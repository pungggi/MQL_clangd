/**
 * Auto-generated MQL5 Standard Library stubs for clangd
 * Header: generated_stubs
 * Generated: 2026-02-01T18:58:27.896Z
 * 
 * DO NOT EDIT - This file is auto-generated by mql-stub-generator
 */

#pragma once

#ifdef __clang__

// Forward declarations
class CArray;
class CArrayChar;
class CArrayColor;
class CArrayDatetime;
class CArrayDouble;
class CArrayFloat;
class CArrayInt;
class CArrayLong;
class CArrayObj;
class CArrayShort;
class CArrayString;
class CArrayUChar;
class CArrayUInt;
class CArrayULong;
class CArrayUShort;
class CList;
class CTree;
class CTreeNode;
class CCanvas;
struct BitmapHeader;
class CChartCanvas;
class CHistogramChart;
class CLineChart;
class CPieChart;
class CDXBox;
class CDXVertexBuffer;
class CDXIndexBuffer;
class CDXDispatcher;
struct DXColor;
struct DXPlane;
struct DXVector2;
struct DXVector3;
struct DXVector4;
struct DXMatrix;
struct DXQuaternion;
struct DViewport;
class CDXMesh;
class CDXSurface;
struct OBJFaceType;
struct GRADIENT_COLOR;
struct GRADIENT_SIZE;
class CFlameCanvas;
class CChartObject;
class CChartObjectPanel;
class CChartObjectArrow;
class CChartObjectArrowThumbUp;
class CChartObjectArrowThumbDown;
class CChartObjectArrowUp;
class CChartObjectArrowDown;
class CChartObjectArrowStop;
class CChartObjectArrowCheck;
class CChartObjectArrowLeftPrice;
class CChartObjectArrowRightPrice;
class CChartObjectBitmap;
class CChartObjectBmpLabel;
class CChartObjectChannel;
class CChartObjectStdDevChannel;
class CChartObjectRegression;
class CChartObjectPitchfork;
class CChartObjectElliottWave3;
class CChartObjectElliottWave5;
class CChartObjectFibo;
class CChartObjectFiboTimes;
class CChartObjectFiboFan;
class CChartObjectFiboArc;
class CChartObjectFiboChannel;
class CChartObjectFiboExpansion;
class CChartObjectGannLine;
class CChartObjectGannFan;
class CChartObjectGannGrid;
class CChartObjectVLine;
class CChartObjectHLine;
class CChartObjectTrend;
class CChartObjectTrendByAngle;
class CChartObjectCycles;
class CChartObjectRectangle;
class CChartObjectTriangle;
class CChartObjectEllipse;
class CChartObjectText;
class CChartObjectLabel;
class CChartObjectEdit;
class CChartObjectButton;
class CChartObjectRectLabel;
class CChartObjectSubChart;
class CChart;
class CBmpButton;
class CButton;
class CCheckBox;
class CCheckGroup;
class CComboBox;
class CDateDropList;
class CDatePicker;
class CDialog;
class CAppDialog;
class CEdit;
class CLabel;
class CListView;
class CPanel;
class CPicture;
class CRadioButton;
class CRadioGroup;
struct CPoint;
struct CSize;
struct CRect;
class CScroll;
class CScrollV;
class CScrollH;
class CSpinEdit;
class CWnd;
class CDragWnd;
class CWndClient;
class CWndContainer;
class CWndObj;
class CExpertBase;
class CExpertMoney;
class CExpertSignal;
class CExpertTrade;
class CExpertTrailing;
class CMoneyFixedLot;
class CMoneyFixedMargin;
class CMoneyFixedRisk;
class CMoneyNone;
class CMoneySizeOptimized;
class CSignalAC;
class CSignalAMA;
class CSignalAO;
class CSignalBearsPower;
class CSignalBullsPower;
class CSignalCCI;
class CSignalDEMA;
class CSignalDeM;
class CSignalEnvelopes;
class CSignalFrAMA;
class CSignalITF;
class CSignalMA;
class CSignalMACD;
class CSignalRSI;
class CSignalRVI;
class CSignalSAR;
class CSignalStoch;
class CSignalTEMA;
class CSignalTriX;
class CSignalWPR;
class CTrailingFixedPips;
class CTrailingMA;
class CTrailingNone;
class CTrailingPSAR;
class CFile;
class CFileBin;
struct BITMAPFILEHEADER;
struct BITMAPINFOHEADER;
class CFileBMP;
class CFilePipe;
class CFileTxt;
struct Slot;
struct Introsort;
class CPrimeGenerator;
class CLinkedListNode;
class CAxis;
class CColorGenerator;
struct CPoint2D;
class CCurve;
class CiAC;
class CiAlligator;
class CiAO;
class CiFractals;
class CiGator;
class CiBWMFI;
class CiCustom;
class CIndicatorBuffer;
class CIndicator;
class CIndicators;
class CiATR;
class CiBearsPower;
class CiBullsPower;
class CiCCI;
class CiChaikin;
class CiDeMarker;
class CiForce;
class CiMACD;
class CiMomentum;
class CiOsMA;
class CiRSI;
class CiRVI;
class CiStochastic;
class CiWPR;
class CiTriX;
class CSeries;
class CDoubleBuffer;
class CPriceSeries;
class COpenBuffer;
class CiOpen;
class CHighBuffer;
class CiHigh;
class CLowBuffer;
class CiLow;
class CCloseBuffer;
class CiClose;
class CSpreadBuffer;
class CiSpread;
class CTimeBuffer;
class CiTime;
class CTickVolumeBuffer;
class CiTickVolume;
class CRealVolumeBuffer;
class CiRealVolume;
class CiADX;
class CiADXWilder;
class CiBands;
class CiEnvelopes;
class CiIchimoku;
class CiMA;
class CiSAR;
class CiStdDev;
class CiDEMA;
class CiTEMA;
class CiFrAMA;
class CiAMA;
class CiVIDyA;
class CiAD;
class CiMFI;
class CiOBV;
class CiVolumes;
class CAlglib;
class CSCodes;
struct CApBuff;
class CApServ;
class CTSort;
class CBasicStatOps;
class CAblasF;
class CBlas;
class CHblas;
class CReflections;
class CComplexReflections;
class CSblas;
class CRotations;
class CTrLinSolve;
class CSafeSolve;
class CXblas;
struct CLinMinState;
struct CArmijoState;
class CLinMin;
struct CFtPlan;
class CFtBase;
class CNearUnitYUnit;
class CNTheory;
struct CMLPBuffers;
class CHPCCores;
class CKDTreeRequestBuffer;
class CKDTreeRequestBufferShell;
class CKDTree;
class CKDTreeShell;
class CNearestNeighbor;
struct RCommState;
class CAp;
class CHighQualityRandState;
class CHighQualityRandStateShell;
class CHighQualityRand;
class CMath;
class CSerializer;
class BitConverter;
class CInfOrNaN;
struct al_complex;
struct CCVReport;
class CBdSS;
struct CDFWorkBuf;
struct CDFVoteBuf;
struct CDFPermimpBuf;
struct CDFTreeBuf;
struct CDecisionForestBuilder;
struct CDecisionForestBuffer;
class CDecisionForest;
class CDecisionForestShell;
class CDFReport;
class CDFReportShell;
struct CDFInternalBuffers;
class CDForest;
class CKMeans;
class CLDA;
class CLinearModel;
class CLinearModelShell;
class CLRReport;
class CLRReportShell;
class CLinReg;
struct CModelErrors;
struct CSMLPGrad;
class CMultilayerPerceptron;
class CMultilayerPerceptronShell;
class CMLPBase;
class CLogitModel;
class CLogitModelShell;
struct CLogitMCState;
class CMNLReport;
class CMNLReportShell;
class CLogit;
class CMCPDState;
class CMCPDStateShell;
class CMCPDReport;
class CMCPDReportShell;
class CMarkovCPD;
class CMLPReport;
class CMLPReportShell;
class CMLPCVReport;
class CMLPCVReportShell;
class CMLPEnsemble;
class CMLPEnsembleShell;
struct CSMLPTrnSession;
struct CMLPTrainer;
class CMLPTrain;
class CMLPE;
class CPCAnalysis;
struct CKmeansBuffers;
struct CClusterizerState;
struct CAHCReport;
struct CKmeansReport;
class CClustering;
class CFilters;
struct CSSAModel;
class CSSA;
struct CKNNBuffer;
struct CKNNBuilder;
struct CKNNModel;
struct CKNNReport;
class CKNN;
class CNDimensional_Func;
class CNDimensional_Grad;
class CNDimensional_Hess;
class CNDimensional_FVec;
class CNDimensional_Jac;
class CNDimensional_PFunc;
class CNDimensional_PGrad;
class CNDimensional_PHess;
class CNDimensional_ODE_RP;
class CIntegrator1_Func;
class CNDimensional_Rep;
class CODESolverState;
class CODESolverStateShell;
class CODESolverReport;
class CODESolverReportShell;
class CODESolver;
class CFastFourierTransform;
class CConv;
class CCorr;
class CFastHartleyTransform;
class CGaussQ;
class CGaussKronrodQ;
class CAutoGKReport;
class CAutoGKReportShell;
struct CAutoGKInternalState;
class CAutoGKState;
class CAutoGKStateShell;
class CAutoGK;
class CIDWCalcBuffer;
class CIDWModel;
class CIDWModelShell;
struct CIDWBuilder;
struct CIDWReport;
class CIDWInt;
class CBarycentricInterpolant;
class CBarycentricInterpolantShell;
class CRatInt;
class CPolInt;
class CSpline1DInterpolant;
class CSpline1DInterpolantShell;
class CSpline1DFitReport;
class CSpline1DFitReportShell;
class CSpline1D;
class CPolynomialFitReport;
class CPolynomialFitReportShell;
class CBarycentricFitReport;
class CBarycentricFitReportShell;
class CLSFitReport;
class CLSFitReportShell;
class CLSFitState;
class CLSFitStateShell;
class CLSFit;
class CPSpline2Interpolant;
class CPSpline2InterpolantShell;
class CPSpline3Interpolant;
class CPSpline3InterpolantShell;
class CPSpline;
class CSpline2DInterpolant;
class CSpline2DInterpolantShell;
class CSpline2DBuilder;
struct CSpline2DFitReport;
struct CSpline2DXDesignMatrix;
struct CSpline2DBlockLLSBuf;
struct CSpline2DFastDDMBuf;
class CSpline2D;
class CIntFitServ;
struct CFitSphereInternalReport;
class CFitSphere;
struct CRBFV1CalcBuffer;
struct CRBFV1Model;
struct CGridCalc3v1Buf;
class CRBFV1Report;
class CRBFV1;
struct CRBFV2CalcBuffer;
struct CRBFV2Model;
struct CRBFV2GridCalcBuffer;
struct CRBFV2Report;
class CRBFV2;
struct CRBF3EvaluatorBuffer;
struct CRBF3Evaluator;
struct CRBFV3CalcBuffer;
struct CACBFBuffer;
struct CACBFChunk;
struct CACBFBuilder;
struct CRBF3DDMBuffer;
struct CRBF3DDMSubproblem;
struct CRBF3DDMSolver;
struct CRBFV3Model;
struct CRBFV3Report;
class CRBFV3;
struct CRBFCalcBuffer;
struct CRBFModel;
struct CRBFReport;
class CRBF;
struct CSpline3DInterpolant;
class CSpline3D;
class CIntComp;
class CAblas;
class COrtFac;
struct CSparseMatrix;
struct CSparseBuffers;
class CSparse;
struct CEigSubSpaceState;
struct CEigSubSpaceReport;
class CEigenVDetect;
class CMatGen;
struct CAmdKNSet;
struct CAmdNSet;
struct CAmdVertexSet;
struct CAmdLLMatrix;
struct CAmdBuffer;
struct CSpCholAnalysis;
struct CSparseDecompositionAnalysis;
class CTrFac;
class CDLU;
class CRCond;
class CMatInvReport;
class CMatInvReportShell;
class CMatInv;
class CBdSingValueDecompose;
class CSingValueDecompose;
struct CFblsLinCgState;
struct CFblsGMRESState;
class CFbls;
class CMatDet;
class CSpdGEVD;
class CInverseUpdate;
class CSchur;
class CSLUV2List1Matrix;
struct CSLUV2SparseTrail;
struct CSLUV2DenseTrail;
struct CSLUV2Buffer;
class CSpTrf;
class CAmdOrdering;
class CSpChol;
struct CNormEstimatorState;
class CNormEstimator;
class CHsSchur;
class CRowDouble;
class CRowInt;
class CRowComplex;
class CMatrixDouble;
class CMatrixInt;
class CMatrixComplex;
struct COptGuardReport;
struct COptGuardNonC0Report;
struct COptGuardNonC1Test0Report;
struct COptGuardNonC1Test1Report;
class COptGuardApi;
struct CPrecBufLBFGS;
struct CPrecBufLowRank;
struct CSmoothnessMonitor;
class COptServ;
class CMinCGState;
class CMinCGStateShell;
class CMinCGReport;
class CMinCGReportShell;
class CMinCG;
struct CSNNLSSolver;
class CSNNLS;
struct CSActiveSet;
class CSActiveSets;
class CMinBLEICState;
class CMinBLEICStateShell;
class CMinBLEICReport;
class CMinBLEICReportShell;
class CMinBLEIC;
class CMinLBFGSState;
class CMinLBFGSStateShell;
class CMinLBFGSReport;
class CMinLBFGSReportShell;
class CMinLBFGS;
struct CVIPMVars;
struct CVIPMReducedSparseSystem;
struct CVIPMRightHandSide;
struct CVIPMState;
class CVIPMSolver;
struct CConvexQuadraticModel;
class CCQModels;
struct CQQPSettings;
struct CQQPBuffers;
class CQQPSolver;
struct CQPDenseAULSettings;
struct CQPDenseAULBuffers;
class CQPDenseAULSolver;
struct CQPBLEICSettings;
struct CQPBLEICbuffers;
class CQPBLEICSolver;
class CMinQPState;
class CMinQPStateShell;
class CMinQPReport;
class CMinQPReportShell;
class CMinQP;
struct CMinLMStepFinder;
class CMinLMState;
class CMinLMStateShell;
class CMinLMReport;
class CMinLMReportShell;
class CMinLM;
class CMinASAState;
class CMinASAStateShell;
class CMinASAReport;
class CMinASAReportShell;
class CMinComp;
class CLPQPServ;
struct CMinSQPSubSolver;
struct CMinSQPTmpLagrangian;
struct CMinSQPTmpMerit;
struct CMinSQPMeritPhaseState;
struct CMinSQPState;
class CNLCSQP;
struct CPresolveInfo;
class CLPQPPresolve;
struct CDualSimplexSettings;
struct CDSSVector;
struct CDualSimplexBasis;
struct CDualSimplexSubproblem;
struct CDualSimplexState;
class CRevisedDualSimplex;
struct CMinLPState;
struct CMinLPReport;
class CMinLP;
struct CMinSLPSubsolver;
struct CMinSLPTmpLagrangian;
struct CMinSLPTmpMerit;
struct CMinSLPPhase13State;
struct CMinSLPPhase2State;
struct CMinSLPState;
class CNLCSLP;
struct CMinNLCState;
struct CMinNLCReport;
class CMinNLC;
struct CMinNSQP;
struct CMinNSState;
struct CMinNSReport;
class CMinNS;
struct CMinBCState;
struct CMinBCReport;
class CMinBC;
struct CLPTestProblem;
class COPTS;
class CDenseSolverReport;
class CDenseSolverReportShell;
class CDenseSolverLSReport;
class CDenseSolverLSReportShell;
class CDenseSolver;
class CNlEqState;
class CNlEqStateShell;
class CNlEqReport;
class CNlEqReportShell;
class CNlEq;
struct CPolynomialSolverReport;
class CPolynomialSolver;
struct CSparseSolverReport;
class CDirectSparseSolvers;
struct CSparseSolverState;
class CIterativeSparse;
struct CLinCGState;
struct CLinCGReport;
class CLinCG;
struct CLinLSQRState;
struct CLinLSQRReport;
class CLinLSQR;
class CGammaFunc;
class CNormalDistr;
class CIncGammaF;
class CAiryF;
class CBessel;
class CBetaF;
class CIncBetaF;
class CBinomialDistr;
class CChebyshev;
class CChiSquareDistr;
class CDawson;
class CElliptic;
class CExpIntegrals;
class CFDistr;
class CFresnel;
class CHermite;
class CJacobianElliptic;
class CLaguerre;
class CLegendre;
class CPoissonDistr;
class CPsiF;
class CStudenttDistr;
class CTrigIntegrals;
class CBaseStat;
class CCorrTests;
class CJarqueBera;
class CMannWhitneyU;
class CSignTest;
class CStudentTests;
class CVarianceTests;
class CWilcoxonSignedRank;
class CDictionary_Obj_Obj;
class CDictionary_String_Obj;
class CDictionary_Obj_Double;
class ICondition;
class CSingleCondition;
class CFuzzyCondition;
class CConditions;
class IParsableRule;
class CGenericFuzzyRule;
class CMamdaniFuzzyRule;
class CSugenoFuzzyRule;
class CFuzzyTerm;
class CFuzzyVariable;
class CGenericFuzzySystem;
class INamedValue;
class INamedVariable;
class CNamedVariableImpl;
class CNamedValueImpl;
class CNameHelper;
class CMamdaniFuzzySystem;
class IMembershipFunction;
class CNormalCombinationMembershipFunction;
class CGeneralizedBellShapedMembershipFunction;
class CS_ShapedMembershipFunction;
class CZ_ShapedMembershipFunction;
class CP_ShapedMembershipFunction;
class CSigmoidalMembershipFunction;
class CProductTwoSigmoidalMembershipFunctions;
class CDifferencTwoSigmoidalMembershipFunction;
class CTrapezoidMembershipFunction;
class CNormalMembershipFunction;
class CTriangularMembershipFunction;
class CConstantMembershipFunction;
class CCompositeMembershipFunction;
class IExpression;
class CLexem;
class CConditionExpression;
class CKeywordLexem;
class CVarLexem;
class IAltLexem;
class CTermLexem;
class CRuleParser;
class CSugenoFuzzySystem;
class ISugenoFunction;
class CLinearSugenoFunction;
class CSugenoVariable;
class COpenCL;
class CString;
class CAccountInfo;
class CDealInfo;
class CHistoryOrderInfo;
class COrderInfo;
class CPositionInfo;
class CSymbolInfo;
class CTerminalInfo;
class CTrade;
struct BY_HANDLE_FILE_INFORMATION;
struct CREATEFILE2_EXTENDED_PARAMETERS;
struct FILE_ATTRIBUTE_DATA;
struct FIND_STREAM_DATA;
struct FIND_DATAW;
struct ENUMUILANG;
struct WIN32_MEMORY_RANGE_ENTRY;
struct PROCESS_INFORMATION;
struct STARTUPINFOW;
struct MEMORY_PRIORITY_INFORMATION;
struct THREAD_POWER_THROTTLING_STATE;
struct APP_MEMORY_INFORMATION;
struct PROCESS_MEMORY_EXHAUSTION_INFO;
struct PROCESS_POWER_THROTTLING_STATE;
struct PROCESS_PROTECTION_LEVEL_INFORMATION;
struct DUMMYSTRUCTNAME;
struct MEMORYSTATUSEX;
struct SYSTEM_INFO;
struct ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
struct ACTCTX_SECTION_KEYED_DATA;
struct ACTCTX_SECTION_KEYED_DATA_2600;
struct ACTCTXW;
struct ACTIVATION_CONTEXT_BASIC_INFORMATION;
struct DCB;
struct COMMCONFIG;
struct COMMPROP;
struct COMMTIMEOUTS;
struct COMSTAT;
struct COPYFILE2_EXTENDED_PARAMETERS;
struct EVENTLOG_FULL_INFORMATION;
struct FILE_ALIGNMENT_INFO;
struct FILE_ALLOCATION_INFO;
struct FILE_ATTRIBUTE_TAG_INFO;
struct FILE_BASIC_INFO;
struct FILE_COMPRESSION_INFO;
struct FILE_DISPOSITION_INFO;
struct FILE_DISPOSITION_INFO_EX;
struct FILE_END_OF_FILE_INFO;
struct FILE_FULL_DIR_INFO;
struct FILE_ID_BOTH_DIR_INFO;
struct FILE_ID_EXTD_DIR_INFO;
struct FILE_ID_INFO;
struct FILE_IO_PRIORITY_HINT_INFO;
struct FILE_NAME_INFO;
struct FILE_STANDARD_INFO;
struct FILE_STORAGE_INFO;
struct FILE_STREAM_INFO;
struct HW_PROFILE_INFOW;
struct JIT_DEBUG_INFO;
struct MEMORYSTATUS;
struct OFSTRUCT;
struct OPERATION_END_PARAMETERS;
struct OPERATION_START_PARAMETERS;
struct SYSTEM_POWER_STATUS;
struct UMS_SCHEDULER_STARTUP_INFO;
struct WIN32_STREAM_ID;
struct UMS_SYSTEM_THREAD_INFORMATION;
struct FILE_ID_DESCRIPTOR;
struct SYSTEMTIME;
struct REASON_CONTEXT;
struct OVERLAPPED;
struct LDT_ENTRY;
struct GUID;
struct FILETIME;
struct POINT;
struct POINTL;
struct POINTS;
struct RECT;
struct RECTL;
struct SIZE;
struct FILE_INFO;
struct CLAIM_SECURITY_ATTRIBUTE_V1;
struct CLAIM_SECURITY_ATTRIBUTES_INFORMATION;
struct ABC;
struct ABCFLOAT;
struct AXISINFOW;
struct AXESLISTW;
struct BITMAP;
struct BITMAPCOREHEADER;
struct RGBTRIPLE;
struct BITMAPCOREINFO;
struct RGBQUAD;
struct BITMAPINFO;
struct CIEXYZ;
struct CIEXYZTRIPLE;
struct BITMAPV4HEADER;
struct BITMAPV5HEADER;
struct BLENDFUNCTION;
struct FONTSIGNATURE;
struct CHARSETINFO;
struct COLORADJUSTMENT;
struct DESIGNVECTOR;
struct DIBSECTION;
struct DISPLAY_DEVICEA;
struct DISPLAY_DEVICEW;
struct DISPLAYCONFIG_2DREGION;
struct DISPLAYCONFIG_DEVICE_INFO_HEADER;
struct DISPLAYCONFIG_ADAPTER_NAME;
struct DISPLAYCONFIG_DESKTOP_IMAGE_INFO;
struct DISPLAYCONFIG_PATH_SOURCE_INFO;
struct DISPLAYCONFIG_RATIONAL;
struct DISPLAYCONFIG_PATH_TARGET_INFO;
struct DISPLAYCONFIG_PATH_INFO;
struct DISPLAYCONFIG_SDR_WHITE_LEVEL;
struct DISPLAYCONFIG_SOURCE_DEVICE_NAME;
struct DISPLAYCONFIG_SOURCE_MODE;
struct DISPLAYCONFIG_TARGET_BASE_TYPE;
struct DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS;
struct DISPLAYCONFIG_TARGET_DEVICE_NAME;
struct DISPLAYCONFIG_VIDEO_SIGNAL_INFO;
struct DISPLAYCONFIG_TARGET_MODE;
struct DISPLAYCONFIG_TARGET_PREFERRED_MODE;
struct DOCINFOW;
struct DRAWPATRECT;
struct EMR;
struct EMRABORTPATH;
struct XFORM;
struct EMRALPHABLEND;
struct EMRANGLEARC;
struct EMRARC;
struct EMRBITBLT;
struct EMRCOLORCORRECTPALETTE;
struct EMRCOLORMATCHTOTARGET;
struct LOGBRUSH;
struct EMRCREATEBRUSHINDIRECT;
struct LOGCOLORSPACEW;
struct EMRCREATECOLORSPACEW;
struct EMRCREATEDIBPATTERNBRUSHPT;
struct EMRCREATEMONOBRUSH;
struct LOGPALETTE;
struct LOGPEN;
struct EMRCREATEPALETTE;
struct EMRCREATEPEN;
struct EMRELLIPSE;
struct EMREOF;
struct EMREXCLUDECLIPRECT;
struct LOGFONTW;
struct PANOSE;
struct EXTLOGFONTW;
struct EMREXTCREATEFONTINDIRECTW;
struct EXTLOGPEN;
struct EMREXTCREATEPEN;
struct EMREXTESCAPE;
struct EMREXTFLOODFILL;
struct EMREXTSELECTCLIPRGN;
struct EMRTEXT;
struct EMREXTTEXTOUTA;
struct EMRFILLPATH;
struct EMRFILLRGN;
struct EMRFORMAT;
struct EMRFRAMERGN;
struct EMRGDICOMMENT;
struct EMRGLSBOUNDEDRECORD;
struct EMRGLSRECORD;
struct PIXELFORMATDESCRIPTOR;
struct TRIVERTEX;
struct EMRGRADIENTFILL;
struct EMRINVERTRGN;
struct EMRLINETO;
struct EMRMASKBLT;
struct EMRMODIFYWORLDTRANSFORM;
struct EMRNAMEDESCAPE;
struct EMROFFSETCLIPRGN;
struct EMRPIXELFORMAT;
struct EMRPLGBLT;
struct EMRPOLYDRAW;
struct EMRPOLYDRAW16;
struct EMRPOLYLINE;
struct EMRPOLYLINE16;
struct EMRPOLYPOLYLINE;
struct EMRPOLYPOLYLINE16;
struct EMRPOLYTEXTOUTW;
struct EMRRESIZEPALETTE;
struct EMRRESTOREDC;
struct EMRROUNDRECT;
struct EMRSCALEVIEWPORTEXTEX;
struct EMRSELECTCLIPPATH;
struct EMRSELECTOBJECT;
struct EMRSELECTPALETTE;
struct EMRSETARCDIRECTION;
struct EMRSETBKCOLOR;
struct EMRSETCOLORADJUSTMENT;
struct EMRSETCOLORSPACE;
struct EMRSETDIBITSTODEVICE;
struct EMRSETICMPROFILE;
struct EMRSETMAPPERFLAGS;
struct EMRSETMITERLIMIT;
struct PALETTEENTRY;
struct EMRSETPALETTEENTRIES;
struct EMRSETPIXELV;
struct EMRSETVIEWPORTEXTEX;
struct EMRSETVIEWPORTORGEX;
struct EMRSETWORLDTRANSFORM;
struct EMRSTRETCHBLT;
struct EMRSTRETCHDIBITS;
struct EMRTRANSPARENTBLT;
struct ENHMETAHEADER;
struct ENHMETARECORD;
struct ENUMLOGFONTEXW;
struct ENUMLOGFONTEXDVW;
struct ENUMLOGFONTW;
struct NEWTEXTMETRICW;
struct NEWTEXTMETRICEXW;
struct ENUMTEXTMETRICW;
struct FIXED;
struct POINTFLOAT;
struct GCP_RESULTSW;
struct GLYPHMETRICS;
struct GLYPHMETRICSFLOAT;
struct WCRANGE;
struct GLYPHSET;
struct GRADIENT_RECT;
struct GRADIENT_TRIANGLE;
struct HANDLETABLE;
struct KERNINGPAIR;
struct LAYERPLANEDESCRIPTOR;
struct LOCALESIGNATURE;
struct MAT2;
struct METAFILEPICT;
struct METAHEADER;
struct METARECORD;
struct TEXTMETRICW;
struct OUTLINETEXTMETRICW;
struct PELARRAY;
struct POINTFX;
struct POLYTEXTW;
struct PSFEATURE_CUSTPAPER;
struct PSFEATURE_OUTPUT;
struct PSINJECTDATA;
struct RASTERIZER_STATUS;
struct RGNDATAHEADER;
struct RGNDATA;
struct TTPOLYCURVE;
struct TTPOLYGONHEADER;
struct DEVMODEW;
struct WGLSWAP;
struct DISPLAYCONFIG_MODE_INFO;
struct PROCESSOR_NUMBER;
struct GROUP_AFFINITY;
struct FLOAT128;
struct LARGE_INTEGER;
struct ULARGE_INTEGER;
struct LUID;
struct LIST_ENTRY;
struct SINGLE_LIST_ENTRY;
struct LIST_ENTRY32;
struct LIST_ENTRY64;
struct OBJECTID;
struct M128A;
struct XSAVE_FORMAT;
struct XSAVE_AREA_HEADER;
struct XSAVE_AREA;
struct XSTATE_CONTEXT;
struct SCOPE_TABLE_AMD64;
struct UNWIND_HISTORY_TABLE_ENTRY;
struct UNWIND_HISTORY_TABLE;
struct SCOPE_TABLE_ARM64;
struct NEON128;
struct DISPATCHER_CONTEXT;
struct KNONVOLATILE_CONTEXT_POINTERS;
struct SCOPE_TABLE_ARM;
struct DISPATCHER_CONTEXT_ARM64;
struct KNONVOLATILE_CONTEXT_POINTERS_ARM64;
struct FLOATING_SAVE_AREA;
struct CONTEXT;
struct WOW64_FLOATING_SAVE_AREA;
struct WOW64_CONTEXT;
struct WOW64_LDT_ENTRY;
struct WOW64_DESCRIPTOR_TABLE_ENTRY;
struct EXCEPTION_RECORD;
struct EXCEPTION_RECORD32;
struct EXCEPTION_RECORD64;
struct EXCEPTION_POINTERS;
struct GENERIC_MAPPING;
struct LUID_AND_ATTRIBUTES;
struct SID_IDENTIFIER_AUTHORITY;
struct SID;
struct SID_AND_ATTRIBUTES;
struct SID_AND_ATTRIBUTES_HASH;
struct ACL;
struct ACE_HEADER;
struct ACCESS_ALLOWED_ACE;
struct ACCESS_DENIED_ACE;
struct SYSTEM_AUDIT_ACE;
struct SYSTEM_ALARM_ACE;
struct SYSTEM_RESOURCE_ATTRIBUTE_ACE;
struct SYSTEM_SCOPED_POLICY_ID_ACE;
struct SYSTEM_MANDATORY_LABEL_ACE;
struct SYSTEM_PROCESS_TRUST_LABEL_ACE;
struct SYSTEM_ACCESS_FILTER_ACE;
struct ACCESS_ALLOWED_OBJECT_ACE;
struct ACCESS_DENIED_OBJECT_ACE;
struct SYSTEM_AUDIT_OBJECT_ACE;
struct SYSTEM_ALARM_OBJECT_ACE;
struct ACCESS_ALLOWED_CALLBACK_ACE;
struct ACCESS_DENIED_CALLBACK_ACE;
struct SYSTEM_AUDIT_CALLBACK_ACE;
struct SYSTEM_ALARM_CALLBACK_ACE;
struct ACCESS_ALLOWED_CALLBACK_OBJECT_ACE;
struct ACCESS_DENIED_CALLBACK_OBJECT_ACE;
struct SYSTEM_AUDIT_CALLBACK_OBJECT_ACE;
struct SYSTEM_ALARM_CALLBACK_OBJECT_ACE;
struct ACL_REVISION_INFORMATION;
struct ACL_SIZE_INFORMATION;
struct SECURITY_DESCRIPTOR_RELATIVE;
struct SECURITY_DESCRIPTOR;
struct SECURITY_OBJECT_AI_PARAMS;
struct OBJECT_TYPE_LIST;
struct PRIVILEGE_SET;
struct ACCESS_REASONS;
struct SE_SECURITY_DESCRIPTOR;
struct SE_ACCESS_REQUEST;
struct SE_ACCESS_REPLY;
struct TOKEN_USER;
struct SE_TOKEN_USER;
struct TOKEN_GROUPS;
struct TOKEN_PRIVILEGES;
struct TOKEN_OWNER;
struct TOKEN_PRIMARY_GROUP;
struct TOKEN_DEFAULT_DACL;
struct TOKEN_USER_CLAIMS;
struct TOKEN_DEVICE_CLAIMS;
struct TOKEN_GROUPS_AND_PRIVILEGES;
struct TOKEN_LINKED_TOKEN;
struct TOKEN_ELEVATION;
struct TOKEN_MANDATORY_LABEL;
struct TOKEN_MANDATORY_POLICY;
struct TOKEN_ACCESS_INFORMATION;
struct TOKEN_AUDIT_POLICY;
struct TOKEN_SOURCE;
struct TOKEN_STATISTICS;
struct TOKEN_CONTROL;
struct TOKEN_ORIGIN;
struct TOKEN_APPCONTAINER_INFORMATION;
struct TOKEN_SID_INFORMATION;
struct TOKEN_BNO_ISOLATION_INFORMATION;
struct CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE;
struct CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;
struct CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1;
struct Attribute;
struct SECURITY_QUALITY_OF_SERVICE;
struct SE_IMPERSONATION_STATE;
struct SECURITY_CAPABILITIES;
struct JOB_SET_ARRAY;
struct EXCEPTION_REGISTRATION_RECORD;
struct NT_TIB;
struct UMS_CREATE_THREAD_ATTRIBUTES;
struct WOW64_ARCHITECTURE_INFORMATION;
struct QUOTA_LIMITS;
struct QUOTA_LIMITS_EX;
struct IO_COUNTERS;
struct JOBOBJECT_BASIC_ACCOUNTING_INFORMATION;
struct JOBOBJECT_BASIC_LIMIT_INFORMATION;
struct JOBOBJECT_EXTENDED_LIMIT_INFORMATION;
struct JOBOBJECT_BASIC_PROCESS_ID_LIST;
struct JOBOBJECT_BASIC_UI_RESTRICTIONS;
struct JOBOBJECT_SECURITY_LIMIT_INFORMATION;
struct JOBOBJECT_END_OF_JOB_TIME_INFORMATION;
struct JOBOBJECT_ASSOCIATE_COMPLETION_PORT;
struct JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;
struct JOBOBJECT_JOBSET_INFORMATION;
struct JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION;
struct JOBOBJECT_LIMIT_VIOLATION_INFORMATION;
struct JOBOBJECT_NET_RATE_CONTROL_INFORMATION;
struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE;
struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2;
struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3;
struct JOBOBJECT_IO_ATTRIBUTION_STATS;
struct JOBOBJECT_IO_ATTRIBUTION_INFORMATION;
struct SILOOBJECT_BASIC_INFORMATION;
struct SERVERSILO_BASIC_INFORMATION;
struct CACHE_DESCRIPTOR;
struct ProcessorCore;
struct PROCESSOR_RELATIONSHIP;
struct NUMA_NODE_RELATIONSHIP;
struct CACHE_RELATIONSHIP;
struct PROCESSOR_GROUP_INFO;
struct GROUP_RELATIONSHIP;
struct SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION;
struct XSTATE_FEATURE;
struct XSTATE_CONFIGURATION;
struct MEMORY_BASIC_INFORMATION;
struct MEMORY_BASIC_INFORMATION32;
struct MEMORY_BASIC_INFORMATION64;
struct CFG_CALL_TARGET_INFO;
struct MEM_ADDRESS_REQUIREMENTS;
struct ENCLAVE_CREATE_INFO_SGX;
struct ENCLAVE_INIT_INFO_SGX;
struct ENCLAVE_CREATE_INFO_VBS;
struct ENCLAVE_INIT_INFO_VBS;
struct FILE_ID_128;
struct FILE_NOTIFY_INFORMATION;
struct FILE_NOTIFY_EXTENDED_INFORMATION;
struct GenericReparseBuffer;
struct SCRUB_DATA_INPUT;
struct SCRUB_PARITY_EXTENT;
struct SCRUB_PARITY_EXTENT_DATA;
struct SCRUB_DATA_OUTPUT;
struct SHARED_VIRTUAL_DISK_SUPPORT;
struct NETWORK_APP_INSTANCE_EA;
struct CM_POWER_DATA;
struct POWER_USER_PRESENCE;
struct POWER_SESSION_CONNECT;
struct POWER_SESSION_TIMEOUTS;
struct POWER_SESSION_RIT_STATE;
struct POWER_SESSION_WINLOGON;
struct POWER_IDLE_RESILIENCY;
struct POWER_MONITOR_INVOCATION;
struct RESUME_PERFORMANCE;
struct APPLICATIONLAUNCH_SETTING_VALUE;
struct POWER_PLATFORM_INFORMATION;
struct POWER_ACTION_POLICY;
struct SYSTEM_POWER_LEVEL;
struct SYSTEM_POWER_POLICY;
struct PROCESSOR_POWER_POLICY_INFO;
struct PROCESSOR_POWER_POLICY;
struct ADMINISTRATOR_POWER_POLICY;
struct HIBERFILE_BUCKET;
struct IMAGE_DOS_HEADER;
struct IMAGE_OS2_HEADER;
struct IMAGE_VXD_HEADER;
struct IMAGE_FILE_HEADER;
struct IMAGE_DATA_DIRECTORY;
struct IMAGE_OPTIONAL_HEADER32;
struct IMAGE_ROM_OPTIONAL_HEADER;
struct IMAGE_OPTIONAL_HEADER64;
struct IMAGE_NT_HEADERS64;
struct IMAGE_NT_HEADERS32;
struct IMAGE_ROM_HEADERS;
struct ANON_OBJECT_HEADER;
struct ANON_OBJECT_HEADER_V2;
struct ANON_OBJECT_HEADER_BIGOBJ;
struct IMAGE_SECTION_HEADER;
struct IMAGE_SYMBOL;
struct IMAGE_SYMBOL_EX;
struct IMAGE_AUX_SYMBOL_TOKEN_DEF;
struct IMAGE_LINENUMBER;
struct IMAGE_BASE_RELOCATION;
struct IMAGE_ARCHIVE_MEMBER_HEADER;
struct IMAGE_EXPORT_DIRECTORY;
struct IMAGE_IMPORT_BY_NAME;
struct IMAGE_THUNK_DATA64;
struct IMAGE_THUNK_DATA32;
struct IMAGE_BOUND_IMPORT_DESCRIPTOR;
struct IMAGE_BOUND_FORWARDER_REF;
struct IMAGE_RESOURCE_DIRECTORY;
struct IMAGE_RESOURCE_DIRECTORY_STRING;
struct IMAGE_RESOURCE_DIR_STRING_U;
struct IMAGE_RESOURCE_DATA_ENTRY;
struct IMAGE_LOAD_CONFIG_CODE_INTEGRITY;
struct IMAGE_DYNAMIC_RELOCATION_TABLE;
struct IMAGE_DYNAMIC_RELOCATION32;
struct IMAGE_DYNAMIC_RELOCATION64;
struct IMAGE_DYNAMIC_RELOCATION32_V2;
struct IMAGE_DYNAMIC_RELOCATION64_V2;
struct IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER;
struct IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER;
struct IMAGE_LOAD_CONFIG_DIRECTORY32;
struct IMAGE_LOAD_CONFIG_DIRECTORY64;
struct IMAGE_HOT_PATCH_INFO;
struct IMAGE_HOT_PATCH_BASE;
struct IMAGE_HOT_PATCH_HASHES;
struct IMAGE_CE_RUNTIME_FUNCTION_ENTRY;
struct IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY;
struct IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY;
struct IMAGE_ENCLAVE_CONFIG32;
struct IMAGE_ENCLAVE_CONFIG64;
struct IMAGE_ENCLAVE_IMPORT;
struct IMAGE_DEBUG_DIRECTORY;
struct IMAGE_COFF_SYMBOLS_HEADER;
struct FPO_DATA;
struct IMAGE_DEBUG_MISC;
struct IMAGE_FUNCTION_ENTRY;
struct IMAGE_SEPARATE_DEBUG_HEADER;
struct NON_PAGED_DEBUG_INFO;
struct IMAGE_ARCHITECTURE_HEADER;
struct IMAGE_ARCHITECTURE_ENTRY;
struct SLIST_ENTRY;
struct RTL_BARRIER;
struct MESSAGE_RESOURCE_ENTRY;
struct MESSAGE_RESOURCE_BLOCK;
struct MESSAGE_RESOURCE_DATA;
struct OSVERSIONINFOW;
struct OSVERSIONINFOEXW;
struct NV_MEMORY_RANGE;
struct CORRELATION_VECTOR;
struct CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG;
struct IMAGE_POLICY_ENTRY;
struct IMAGE_POLICY_METADATA;
struct RTL_CRITICAL_SECTION_DEBUG;
struct RTL_CRITICAL_SECTION;
struct RTL_SRWLOCK;
struct RTL_CONDITION_VARIABLE;
struct HEAP_OPTIMIZE_RESOURCES_INFORMATION;
struct ACTIVATION_CONTEXT_QUERY_INDEX;
struct ASSEMBLY_FILE_DETAILED_INFORMATION;
struct ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;
struct ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;
struct COMPATIBILITY_CONTEXT_ELEMENT;
struct ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;
struct SUPPORTED_OS_INFO;
struct ACTIVATION_CONTEXT_DETAILED_INFORMATION;
struct HARDWARE_COUNTER_DATA;
struct PERFORMANCE_DATA;
struct EVENTLOGRECORD;
struct TAPE_ERASE;
struct TAPE_PREPARE;
struct TAPE_WRITE_MARKS;
struct TAPE_GET_POSITION;
struct TAPE_SET_POSITION;
struct TAPE_GET_DRIVE_PARAMETERS;
struct TAPE_SET_DRIVE_PARAMETERS;
struct TAPE_GET_MEDIA_PARAMETERS;
struct TAPE_SET_MEDIA_PARAMETERS;
struct TAPE_CREATE_PARTITION;
struct TAPE_WMI_OPERATIONS;
struct TRANSACTION_BASIC_INFORMATION;
struct TRANSACTIONMANAGER_BASIC_INFORMATION;
struct TRANSACTIONMANAGER_LOG_INFORMATION;
struct TRANSACTIONMANAGER_LOGPATH_INFORMATION;
struct TRANSACTIONMANAGER_RECOVERY_INFORMATION;
struct TRANSACTIONMANAGER_OLDEST_INFORMATION;
struct TRANSACTION_PROPERTIES_INFORMATION;
struct TRANSACTION_BIND_INFORMATION;
struct TRANSACTION_ENLISTMENT_PAIR;
struct TRANSACTION_ENLISTMENTS_INFORMATION;
struct TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;
struct RESOURCEMANAGER_BASIC_INFORMATION;
struct RESOURCEMANAGER_COMPLETION_INFORMATION;
struct ENLISTMENT_BASIC_INFORMATION;
struct ENLISTMENT_CRM_INFORMATION;
struct TRANSACTION_LIST_ENTRY;
struct TRANSACTION_LIST_INFORMATION;
struct KTMOBJECT_CURSOR;
struct TP_POOL_STACK_INFORMATION;
struct TP_CALLBACK_ENVIRON_V3;
struct SYSTEM_LOGICAL_PROCESSOR_INFORMATION;
struct SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;
struct SYSTEM_CPU_SET_INFORMATION;
struct VALENTW;
struct ACCEL;
struct ACCESSTIMEOUT;
struct ALTTABINFO;
struct ANIMATIONINFO;
struct AUDIODESCRIPTION;
struct BSMINFO;
struct CBT_CREATEWNDA;
struct CBT_CREATEWNDW;
struct CBTACTIVATESTRUCT;
struct CHANGEFILTERSTRUCT;
struct CLIENTCREATESTRUCT;
struct COMBOBOXINFO;
struct COMPAREITEMSTRUCT;
struct COPYDATASTRUCT;
struct CURSORINFO;
struct CURSORSHAPE;
struct CWPRETSTRUCT;
struct CWPSTRUCT;
struct DEBUGHOOKINFO;
struct DELETEITEMSTRUCT;
struct DLGITEMTEMPLATE;
struct DLGTEMPLATE;
struct DRAWITEMSTRUCT;
struct DRAWTEXTPARAMS;
struct DROPSTRUCT;
struct EVENTMSG;
struct FILTERKEYS;
struct FLASHWINFO;
struct GESTURECONFIG;
struct GESTUREINFO;
struct GESTURENOTIFYSTRUCT;
struct GUITHREADINFO;
struct HARDWAREHOOKSTRUCT;
struct HARDWAREINPUT;
struct HELPINFO;
struct HELPWININFOA;
struct HELPWININFOW;
struct HIGHCONTRASTW;
struct ICONINFO;
struct ICONINFOEXW;
struct ICONMETRICSW;
struct INPUT_INJECTION_VALUE;
struct INPUT_MESSAGE_SOURCE;
struct KBDLLHOOKSTRUCT;
struct KEYBDINPUT;
struct LASTINPUTINFO;
struct MDICREATESTRUCTW;
struct MDINEXTMENU;
struct MEASUREITEMSTRUCT;
struct MENUBARINFO;
struct MENUGETOBJECTINFO;
struct MENUINFO;
struct MENUITEMINFOW;
struct MENUITEMTEMPLATE;
struct MENUITEMTEMPLATEHEADER;
struct MINIMIZEDMETRICS;
struct MINMAXINFO;
struct MONITORINFO;
struct MOUSEHOOKSTRUCT;
struct MOUSEHOOKSTRUCTEX;
struct MOUSEKEYS;
struct MOUSEMOVEPOINT;
struct MSG;
struct MSGBOXPARAMSW;
struct MSLLHOOKSTRUCT;
struct MULTIKEYHELPW;
struct NCCALCSIZE_PARAMS;
struct NMHDR;
struct NONCLIENTMETRICSW;
struct PAINTSTRUCT;
struct POINTER_DEVICE_CURSOR_INFO;
struct POINTER_DEVICE_PROPERTY;
struct POINTER_INFO;
struct POINTER_PEN_INFO;
struct POINTER_TOUCH_INFO;
struct POWERBROADCAST_SETTING;
struct RAWINPUTDEVICE;
struct RAWINPUTDEVICELIST;
struct RAWINPUTHEADER;
struct RID_DEVICE_INFO_HID;
struct RID_DEVICE_INFO_KEYBOARD;
struct RID_DEVICE_INFO_MOUSE;
struct SCROLLBARINFO;
struct SCROLLINFO;
struct SERIALKEYSW;
struct SHELLHOOKINFO;
struct SOUNDSENTRYW;
struct STICKYKEYS;
struct STYLESTRUCT;
struct TITLEBARINFO;
struct TITLEBARINFOEX;
struct TOGGLEKEYS;
struct TOUCH_HIT_TESTING_INPUT;
struct TOUCH_HIT_TESTING_PROXIMITY_EVALUATION;
struct TOUCHINPUT;
struct TOUCHPREDICTIONPARAMETERS;
struct TPMPARAMS;
struct TRACKMOUSEEVENT;
struct UPDATELAYEREDWINDOWINFO;
struct USAGE_PROPERTIES;
struct USEROBJECTFLAGS;
struct WINDOWINFO;
struct WINDOWPLACEMENT;
struct WINDOWPOS;
struct WTSSESSION_NOTIFICATION;
struct RAWKEYBOARD;
struct RAWHID;
struct RAWINPUT;
struct INPUT_TRANSFORM;
struct MENUITEMINFO;
struct INPUT;
// Base classes from other headers
class CObject;
class CDXHandleShared;
class CDXObjectBase;
class CDXObject;



// Enums
enum ENUM_LINE_END {
    LINE_END_ROUND,
    LINE_END_BUTT,
    LINE_END_SQUARE
};

enum ENUM_SHOW_FLAGS {
    FLAG_SHOW_NONE = 0,
    FLAG_SHOW_LEGEND = 1,
    FLAG_SHOW_SCALE_LEFT = 2,
    FLAG_SHOW_SCALE_RIGHT = 4,
    FLAG_SHOW_SCALE_TOP = 8,
    FLAG_SHOW_SCALE_BOTTOM = 16,
    FLAG_SHOW_GRID = 32,
    FLAG_SHOW_DESCRIPTORS = 64,
    FLAG_SHOW_VALUE = 128,
    FLAG_SHOW_PERCENT = 256,
    FLAGS_SHOW_SCALES = (FLAG_SHOW_SCALE_LEFT+FLAG_SHOW_SCALE_RIGHT+ FLAG_SHOW_SCALE_TOP+FLAG_SHOW_SCALE_BOTTOM),
    FLAGS_SHOW_ALL = (FLAG_SHOW_LEGEND+FLAGS_SHOW_SCALES+FLAG_SHOW_GRID+ FLAG_SHOW_DESCRIPTORS+FLAG_SHOW_VALUE+FLAG_SHOW_PERCENT)
};

enum ENUM_ALIGNMENT {
    ALIGNMENT_LEFT = 1,
    ALIGNMENT_TOP = 2,
    ALIGNMENT_RIGHT = 4,
    ALIGNMENT_BOTTOM = 8
};

enum EN_SURFACE_FLAGS {
    SF_NONE = 0x0,
    SF_TWO_SIDED = 0x1,
    SF_USE_NORMALS = 0x2
};

enum EN_COLOR_SCHEME {
    CS_NONE = 0,
    CS_JET = 1,
    CS_COLD_TO_HOT = 2,
    CS_RED_TO_GREEN = 3
};

enum ENUM_DATE_MODES {
    DATE_MODE_MON,
    DATE_MODE_YEAR
};

enum ENUM_WND_PROP_FLAGS {
    WND_PROP_FLAG_CAN_DBL_CLICK = 1,
    WND_PROP_FLAG_CAN_DRAG = 2,
    WND_PROP_FLAG_CLICKS_BY_PRESS = 4,
    WND_PROP_FLAG_CAN_LOCK = 8,
    WND_PROP_FLAG_READ_ONLY = 16
};

enum ENUM_WND_STATE_FLAGS {
    WND_STATE_FLAG_ENABLE = 1,
    WND_STATE_FLAG_VISIBLE = 2,
    WND_STATE_FLAG_ACTIVE = 4
};

enum ENUM_MOUSE_FLAGS {
    MOUSE_INVALID_FLAGS = -1,
    MOUSE_EMPTY = 0,
    MOUSE_LEFT = 1,
    MOUSE_RIGHT = 2
};

enum ENUM_WND_ALIGN_FLAGS {
    WND_ALIGN_NONE = 0,
    WND_ALIGN_LEFT = 1,
    WND_ALIGN_TOP = 2,
    WND_ALIGN_RIGHT = 4,
    WND_ALIGN_BOTTOM = 8,
    WND_ALIGN_WIDTH = WND_ALIGN_LEFT|WND_ALIGN_RIGHT,
    WND_ALIGN_HEIGHT = WND_ALIGN_TOP|WND_ALIGN_BOTTOM,
    WND_ALIGN_CLIENT = WND_ALIGN_WIDTH|WND_ALIGN_HEIGHT
};

enum ENUM_TYPE_TREND {
    TYPE_TREND_HARD_DOWN = 0,
    TYPE_TREND_DOWN = 1,
    TYPE_TREND_SOFT_DOWN = 2,
    TYPE_TREND_FLAT = 3,
    TYPE_TREND_SOFT_UP = 4,
    TYPE_TREND_UP = 5,
    TYPE_TREND_HARD_UP = 6
};

enum ENUM_USED_SERIES {
    USE_SERIES_OPEN = 0x1,
    USE_SERIES_HIGH = 0x2,
    USE_SERIES_LOW = 0x4,
    USE_SERIES_CLOSE = 0x8,
    USE_SERIES_SPREAD = 0x10,
    USE_SERIES_TIME = 0x20,
    USE_SERIES_TICK_VOLUME = 0x40,
    USE_SERIES_REAL_VOLUME = 0x80
};

enum ENUM_INIT_PHASE {
    INIT_PHASE_FIRST = 0,
    INIT_PHASE_TUNING = 1,
    INIT_PHASE_VALIDATION = 2,
    INIT_PHASE_COMPLETE = 3
};

enum ENUM_AXIS_TYPE {
    AXIS_TYPE_DOUBLE,
    AXIS_TYPE_DATETIME,
    AXIS_TYPE_CUSTOM
};

enum ENUM_CURVE_TYPE {
    CURVE_POINTS,
    CURVE_LINES,
    CURVE_POINTS_AND_LINES,
    CURVE_STEPS,
    CURVE_HISTOGRAM,
    CURVE_CUSTOM,
    CURVE_NONE
};

enum ENUM_POINT_TYPE {
    POINT_CIRCLE,
    POINT_SQUARE,
    POINT_DIAMOND,
    POINT_TRIANGLE,
    POINT_TRIANGLE_DOWN,
    POINT_X_CROSS,
    POINT_PLUS,
    POINT_STAR,
    POINT_HORIZONTAL_DASH,
    POINT_VERTICAL_DASH
};

enum TRACE_MODE {
    TRACE_NONE,
    TRACE_FILE
};

enum SMODE {
    DEFAULT,
    ALLOC,
    TO_STRING,
    FROM_STRING
};

enum OperatorType {
    And,
    Or
};

enum HedgeType {
    None,
    Slightly,
    Somewhat,
    Very,
    Extremely
};

enum EnAndMethod {
    MinAnd,
    ProductionAnd
};

enum EnOrMethod {
    MaxOr,
    ProbabilisticOr
};

enum ImplicationMethod {
    MinIpm,
    ProductionImp
};

enum AggregationMethod {
    MaxAgg,
    SumAgg
};

enum DefuzzificationMethod {
    CentroidDef,
    BisectorDef,
    AverageMaximumDef,
    LargestMaximumDef,
    SmallestMaximumDef
};

enum EnType {
    TYPE_CLASS_INamedValue,
    TYPE_CLASS_INamedVariable,
    TYPE_CLASS_NamedVariableImpl,
    TYPE_CLASS_NamedValueImpl,
    TYPE_CLASS_FuzzyTerm,
    TYPE_CLASS_FuzzyVariable,
    TYPE_CLASS_SugenoVariable,
    TYPE_CLASS_ISugenoFunction,
    TYPE_CLASS_LinearSugenoFunction
};

enum EnLexem {
    TYPE_CLASS_IExpression,
    TYPE_CLASS_Lexem,
    TYPE_CLASS_ConditionExpression,
    TYPE_CLASS_VarLexem,
    TYPE_CLASS_KeywordLexem,
    TYPE_CLASS_AltLexem,
    TYPE_CLASS_TermLexem
};

enum EnCondition {
    TYPE_CLASS_ICondition,
    TYPE_CLASS_Conditions,
    TYPE_CLASS_SingleCondition,
    TYPE_CLASS_FuzzyCondition
};

enum EnRule {
    TYPE_CLASS_IParsableRule,
    TYPE_CLASS_GenericFuzzyRule,
    TYPE_CLASS_MamdaniFuzzyRule,
    TYPE_CLASS_SugenoFuzzyRule
};

enum MfCompositionType {
    MinMF,
    MaxMF,
    ProdMF,
    SumMF
};

enum ENUM_LOG_LEVELS {
    LOG_LEVEL_NO = 0,
    LOG_LEVEL_ERRORS = 1,
    LOG_LEVEL_ALL = 2
};

enum STREAM_INFO_LEVELS {
    FindStreamInfoStandard,
    FindStreamInfoMaxInfoLevel
};

enum MEMORY_RESOURCE_NOTIFICATION_TYPE {
    LowMemoryResourceNotification,
    HighMemoryResourceNotification
};

enum OFFER_PRIORITY {
    VmOfferPriorityVeryLow = 1,
    VmOfferPriorityLow,
    VmOfferPriorityBelowNormal,
    VmOfferPriorityNormal
};

enum WIN32_MEMORY_INFORMATION_CLASS {
    MemoryRegionInfo
};

enum THREAD_INFORMATION_CLASS {
    ThreadMemoryPriority,
    ThreadAbsoluteCpuPriority,
    ThreadDynamicCodePolicy,
    ThreadPowerThrottling,
    ThreadInformationClassMax
};

enum PROCESS_INFORMATION_CLASS {
    ProcessMemoryPriority,
    ProcessMemoryExhaustionInfo,
    ProcessAppMemoryInfo,
    ProcessInPrivateInfo,
    ProcessPowerThrottling,
    ProcessReservedValue1,
    ProcessTelemetryCoverageInfo,
    ProcessProtectionLevelInfo,
    ProcessInformationClassMax
};

enum PROCESS_MEMORY_EXHAUSTION_TYPE {
    PMETypeFailFastOnCommitFailure,
    PMETypeMax
};

enum COMPUTER_NAME_FORMAT {
    ComputerNameNetBIOS,
    ComputerNameDnsHostname,
    ComputerNameDnsDomain,
    ComputerNameDnsFullyQualified,
    ComputerNamePhysicalNetBIOS,
    ComputerNamePhysicalDnsHostname,
    ComputerNamePhysicalDnsDomain,
    ComputerNamePhysicalDnsFullyQualified,
    ComputerNameMax
};

enum COPYFILE2_COPY_PHASE {
    COPYFILE2_PHASE_NONE = 0,
    COPYFILE2_PHASE_PREPARE_SOURCE,
    COPYFILE2_PHASE_PREPARE_DEST,
    COPYFILE2_PHASE_READ_SOURCE,
    COPYFILE2_PHASE_WRITE_DESTINATION,
    COPYFILE2_PHASE_SERVER_COPY,
    COPYFILE2_PHASE_NAMEGRAFT_COPY,
    COPYFILE2_PHASE_MAX
};

enum COPYFILE2_MESSAGE_ACTION {
    COPYFILE2_PROGRESS_CONTINUE = 0,
    COPYFILE2_PROGRESS_CANCEL,
    COPYFILE2_PROGRESS_STOP,
    COPYFILE2_PROGRESS_QUIET,
    COPYFILE2_PROGRESS_PAUSE
};

enum COPYFILE2_MESSAGE_TYPE {
    COPYFILE2_CALLBACK_NONE = 0,
    COPYFILE2_CALLBACK_CHUNK_STARTED,
    COPYFILE2_CALLBACK_CHUNK_FINISHED,
    COPYFILE2_CALLBACK_STREAM_STARTED,
    COPYFILE2_CALLBACK_STREAM_FINISHED,
    COPYFILE2_CALLBACK_POLL_CONTINUE,
    COPYFILE2_CALLBACK_ERROR,
    COPYFILE2_CALLBACK_MAX
};

enum DEP_SYSTEM_POLICY_TYPE {
    DEPPolicyAlwaysOff = 0,
    DEPPolicyAlwaysOn,
    DEPPolicyOptIn,
    DEPPolicyOptOut,
    DEPTotalPolicyCount
};

enum FILE_ID_TYPE {
    FileIdType,
    ObjectIdType,
    ExtendedFileIdType,
    MaximumFileIdType
};

enum PRIORITY_HINT {
    IoPriorityHintVeryLow = 0,
    IoPriorityHintLow,
    IoPriorityHintNormal,
    MaximumIoPriorityHintType
};

enum PROC_THREAD_ATTRIBUTE_NUM {
    ProcThreadAttributeParentProcess = 0,
    ProcThreadAttributeHandleList = 2,
    ProcThreadAttributeGroupAffinity = 3,
    ProcThreadAttributePreferredNode = 4,
    ProcThreadAttributeIdealProcessor = 5,
    ProcThreadAttributeUmsThread = 6,
    ProcThreadAttributeMitigationPolicy = 7,
    ProcThreadAttributeSecurityCapabilities = 9,
    ProcThreadAttributeProtectionLevel = 11,
    ProcThreadAttributeJobList = 13,
    ProcThreadAttributeChildProcessPolicy = 14,
    ProcThreadAttributeAllApplicationPackagesPolicy = 15,
    ProcThreadAttributeWin32kFilter = 16,
    ProcThreadAttributeSafeOpenPromptOriginClaim = 17,
    ProcThreadAttributeDesktopAppPolicy = 18
};

enum LATENCY_TIME {
    LT_DONT_CARE,
    LT_LOWEST_LATENCY
};

enum GET_FILEEX_INFO_LEVELS {
    GetFileExInfoStandard,
    GetFileExMaxInfoLevel
};

enum FINDEX_INFO_LEVELS {
    FindExInfoStandard,
    FindExInfoBasic,
    FindExInfoMaxInfoLevel
};

enum FINDEX_SEARCH_OPS {
    FindExSearchNameMatch,
    FindExSearchLimitToDirectories,
    FindExSearchLimitToDevices,
    FindExSearchMaxSearchOp
};

enum DPI_AWARENESS {
    DPI_AWARENESS_INVALID = -1,
    DPI_AWARENESS_UNAWARE = 0,
    DPI_AWARENESS_SYSTEM_AWARE = 1,
    DPI_AWARENESS_PER_MONITOR_AWARE = 2
};

enum DPI_HOSTING_BEHAVIOR {
    DPI_HOSTING_BEHAVIOR_INVALID = -1,
    DPI_HOSTING_BEHAVIOR_DEFAULT = 0,
    DPI_HOSTING_BEHAVIOR_MIXED = 1
};

enum FILE_INFO_BY_HANDLE_CLASS {
    FileBasicInfo = 0,
    FileStandardInfo = 1,
    FileNameInfo = 2,
    FileRenameInfo = 3,
    FileDispositionInfo = 4,
    FileAllocationInfo = 5,
    FileEndOfFileInfo = 6,
    FileStreamInfo = 7,
    FileCompressionInfo = 8,
    FileAttributeTagInfo = 9,
    FileIdBothDirectoryInfo = 10,
    FileIdBothDirectoryRestartInfo = 11,
    FileIoPriorityHintInfo = 12,
    FileRemoteProtocolInfo = 13,
    FileFullDirectoryInfo = 14,
    FileFullDirectoryRestartInfo = 15,
    FileStorageInfo = 16,
    FileAlignmentInfo = 17,
    FileIdInfo = 18,
    FileIdExtdDirectoryInfo = 19,
    FileIdExtdDirectoryRestartInfo = 20,
    MaximumFileInfoByHandlesClass
};

enum READ_DIRECTORY_NOTIFY_INFORMATION_CLASS {
    ReadDirectoryNotifyInformation = 1,
    ReadDirectoryNotifyExtendedInformation
};

enum WELL_KNOWN_SID_TYPE {
    WinNullSid = 0,
    WinWorldSid = 1,
    WinLocalSid = 2,
    WinCreatorOwnerSid = 3,
    WinCreatorGroupSid = 4,
    WinCreatorOwnerServerSid = 5,
    WinCreatorGroupServerSid = 6,
    WinNtAuthoritySid = 7,
    WinDialupSid = 8,
    WinNetworkSid = 9,
    WinBatchSid = 10,
    WinInteractiveSid = 11,
    WinServiceSid = 12,
    WinAnonymousSid = 13,
    WinProxySid = 14,
    WinEnterpriseControllersSid = 15,
    WinSelfSid = 16,
    WinAuthenticatedUserSid = 17,
    WinRestrictedCodeSid = 18,
    WinTerminalServerSid = 19,
    WinRemoteLogonIdSid = 20,
    WinLogonIdsSid = 21,
    WinLocalSystemSid = 22,
    WinLocalServiceSid = 23,
    WinNetworkServiceSid = 24,
    WinBuiltinDomainSid = 25,
    WinBuiltinAdministratorsSid = 26,
    WinBuiltinUsersSid = 27,
    WinBuiltinGuestsSid = 28,
    WinBuiltinPowerUsersSid = 29,
    WinBuiltinAccountOperatorsSid = 30,
    WinBuiltinSystemOperatorsSid = 31,
    WinBuiltinPrintOperatorsSid = 32,
    WinBuiltinBackupOperatorsSid = 33,
    WinBuiltinReplicatorSid = 34,
    WinBuiltinPreWindows2000CompatibleAccessSid = 35,
    WinBuiltinRemoteDesktopUsersSid = 36,
    WinBuiltinNetworkConfigurationOperatorsSid = 37,
    WinAccountAdministratorSid = 38,
    WinAccountGuestSid = 39,
    WinAccountKrbtgtSid = 40,
    WinAccountDomainAdminsSid = 41,
    WinAccountDomainUsersSid = 42,
    WinAccountDomainGuestsSid = 43,
    WinAccountComputersSid = 44,
    WinAccountControllersSid = 45,
    WinAccountCertAdminsSid = 46,
    WinAccountSchemaAdminsSid = 47,
    WinAccountEnterpriseAdminsSid = 48,
    WinAccountPolicyAdminsSid = 49,
    WinAccountRasAndIasServersSid = 50,
    WinNTLMAuthenticationSid = 51,
    WinDigestAuthenticationSid = 52,
    WinSChannelAuthenticationSid = 53,
    WinThisOrganizationSid = 54,
    WinOtherOrganizationSid = 55,
    WinBuiltinIncomingForestTrustBuildersSid = 56,
    WinBuiltinPerfMonitoringUsersSid = 57,
    WinBuiltinPerfLoggingUsersSid = 58,
    WinBuiltinAuthorizationAccessSid = 59,
    WinBuiltinTerminalServerLicenseServersSid = 60,
    WinBuiltinDCOMUsersSid = 61,
    WinBuiltinIUsersSid = 62,
    WinIUserSid = 63,
    WinBuiltinCryptoOperatorsSid = 64,
    WinUntrustedLabelSid = 65,
    WinLowLabelSid = 66,
    WinMediumLabelSid = 67,
    WinHighLabelSid = 68,
    WinSystemLabelSid = 69,
    WinWriteRestrictedCodeSid = 70,
    WinCreatorOwnerRightsSid = 71,
    WinCacheablePrincipalsGroupSid = 72,
    WinNonCacheablePrincipalsGroupSid = 73,
    WinEnterpriseReadonlyControllersSid = 74,
    WinAccountReadonlyControllersSid = 75,
    WinBuiltinEventLogReadersGroup = 76,
    WinNewEnterpriseReadonlyControllersSid = 77,
    WinBuiltinCertSvcDComAccessGroup = 78,
    WinMediumPlusLabelSid = 79,
    WinLocalLogonSid = 80,
    WinConsoleLogonSid = 81,
    WinThisOrganizationCertificateSid = 82,
    WinApplicationPackageAuthoritySid = 83,
    WinBuiltinAnyPackageSid = 84,
    WinCapabilityInternetClientSid = 85,
    WinCapabilityInternetClientServerSid = 86,
    WinCapabilityPrivateNetworkClientServerSid = 87,
    WinCapabilityPicturesLibrarySid = 88,
    WinCapabilityVideosLibrarySid = 89,
    WinCapabilityMusicLibrarySid = 90,
    WinCapabilityDocumentsLibrarySid = 91,
    WinCapabilitySharedUserCertificatesSid = 92,
    WinCapabilityEnterpriseAuthenticationSid = 93,
    WinCapabilityRemovableStorageSid = 94,
    WinBuiltinRDSRemoteAccessServersSid = 95,
    WinBuiltinRDSEndpointServersSid = 96,
    WinBuiltinRDSManagementServersSid = 97,
    WinUserModeDriversSid = 98,
    WinBuiltinHyperVAdminsSid = 99,
    WinAccountCloneableControllersSid = 100,
    WinBuiltinAccessControlAssistanceOperatorsSid = 101,
    WinBuiltinRemoteManagementUsersSid = 102,
    WinAuthenticationAuthorityAssertedSid = 103,
    WinAuthenticationServiceAssertedSid = 104,
    WinLocalAccountSid = 105,
    WinLocalAccountAndAdministratorSid = 106,
    WinAccountProtectedUsersSid = 107,
    WinCapabilityAppointmentsSid = 108,
    WinCapabilityContactsSid = 109,
    WinAccountDefaultSystemManagedSid = 110,
    WinBuiltinDefaultSystemManagedGroupSid = 111,
    WinBuiltinStorageReplicaAdminsSid = 112,
    WinAccountKeyAdminsSid = 113,
    WinAccountEnterpriseKeyAdminsSid = 114,
    WinAuthenticationKeyTrustSid = 115,
    WinAuthenticationKeyPropertyMFASid = 116,
    WinAuthenticationKeyPropertyAttestationSid = 117,
    WinAuthenticationFreshKeyAuthSid = 118,
    WinBuiltinDeviceOwnersSid = 119
};

enum DISPLAYCONFIG_COLOR_ENCODING {
    DISPLAYCONFIG_COLOR_ENCODING_RGB = 0,
    DISPLAYCONFIG_COLOR_ENCODING_YCBCR444 = 1,
    DISPLAYCONFIG_COLOR_ENCODING_YCBCR422 = 2,
    DISPLAYCONFIG_COLOR_ENCODING_YCBCR420 = 3,
    DISPLAYCONFIG_COLOR_ENCODING_INTENSITY = 4,
    DISPLAYCONFIG_COLOR_ENCODING_FORCE_UINT32 = 0xFFFFFFFF
};

enum DISPLAYCONFIG_DEVICE_INFO_TYPE {
    DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME = 1,
    DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME = 2,
    DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE = 3,
    DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME = 4,
    DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE = 5,
    DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_BASE_TYPE = 6,
    DISPLAYCONFIG_DEVICE_INFO_GET_SUPPORT_VIRTUAL_RESOLUTION = 7,
    DISPLAYCONFIG_DEVICE_INFO_SET_SUPPORT_VIRTUAL_RESOLUTION = 8,
    DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO = 9,
    DISPLAYCONFIG_DEVICE_INFO_SET_ADVANCED_COLOR_STATE = 10,
    DISPLAYCONFIG_DEVICE_INFO_GET_SDR_WHITE_LEVEL = 11,
    DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32 = 0xFFFFFFFF
};

enum DISPLAYCONFIG_MODE_INFO_TYPE {
    DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE = 1,
    DISPLAYCONFIG_MODE_INFO_TYPE_TARGET = 2,
    DISPLAYCONFIG_MODE_INFO_TYPE_DESKTOP_IMAGE = 3,
    DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32 = 0xFFFFFFFF
};

enum DISPLAYCONFIG_PIXELFORMAT {
    DISPLAYCONFIG_PIXELFORMAT_8BPP = 1,
    DISPLAYCONFIG_PIXELFORMAT_16BPP = 2,
    DISPLAYCONFIG_PIXELFORMAT_24BPP = 3,
    DISPLAYCONFIG_PIXELFORMAT_32BPP = 4,
    DISPLAYCONFIG_PIXELFORMAT_NONGDI = 5,
    DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32 = 0xffffffff
};

enum DISPLAYCONFIG_ROTATION {
    DISPLAYCONFIG_ROTATION_IDENTITY = 1,
    DISPLAYCONFIG_ROTATION_ROTATE90 = 2,
    DISPLAYCONFIG_ROTATION_ROTATE180 = 3,
    DISPLAYCONFIG_ROTATION_ROTATE270 = 4,
    DISPLAYCONFIG_ROTATION_FORCE_UINT32 = 0xFFFFFFFF
};

enum DISPLAYCONFIG_SCALING {
    DISPLAYCONFIG_SCALING_IDENTITY = 1,
    DISPLAYCONFIG_SCALING_CENTERED = 2,
    DISPLAYCONFIG_SCALING_STRETCHED = 3,
    DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX = 4,
    DISPLAYCONFIG_SCALING_CUSTOM = 5,
    DISPLAYCONFIG_SCALING_PREFERRED = 128,
    DISPLAYCONFIG_SCALING_FORCE_UINT32 = 0xFFFFFFFF
};

enum DISPLAYCONFIG_SCANLINE_ORDERING {
    DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED = 0,
    DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE = 1,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED = 2,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST = DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST = 3,
    DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32 = 0xFFFFFFFF
};

enum DISPLAYCONFIG_TOPOLOGY_ID {
    DISPLAYCONFIG_TOPOLOGY_INTERNAL = 0x00000001,
    DISPLAYCONFIG_TOPOLOGY_CLONE = 0x00000002,
    DISPLAYCONFIG_TOPOLOGY_EXTEND = 0x00000004,
    DISPLAYCONFIG_TOPOLOGY_EXTERNAL = 0x00000008,
    DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32 = 0xFFFFFFFF
};

enum DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY {
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER = -1,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15 = 0,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO = 1,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO = 2,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO = 3,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI = 4,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI = 5,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS = 6,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN = 8,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI = 9,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL = 10,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED = 11,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL = 12,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED = 13,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE = 14,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_MIRACAST = 15,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_WIRED = 16,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL = 0x80000000,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32 = 0xFFFFFFFF
};

enum SID_NAME_USE {
    SidTypeUser = 1,
    SidTypeGroup,
    SidTypeDomain,
    SidTypeAlias,
    SidTypeWellKnownGroup,
    SidTypeDeletedAccount,
    SidTypeInvalid,
    SidTypeUnknown,
    SidTypeComputer,
    SidTypeLabel,
    SidTypeLogonSession
};

enum ACL_INFORMATION_CLASS {
    AclRevisionInformation = 1,
    AclSizeInformation
};

enum AUDIT_EVENT_TYPE {
    AuditEventObjectAccess,
    AuditEventDirectoryServiceAccess
};

enum ACCESS_REASON_TYPE {
    AccessReasonNone = 0x00000000,
    AccessReasonAllowedAce = 0x00010000,
    AccessReasonDeniedAce = 0x00020000,
    AccessReasonAllowedParentAce = 0x00030000,
    AccessReasonDeniedParentAce = 0x00040000,
    AccessReasonNotGrantedByCape = 0x00050000,
    AccessReasonNotGrantedByParentCape = 0x00060000,
    AccessReasonNotGrantedToAppContainer = 0x00070000,
    AccessReasonMissingPrivilege = 0x00100000,
    AccessReasonFromPrivilege = 0x00200000,
    AccessReasonIntegrityLevel = 0x00300000,
    AccessReasonOwnership = 0x00400000,
    AccessReasonNullDacl = 0x00500000,
    AccessReasonEmptyDacl = 0x00600000,
    AccessReasonNoSD = 0x00700000,
    AccessReasonNoGrant = 0x00800000,
    AccessReasonTrustLabel = 0x00900000,
    AccessReasonFilterAce = 0x00a00000
};

enum SECURITY_IMPERSONATION_LEVEL {
    SecurityAnonymous,
    SecurityIdentification,
    SecurityImpersonation,
    SecurityDelegation
};

enum TOKEN_TYPE {
    TokenPrimary = 1,
    TokenImpersonation
};

enum TOKEN_ELEVATION_TYPE {
    TokenElevationTypeDefault = 1,
    TokenElevationTypeFull,
    TokenElevationTypeLimited
};

enum TOKEN_INFORMATION_CLASS {
    TokenUser = 1,
    TokenGroups,
    TokenPrivileges,
    TokenOwner,
    TokenPrimaryGroup,
    TokenDefaultDacl,
    TokenSource,
    TokenType,
    TokenImpersonationLevel,
    TokenStatistics,
    TokenRestrictedSids,
    TokenSessionId,
    TokenGroupsAndPrivileges,
    TokenSessionReference,
    TokenSandBoxInert,
    TokenAuditPolicy,
    TokenOrigin,
    TokenElevationType,
    TokenLinkedToken,
    TokenElevation,
    TokenHasRestrictions,
    TokenAccessInformation,
    TokenVirtualizationAllowed,
    TokenVirtualizationEnabled,
    TokenIntegrityLevel,
    TokenUIAccess,
    TokenMandatoryPolicy,
    TokenLogonSid,
    TokenIsAppContainer,
    TokenCapabilities,
    TokenAppContainerSid,
    TokenAppContainerNumber,
    TokenUserClaimAttributes,
    TokenDeviceClaimAttributes,
    TokenRestrictedUserClaimAttributes,
    TokenRestrictedDeviceClaimAttributes,
    TokenDeviceGroups,
    TokenRestrictedDeviceGroups,
    TokenSecurityAttributes,
    TokenIsRestricted,
    TokenProcessTrustLevel,
    TokenPrivateNameSpace,
    TokenSingletonAttributes,
    TokenBnoIsolation,
    TokenChildProcessFlags,
    MaxTokenInfoClass
};

enum MANDATORY_LEVEL {
    MandatoryLevelUntrusted = 0,
    MandatoryLevelLow,
    MandatoryLevelMedium,
    MandatoryLevelHigh,
    MandatoryLevelSystem,
    MandatoryLevelSecureProcess,
    MandatoryLevelCount
};

enum SE_IMAGE_SIGNATURE_TYPE {
    SeImageSignatureNone = 0,
    SeImageSignatureEmbedded,
    SeImageSignatureCache,
    SeImageSignatureCatalogCached,
    SeImageSignatureCatalogNotCached,
    SeImageSignatureCatalogHint,
    SeImageSignaturePackageCatalog
};

enum SE_LEARNING_MODE_DATA_TYPE {
    SeLearningModeInvalidType = 0,
    SeLearningModeSettings,
    SeLearningModeMax
};

enum HARDWARE_COUNTER_TYPE {
    PMCCounter,
    MaxHardwareCounterType
};

enum PROCESS_MITIGATION_POLICY {
    ProcessDEPPolicy,
    ProcessASLRPolicy,
    ProcessDynamicCodePolicy,
    ProcessStrictHandleCheckPolicy,
    ProcessSystemCallDisablePolicy,
    ProcessMitigationOptionsMask,
    ProcessExtensionPointDisablePolicy,
    ProcessControlFlowGuardPolicy,
    ProcessSignaturePolicy,
    ProcessFontDisablePolicy,
    ProcessImageLoadPolicy,
    ProcessSystemCallFilterPolicy,
    ProcessPayloadRestrictionPolicy,
    ProcessChildProcessPolicy,
    MaxProcessMitigationPolicy
};

enum JOBOBJECT_RATE_CONTROL_TOLERANCE {
    ToleranceLow = 1,
    ToleranceMedium,
    ToleranceHigh
};

enum JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL {
    ToleranceIntervalShort = 1,
    ToleranceIntervalMedium,
    ToleranceIntervalLong
};

enum JOB_OBJECT_NET_RATE_CONTROL_FLAGS {
    JOB_OBJECT_NET_RATE_CONTROL_ENABLE = 0x1,
    JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH = 0x2,
    JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG = 0x4,
    JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS = 0x7
};

enum JOB_OBJECT_IO_RATE_CONTROL_FLAGS {
    JOB_OBJECT_IO_RATE_CONTROL_ENABLE = 0x1,
    JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME = 0x2,
    JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL = 0x4,
    JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP = 0x8,
    JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGS = JOB_OBJECT_IO_RATE_CONTROL_ENABLE| JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME| JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL| JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP
};

enum JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS {
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_ENABLE = 0x1,
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_DISABLE = 0x2,
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_VALID_FLAGS = 0x3
};

enum JOBOBJECTINFOCLASS {
    JobObjectBasicAccountingInformation = 1,
    JobObjectBasicLimitInformation,
    JobObjectBasicProcessIdList,
    JobObjectBasicUIRestrictions,
    JobObjectSecurityLimitInformation,
    JobObjectEndOfJobTimeInformation,
    JobObjectAssociateCompletionPortInformation,
    JobObjectBasicAndIoAccountingInformation,
    JobObjectExtendedLimitInformation,
    JobObjectJobSetInformation,
    JobObjectGroupInformation,
    JobObjectNotificationLimitInformation,
    JobObjectLimitViolationInformation,
    JobObjectGroupInformationEx,
    JobObjectCpuRateControlInformation,
    JobObjectCompletionFilter,
    JobObjectCompletionCounter,
    JobObjectReserved1Information = 18,
    JobObjectReserved2Information,
    JobObjectReserved3Information,
    JobObjectReserved4Information,
    JobObjectReserved5Information,
    JobObjectReserved6Information,
    JobObjectReserved7Information,
    JobObjectReserved8Information,
    JobObjectReserved9Information,
    JobObjectReserved10Information,
    JobObjectReserved11Information,
    JobObjectReserved12Information,
    JobObjectReserved13Information,
    JobObjectReserved14Information = 31,
    JobObjectNetRateControlInformation,
    JobObjectNotificationLimitInformation2,
    JobObjectLimitViolationInformation2,
    JobObjectCreateSilo,
    JobObjectSiloBasicInformation,
    JobObjectReserved15Information = 37,
    JobObjectReserved16Information = 38,
    JobObjectReserved17Information = 39,
    JobObjectReserved18Information = 40,
    JobObjectReserved19Information = 41,
    JobObjectReserved20Information = 42,
    JobObjectReserved21Information = 43,
    JobObjectReserved22Information = 44,
    JobObjectReserved23Information = 45,
    JobObjectReserved24Information = 46,
    JobObjectReserved25Information = 47,
    MaxJobObjectInfoClass
};

enum SERVERSILO_STATE {
    SERVERSILO_INITING = 0,
    SERVERSILO_STARTED,
    SERVERSILO_SHUTTING_DOWN,
    SERVERSILO_TERMINATING,
    SERVERSILO_TERMINATED
};

enum FIRMWARE_TYPE {
    FirmwareTypeUnknown,
    FirmwareTypeBios,
    FirmwareTypeUefi,
    FirmwareTypeMax
};

enum LOGICAL_PROCESSOR_RELATIONSHIP {
    RelationProcessorCore,
    RelationNumaNode,
    RelationCache,
    RelationProcessorPackage,
    RelationGroup,
    RelationAll = 0xffff
};

enum PROCESSOR_CACHE_TYPE {
    CacheUnified,
    CacheInstruction,
    CacheData,
    CacheTrace
};

enum CPU_SET_INFORMATION_TYPE {
    CpuSetInformation
};

enum MEM_EXTENDED_PARAMETER_TYPE {
    MemExtendedParameterInvalidType = 0,
    MemExtendedParameterAddressRequirements,
    MemExtendedParameterNumaNode,
    MemExtendedParameterPartitionHandle,
    MemExtendedParameterMax
};

enum SharedVirtualDiskSupportType {
    SharedVirtualDisksUnsupported = 0,
    SharedVirtualDisksSupported = 1,
    SharedVirtualDiskSnapshotsSupported = 3,
    SharedVirtualDiskCDPSnapshotsSupported = 7
};

enum SharedVirtualDiskHandleState {
    SharedVirtualDiskHandleStateNone = 0,
    SharedVirtualDiskHandleStateFileShared = 1,
    SharedVirtualDiskHandleStateHandleShared = 3
};

enum SYSTEM_POWER_STATE {
    PowerSystemUnspecified = 0,
    PowerSystemWorking = 1,
    PowerSystemSleeping1 = 2,
    PowerSystemSleeping2 = 3,
    PowerSystemSleeping3 = 4,
    PowerSystemHibernate = 5,
    PowerSystemShutdown = 6,
    PowerSystemMaximum = 7
};

enum DEVICE_POWER_STATE {
    PowerDeviceUnspecified = 0,
    PowerDeviceD0,
    PowerDeviceD1,
    PowerDeviceD2,
    PowerDeviceD3,
    PowerDeviceMaximum
};

enum MONITOR_DISPLAY_STATE {
    PowerMonitorOff = 0,
    PowerMonitorOn,
    PowerMonitorDim
};

enum USER_ACTIVITY_PRESENCE {
    PowerUserPresent = 0,
    PowerUserNotPresent,
    PowerUserInactive,
    PowerUserMaximum,
    PowerUserInvalid = PowerUserMaximum
};

enum POWER_REQUEST_TYPE {
    PowerRequestDisplayRequired,
    PowerRequestSystemRequired,
    PowerRequestAwayModeRequired,
    PowerRequestExecutionRequired
};

enum POWER_MONITOR_REQUEST_TYPE {
    MonitorRequestTypeOff,
    MonitorRequestTypeOnAndPresent,
    MonitorRequestTypeToggleOn
};

enum POWER_PLATFORM_ROLE {
    PlatformRoleUnspecified = 0,
    PlatformRoleDesktop,
    PlatformRoleMobile,
    PlatformRoleWorkstation,
    PlatformRoleEnterpriseServer,
    PlatformRoleSOHOServer,
    PlatformRoleAppliancePC,
    PlatformRolePerformanceServer,
    PlatformRoleSlate,
    PlatformRoleMaximum
};

enum HIBERFILE_BUCKET_SIZE {
    HiberFileBucket1GB = 0,
    HiberFileBucket2GB,
    HiberFileBucket4GB,
    HiberFileBucket8GB,
    HiberFileBucket16GB,
    HiberFileBucket32GB,
    HiberFileBucketUnlimited,
    HiberFileBucketMax
};

enum IMAGE_AUX_SYMBOL_TYPE {
    IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF = 1
};

enum IMPORT_OBJECT_TYPE {
    IMPORT_OBJECT_CODE = 0,
    IMPORT_OBJECT_DATA = 1,
    IMPORT_OBJECT_CONST = 2
};

enum IMPORT_OBJECT_NAME_TYPE {
    IMPORT_OBJECT_ORDINAL = 0,
    IMPORT_OBJECT_NAME = 1,
    IMPORT_OBJECT_NAME_NO_PREFIX = 2,
    IMPORT_OBJECT_NAME_UNDECORATE = 3,
    IMPORT_OBJECT_NAME_EXPORTAS = 4
};

enum ReplacesCorHdrNumericDefines {
    COMIMAGE_FLAGS_ILONLY = 0x00000001,
    COMIMAGE_FLAGS_32BITREQUIRED = 0x00000002,
    COMIMAGE_FLAGS_IL_LIBRARY = 0x00000004,
    COMIMAGE_FLAGS_STRONGNAMESIGNED = 0x00000008,
    COMIMAGE_FLAGS_NATIVE_ENTRYPOINT = 0x00000010,
    COMIMAGE_FLAGS_TRACKDEBUGDATA = 0x00010000,
    COMIMAGE_FLAGS_32BITPREFERRED = 0x00020000,
    COR_VERSION_MAJOR_V2 = 2,
    COR_VERSION_MAJOR = COR_VERSION_MAJOR_V2,
    COR_VERSION_MINOR = 5,
    COR_DELETED_NAME_LENGTH = 8,
    COR_VTABLEGAP_NAME_LENGTH = 8,
    NATIVE_TYPE_MAX_CB = 1,
    COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = 0xFF,
    IMAGE_COR_MIH_METHODRVA = 0x01,
    IMAGE_COR_MIH_EHRVA = 0x02,
    IMAGE_COR_MIH_BASICBLOCK = 0x08,
    COR_VTABLE_32BIT = 0x01,
    COR_VTABLE_64BIT = 0x02,
    COR_VTABLE_FROM_UNMANAGED = 0x04,
    COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN = 0x08,
    COR_VTABLE_CALL_MOST_DERIVED = 0x10,
    IMAGE_COR_EATJ_THUNK_SIZE = 32,
    MAX_CLASS_NAME = 1024,
    MAX_PACKAGE_NAME = 1024
};

enum RTL_UMS_THREAD_INFO_CLASS {
    UmsThreadInvalidInfoClass = 0,
    UmsThreadUserContext,
    UmsThreadPriority,
    UmsThreadAffinity,
    UmsThreadTeb,
    UmsThreadIsSuspended,
    UmsThreadIsTerminated,
    UmsThreadMaxInfoClass
};

enum RTL_UMS_SCHEDULER_REASON {
    UmsSchedulerStartup = 0,
    UmsSchedulerThreadBlocked,
    UmsSchedulerThreadYield
};

enum OS_DEPLOYEMENT_STATE_VALUES {
    OS_DEPLOYMENT_STANDARD = 1,
    OS_DEPLOYMENT_COMPACT
};

enum IMAGE_POLICY_ENTRY_TYPE {
    ImagePolicyEntryTypeNone = 0,
    ImagePolicyEntryTypeBool,
    ImagePolicyEntryTypeInt8,
    ImagePolicyEntryTypeUInt8,
    ImagePolicyEntryTypeInt16,
    ImagePolicyEntryTypeUInt16,
    ImagePolicyEntryTypeInt32,
    ImagePolicyEntryTypeUInt32,
    ImagePolicyEntryTypeInt64,
    ImagePolicyEntryTypeUInt64,
    ImagePolicyEntryTypeAnsiString,
    ImagePolicyEntryTypeUnicodeString,
    ImagePolicyEntryTypeOverride,
    ImagePolicyEntryTypeMaximum
};

enum IMAGE_POLICY_ID {
    ImagePolicyIdNone = 0,
    ImagePolicyIdEtw,
    ImagePolicyIdDebug,
    ImagePolicyIdCrashDump,
    ImagePolicyIdCrashDumpKey,
    ImagePolicyIdCrashDumpKeyGuid,
    ImagePolicyIdParentSd,
    ImagePolicyIdParentSdRev,
    ImagePolicyIdSvn,
    ImagePolicyIdDeviceId,
    ImagePolicyIdCapability,
    ImagePolicyIdScenarioId,
    ImagePolicyIdMaximum
};

enum HEAP_INFORMATION_CLASS {
    HeapCompatibilityInformation = 0,
    HeapEnableTerminationOnCorruption = 1,
    HeapOptimizeResources = 3
};

enum ACTIVATION_CONTEXT_INFO_CLASS {
    ActivationContextBasicInformation = 1,
    ActivationContextDetailedInformation = 2,
    AssemblyDetailedInformationInActivationContext = 3,
    FileInformationInAssemblyOfAssemblyInActivationContext = 4,
    RunlevelInformationInActivationContext = 5,
    CompatibilityInformationInActivationContext = 6,
    ActivationContextManifestResourceName = 7,
    MaxActivationContextInfoClass,
    AssemblyDetailedInformationInActivationContxt = 3,
    FileInformationInAssemblyOfAssemblyInActivationContxt = 4
};

enum SERVICE_NODE_TYPE {
    DriverType = 0x00000001,
    FileSystemType = 0x00000002,
    Win32ServiceOwnProcess = 0x00000010,
    Win32ServiceShareProcess = 0x00000020,
    AdapterType = 0x00000004,
    RecognizerType = 0x00000008
};

enum SERVICE_LOAD_TYPE {
    BootLoad = 0x00000000,
    SystemLoad = 0x00000001,
    AutoLoad = 0x00000002,
    DemandLoad = 0x00000003,
    DisableLoad = 0x00000004
};

enum SERVICE_ERROR_TYPE {
    IgnoreError = 0x00000000,
    NormalError = 0x00000001,
    SevereError = 0x00000002,
    CriticalError = 0x00000003
};

enum TAPE_DRIVE_PROBLEM_TYPE {
    TapeDriveProblemNone,
    TapeDriveReadWriteWarning,
    TapeDriveReadWriteError,
    TapeDriveReadWarning,
    TapeDriveWriteWarning,
    TapeDriveReadError,
    TapeDriveWriteError,
    TapeDriveHardwareError,
    TapeDriveUnsupportedMedia,
    TapeDriveScsiConnectionError,
    TapeDriveTimetoClean,
    TapeDriveCleanDriveNow,
    TapeDriveMediaLifeExpired,
    TapeDriveSnappedTape
};

enum TRANSACTION_OUTCOME {
    TransactionOutcomeUndetermined = 1,
    TransactionOutcomeCommitted,
    TransactionOutcomeAborted
};

enum TRANSACTION_STATE {
    TransactionStateNormal = 1,
    TransactionStateIndoubt,
    TransactionStateCommittedNotify
};

enum TRANSACTION_INFORMATION_CLASS {
    TransactionBasicInformation,
    TransactionPropertiesInformation,
    TransactionEnlistmentInformation,
    TransactionSuperiorEnlistmentInformation,
    TransactionBindInformation,
    TransactionDTCPrivateInformation
};

enum TRANSACTIONMANAGER_INFORMATION_CLASS {
    TransactionManagerBasicInformation,
    TransactionManagerLogInformation,
    TransactionManagerLogPathInformation,
    TransactionManagerRecoveryInformation = 4,
    TransactionManagerOnlineProbeInformation = 3,
    TransactionManagerOldestTransactionInformation = 5
};

enum RESOURCEMANAGER_INFORMATION_CLASS {
    ResourceManagerBasicInformation,
    ResourceManagerCompletionInformation
};

enum ENLISTMENT_INFORMATION_CLASS {
    EnlistmentBasicInformation,
    EnlistmentRecoveryInformation,
    EnlistmentCrmInformation
};

enum KTMOBJECT_TYPE {
    KTMOBJECT_TRANSACTION,
    KTMOBJECT_TRANSACTION_MANAGER,
    KTMOBJECT_RESOURCE_MANAGER,
    KTMOBJECT_ENLISTMENT,
    KTMOBJECT_INVALID
};

enum TP_CALLBACK_PRIORITY {
    TP_CALLBACK_PRIORITY_HIGH,
    TP_CALLBACK_PRIORITY_NORMAL,
    TP_CALLBACK_PRIORITY_LOW,
    TP_CALLBACK_PRIORITY_INVALID,
    TP_CALLBACK_PRIORITY_COUNT = TP_CALLBACK_PRIORITY_INVALID
};

enum POWER_USER_PRESENCE_TYPE {
    UserNotPresent = 0,
    UserPresent = 1,
    UserUnknown = 0xff
};

enum POWER_MONITOR_REQUEST_REASON {
    MonitorRequestReasonUnknown,
    MonitorRequestReasonPowerButton,
    MonitorRequestReasonRemoteConnection,
    MonitorRequestReasonScMonitorpower,
    MonitorRequestReasonUserInput,
    MonitorRequestReasonAcDcDisplayBurst,
    MonitorRequestReasonUserDisplayBurst,
    MonitorRequestReasonPoSetSystemState,
    MonitorRequestReasonSetThreadExecutionState,
    MonitorRequestReasonFullWake,
    MonitorRequestReasonSessionUnlock,
    MonitorRequestReasonScreenOffRequest,
    MonitorRequestReasonIdleTimeout,
    MonitorRequestReasonPolicyChange,
    MonitorRequestReasonSleepButton,
    MonitorRequestReasonLid,
    MonitorRequestReasonBatteryCountChange,
    MonitorRequestReasonGracePeriod,
    MonitorRequestReasonPnP,
    MonitorRequestReasonDP,
    MonitorRequestReasonSxTransition,
    MonitorRequestReasonSystemIdle,
    MonitorRequestReasonNearProximity,
    MonitorRequestReasonThermalStandby,
    MonitorRequestReasonResumePdc,
    MonitorRequestReasonResumeS4,
    MonitorRequestReasonTerminal,
    MonitorRequestReasonPdcSignal,
    MonitorRequestReasonAcDcDisplayBurstSuppressed,
    MonitorRequestReasonSystemStateEntered,
    MonitorRequestReasonWinrt,
    MonitorRequestReasonUserInputKeyboard,
    MonitorRequestReasonUserInputMouse,
    MonitorRequestReasonUserInputTouch,
    MonitorRequestReasonUserInputPen,
    MonitorRequestReasonUserInputAccelerometer,
    MonitorRequestReasonUserInputHid,
    MonitorRequestReasonUserInputPoUserPresent,
    MonitorRequestReasonUserInputSessionSwitch,
    MonitorRequestReasonUserInputInitialization,
    MonitorRequestReasonPdcSignalWindowsMobilePwrNotif,
    MonitorRequestReasonPdcSignalWindowsMobileShell,
    MonitorRequestReasonPdcSignalHeyCortana,
    MonitorRequestReasonPdcSignalHolographicShell,
    MonitorRequestReasonPdcSignalFingerprint,
    MonitorRequestReasonMax
};

enum POWER_ACTION {
    PowerActionNone = 0,
    PowerActionReserved,
    PowerActionSleep,
    PowerActionHibernate,
    PowerActionShutdown,
    PowerActionShutdownReset,
    PowerActionShutdownOff,
    PowerActionWarmEject,
    PowerActionDisplayOff
};

enum ACTCTX_REQUESTED_RUN_LEVEL {
    ACTCTX_RUN_LEVEL_UNSPECIFIED = 0,
    ACTCTX_RUN_LEVEL_AS_INVOKER,
    ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE,
    ACTCTX_RUN_LEVEL_REQUIRE_ADMIN,
    ACTCTX_RUN_LEVEL_NUMBERS
};

enum ACTCTX_COMPATIBILITY_ELEMENT_TYPE {
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN = 0,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION
};

enum AR_STATE {
    AR_ENABLED = 0x0,
    AR_DISABLED = 0x1,
    AR_SUPPRESSED = 0x2,
    AR_REMOTESESSION = 0x4,
    AR_MULTIMON = 0x8,
    AR_NOSENSOR = 0x10,
    AR_NOT_SUPPORTED = 0x20,
    AR_DOCKED = 0x40,
    AR_LAPTOP = 0x80
};

enum DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS {
    DCDC_DEFAULT = 0x0000,
    DCDC_DISABLE_FONT_UPDATE = 0x0001,
    DCDC_DISABLE_RELAYOUT = 0x0002
};

enum DIALOG_DPI_CHANGE_BEHAVIORS {
    DDC_DEFAULT = 0x0000,
    DDC_DISABLE_ALL = 0x0001,
    DDC_DISABLE_RESIZE = 0x0002,
    DDC_DISABLE_CONTROL_RELAYOUT = 0x0004
};

enum EDIT_CONTROL_FEATURE {
    EDIT_CONTROL_FEATURE_ENTERPRISE_DATA_PROTECTION_PASTE_SUPPORT = 0,
    EDIT_CONTROL_FEATURE_PASTE_NOTIFICATIONS = 1
};

enum FEEDBACK_TYPE {
    FEEDBACK_TOUCH_CONTACTVISUALIZATION = 1,
    FEEDBACK_PEN_BARRELVISUALIZATION = 2,
    FEEDBACK_PEN_TAP = 3,
    FEEDBACK_PEN_DOUBLETAP = 4,
    FEEDBACK_PEN_PRESSANDHOLD = 5,
    FEEDBACK_PEN_RIGHTTAP = 6,
    FEEDBACK_TOUCH_TAP = 7,
    FEEDBACK_TOUCH_DOUBLETAP = 8,
    FEEDBACK_TOUCH_PRESSANDHOLD = 9,
    FEEDBACK_TOUCH_RIGHTTAP = 10,
    FEEDBACK_GESTURE_PRESSANDTAP = 11,
    FEEDBACK_MAX = 0xFFFFFFFF
};

enum HANDEDNESS {
    HANDEDNESS_LEFT = 0,
    HANDEDNESS_RIGHT
};

enum INPUT_MESSAGE_DEVICE_TYPE {
    IMDT_UNAVAILABLE = 0x00000000,
    IMDT_KEYBOARD = 0x00000001,
    IMDT_MOUSE = 0x00000002,
    IMDT_TOUCH = 0x00000004,
    IMDT_PEN = 0x00000008,
    IMDT_TOUCHPAD = 0x00000010
};

enum INPUT_MESSAGE_ORIGIN_ID {
    IMO_UNAVAILABLE = 0x00000000,
    IMO_HARDWARE = 0x00000001,
    IMO_INJECTED = 0x00000002,
    IMO_SYSTEM = 0x00000004
};

enum ORIENTATION_PREFERENCE {
    ORIENTATION_PREFERENCE_NONE = 0x0,
    ORIENTATION_PREFERENCE_LANDSCAPE = 0x1,
    ORIENTATION_PREFERENCE_PORTRAIT = 0x2,
    ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED = 0x4,
    ORIENTATION_PREFERENCE_PORTRAIT_FLIPPED = 0x8
};

enum POINTER_BUTTON_CHANGE_TYPE {
    POINTER_CHANGE_NONE,
    POINTER_CHANGE_FIRSTBUTTON_DOWN,
    POINTER_CHANGE_FIRSTBUTTON_UP,
    POINTER_CHANGE_SECONDBUTTON_DOWN,
    POINTER_CHANGE_SECONDBUTTON_UP,
    POINTER_CHANGE_THIRDBUTTON_DOWN,
    POINTER_CHANGE_THIRDBUTTON_UP,
    POINTER_CHANGE_FOURTHBUTTON_DOWN,
    POINTER_CHANGE_FOURTHBUTTON_UP,
    POINTER_CHANGE_FIFTHBUTTON_DOWN,
    POINTER_CHANGE_FIFTHBUTTON_UP
};

enum POINTER_DEVICE_CURSOR_TYPE {
    POINTER_DEVICE_CURSOR_TYPE_UNKNOWN = 0x00000000,
    POINTER_DEVICE_CURSOR_TYPE_TIP = 0x00000001,
    POINTER_DEVICE_CURSOR_TYPE_ERASER = 0x00000002,
    POINTER_DEVICE_CURSOR_TYPE_MAX = 0xFFFFFFFF
};

enum POINTER_DEVICE_TYPE {
    POINTER_DEVICE_TYPE_INTEGRATED_PEN = 0x00000001,
    POINTER_DEVICE_TYPE_EXTERNAL_PEN = 0x00000002,
    POINTER_DEVICE_TYPE_TOUCH = 0x00000003,
    POINTER_DEVICE_TYPE_TOUCH_PAD = 0x00000004,
    POINTER_DEVICE_TYPE_MAX = 0xFFFFFFFF
};

// Classes
class CArray : public CObject {
public:
    CArray(void);
    ~CArray();
    int Step(void) const;
    bool Step(const int step);
    int Total(void) const;
    int Available(void) const;
    int Max(void) const;
    bool IsSorted(const int mode = 0) const;
    int SortMode(void) const;
    void Clear(void);
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    void Sort(const int mode = 0);
protected:
    int m_step_resize;
    int m_data_total;
    int m_data_max;
    int m_sort_mode;
    virtual void QuickSort(int beg, int end, const int mode = 0);
};

class CArrayChar : public CArray {
public:
    CArrayChar(void);
    ~CArrayChar();
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    bool Reserve(const int size);
    bool Resize(const int size);
    bool Shutdown(void);
    bool Add(const char element);
    bool AddArray(const char & src);
    bool AddArray(const CArrayChar * src);
    bool Insert(const char element, const int pos);
    bool InsertArray(const char & src, const int pos);
    bool InsertArray(const CArrayChar * src, const int pos);
    bool AssignArray(const char & src);
    bool AssignArray(const CArrayChar * src);
    char At(const int index) const;
    int Minimum(const int start, const int count) const;
    int Maximum(const int start, const int count) const;
    bool Update(const int index, const char element);
    bool Shift(const int index, const int shift);
    bool Delete(const int index);
    bool DeleteRange(int from, int to);
    bool CompareArray(const char & array) const;
    bool CompareArray(const CArrayChar * array) const;
    bool InsertSort(const char element);
    int Search(const char element) const;
    int SearchGreat(const char element) const;
    int SearchLess(const char element) const;
    int SearchGreatOrEqual(const char element) const;
    int SearchLessOrEqual(const char element) const;
    int SearchFirst(const char element) const;
    int SearchLast(const char element) const;
    int SearchLinear(const char element) const;
protected:
    char m_data;
    virtual void QuickSort(int beg, int end, const int mode = 0);
    int QuickSearch(const char element) const;
    int MemMove(const int dest, const int src, int count);
};

class CArrayColor : public CArray {
public:
    CArrayColor(void);
    ~CArrayColor();
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    bool Reserve(const int size);
    bool Resize(const int size);
    bool Shutdown(void);
    bool Add(const color element);
    bool AddArray(const color & src);
    bool AddArray(const CArrayColor * src);
    bool Insert(const color element, const int pos);
    bool InsertArray(const color & src, const int pos);
    bool InsertArray(const CArrayColor * src, const int pos);
    bool AssignArray(const color & src);
    bool AssignArray(const CArrayColor * src);
    color At(const int index) const;
    int Minimum(const int start, const int count) const;
    int Maximum(const int start, const int count) const;
    bool Update(const int index, const color element);
    bool Shift(const int index, const int shift);
    bool Delete(const int index);
    bool DeleteRange(int from, int to);
    bool CompareArray(const color & array) const;
    bool CompareArray(const CArrayColor * array) const;
    bool InsertSort(const color element);
    int Search(const color element) const;
    int SearchGreat(const color element) const;
    int SearchLess(const color element) const;
    int SearchGreatOrEqual(const color element) const;
    int SearchLessOrEqual(const color element) const;
    int SearchFirst(const color element) const;
    int SearchLast(const color element) const;
    int SearchLinear(const color element) const;
protected:
    color m_data;
    virtual void QuickSort(int beg, int end, const int mode = 0);
    int QuickSearch(const color element) const;
    int MemMove(const int dest, const int src, int count);
};

class CArrayDatetime : public CArray {
public:
    CArrayDatetime(void);
    ~CArrayDatetime();
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    bool Reserve(const int size);
    bool Resize(const int size);
    bool Shutdown(void);
    bool Add(const datetime element);
    bool AddArray(const datetime & src);
    bool AddArray(const CArrayDatetime * src);
    bool Insert(const datetime element, const int pos);
    bool InsertArray(const datetime & src, const int pos);
    bool InsertArray(const CArrayDatetime * src, const int pos);
    bool AssignArray(const datetime & src);
    bool AssignArray(const CArrayDatetime * src);
    datetime At(const int index) const;
    int Minimum(const int start, const int count) const;
    int Maximum(const int start, const int count) const;
    bool Update(const int index, const datetime element);
    bool Shift(const int index, const int shift);
    bool Delete(const int index);
    bool DeleteRange(int from, int to);
    bool CompareArray(const datetime & array) const;
    bool CompareArray(const CArrayDatetime * array) const;
    bool InsertSort(const datetime element);
    int Search(const datetime element) const;
    int SearchGreat(const datetime element) const;
    int SearchLess(const datetime element) const;
    int SearchGreatOrEqual(const datetime element) const;
    int SearchLessOrEqual(const datetime element) const;
    int SearchFirst(const datetime element) const;
    int SearchLast(const datetime element) const;
    int SearchLinear(const datetime element) const;
protected:
    datetime m_data;
    virtual void QuickSort(int beg, int end, const int mode = 0);
    int QuickSearch(const datetime element) const;
    int MemMove(const int dest, const int src, int count);
};

class CArrayDouble : public CArray {
public:
    CArrayDouble(void);
    ~CArrayDouble();
    void Delta(const double delta);
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    bool Reserve(const int size);
    bool Resize(const int size);
    bool Shutdown(void);
    bool Add(const double element);
    bool AddArray(const double & src);
    bool AddArray(const CArrayDouble * src);
    bool Insert(const double element, const int pos);
    bool InsertArray(const double & src, const int pos);
    bool InsertArray(const CArrayDouble * src, const int pos);
    bool AssignArray(const double & src);
    bool AssignArray(const CArrayDouble * src);
    double At(const int index) const;
    int Minimum(const int start, const int count) const;
    int Maximum(const int start, const int count) const;
    bool Update(const int index, const double element);
    bool Shift(const int index, const int shift);
    bool Delete(const int index);
    bool DeleteRange(int from, int to);
    bool CompareArray(const double & array) const;
    bool CompareArray(const CArrayDouble * array) const;
    bool InsertSort(const double element);
    int Search(const double element) const;
    int SearchGreat(const double element) const;
    int SearchLess(const double element) const;
    int SearchGreatOrEqual(const double element) const;
    int SearchLessOrEqual(const double element) const;
    int SearchFirst(const double element) const;
    int SearchLast(const double element) const;
    int SearchLinear(const double element) const;
protected:
    double m_data;
    double m_delta;
    virtual void QuickSort(int beg, int end, const int mode = 0);
    int QuickSearch(const double element) const;
    int MemMove(const int dest, const int src, int count);
};

class CArrayFloat : public CArray {
public:
    CArrayFloat(void);
    ~CArrayFloat();
    void Delta(const float delta);
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    bool Reserve(const int size);
    bool Resize(const int size);
    bool Shutdown(void);
    bool Add(const float element);
    bool AddArray(const float & src);
    bool AddArray(const CArrayFloat * src);
    bool Insert(const float element, const int pos);
    bool InsertArray(const float & src, const int pos);
    bool InsertArray(const CArrayFloat * src, const int pos);
    bool AssignArray(const float & src);
    bool AssignArray(const CArrayFloat * src);
    float At(const int index) const;
    int Minimum(const int start, const int count) const;
    int Maximum(const int start, const int count) const;
    bool Update(const int index, const float element);
    bool Shift(const int index, const int shift);
    bool Delete(const int index);
    bool DeleteRange(int from, int to);
    bool CompareArray(const float & array) const;
    bool CompareArray(const CArrayFloat * array) const;
    bool InsertSort(const float element);
    int Search(const float element) const;
    int SearchGreat(const float element) const;
    int SearchLess(const float element) const;
    int SearchGreatOrEqual(const float element) const;
    int SearchLessOrEqual(const float element) const;
    int SearchFirst(const float element) const;
    int SearchLast(const float element) const;
    int SearchLinear(const float element) const;
protected:
    float m_data;
    float m_delta;
    virtual void QuickSort(int beg, int end, const int mode = 0);
    int QuickSearch(const float element) const;
    int MemMove(const int dest, const int src, int count);
};

class CArrayInt : public CArray {
public:
    CArrayInt(void);
    ~CArrayInt();
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    bool Reserve(const int size);
    bool Resize(const int size);
    bool Shutdown(void);
    bool Add(const int element);
    bool AddArray(const int & src);
    bool AddArray(const CArrayInt * src);
    bool Insert(const int element, const int pos);
    bool InsertArray(const int & src, const int pos);
    bool InsertArray(const CArrayInt * src, const int pos);
    bool AssignArray(const int & src);
    bool AssignArray(const CArrayInt * src);
    int At(const int index) const;
    int Minimum(const int start, const int count) const;
    int Maximum(const int start, const int count) const;
    bool Update(const int index, const int element);
    bool Shift(const int index, const int shift);
    bool Delete(const int index);
    bool DeleteRange(int from, int to);
    bool CompareArray(const int & array) const;
    bool CompareArray(const CArrayInt * array) const;
    bool InsertSort(const int element);
    int Search(const int element) const;
    int SearchGreat(const int element) const;
    int SearchLess(const int element) const;
    int SearchGreatOrEqual(const int element) const;
    int SearchLessOrEqual(const int element) const;
    int SearchFirst(const int element) const;
    int SearchLast(const int element) const;
    int SearchLinear(const int element) const;
protected:
    int m_data;
    virtual void QuickSort(int beg, int end, const int mode = 0);
    int QuickSearch(const int element) const;
    int MemMove(const int dest, const int src, int count);
};

class CArrayLong : public CArray {
public:
    CArrayLong(void);
    ~CArrayLong();
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    bool Reserve(const int size);
    bool Resize(const int size);
    bool Shutdown(void);
    bool Add(const long element);
    bool AddArray(const long & src);
    bool AddArray(const CArrayLong * src);
    bool Insert(const long element, const int pos);
    bool InsertArray(const long & src, const int pos);
    bool InsertArray(const CArrayLong * src, const int pos);
    bool AssignArray(const long & src);
    bool AssignArray(const CArrayLong * src);
    long At(const int index) const;
    int Minimum(const int start, const int count) const;
    int Maximum(const int start, const int count) const;
    bool Update(const int index, const long element);
    bool Shift(const int index, const int shift);
    bool Delete(const int index);
    bool DeleteRange(int from, int to);
    bool CompareArray(const long & array) const;
    bool CompareArray(const CArrayLong * array) const;
    bool InsertSort(const long element);
    int Search(const long element) const;
    int SearchGreat(const long element) const;
    int SearchLess(const long element) const;
    int SearchGreatOrEqual(const long element) const;
    int SearchLessOrEqual(const long element) const;
    int SearchFirst(const long element) const;
    int SearchLast(const long element) const;
    int SearchLinear(const long element) const;
protected:
    long m_data;
    virtual void QuickSort(int beg, int end, const int mode = 0);
    int QuickSearch(const long element) const;
    int MemMove(const int dest, const int src, int count);
};

class CArrayObj : public CArray {
public:
    CArrayObj(void);
    ~CArrayObj();
    bool FreeMode(void) const;
    void FreeMode(const bool mode);
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    virtual bool CreateElement(const int index);
    bool Reserve(const int size);
    bool Resize(const int size);
    bool Shutdown(void);
    bool Add(CObject * element);
    bool AddArray(const CArrayObj * src);
    bool Insert(CObject * element, const int pos);
    bool InsertArray(const CArrayObj * src, const int pos);
    bool AssignArray(const CArrayObj * src);
    bool Update(const int index, CObject * element);
    bool Shift(const int index, const int shift);
    bool Delete(const int index);
    bool DeleteRange(int from, int to);
    void Clear(void);
    bool CompareArray(const CArrayObj * array) const;
    bool InsertSort(CObject * element);
    int Search(const CObject * element) const;
    int SearchGreat(const CObject * element) const;
    int SearchLess(const CObject * element) const;
    int SearchGreatOrEqual(const CObject * element) const;
    int SearchLessOrEqual(const CObject * element) const;
    int SearchFirst(const CObject * element) const;
    int SearchLast(const CObject * element) const;
protected:
    bool m_free_mode;
    void QuickSort(int beg, int end, const int mode);
    int QuickSearch(const CObject * element) const;
    int MemMove(const int dest, const int src, int count);
};

class CArrayShort : public CArray {
public:
    CArrayShort(void);
    ~CArrayShort();
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    bool Reserve(const int size);
    bool Resize(const int size);
    bool Shutdown(void);
    bool Add(const short element);
    bool AddArray(const short & src);
    bool AddArray(const CArrayShort * src);
    bool Insert(const short element, const int pos);
    bool InsertArray(const short & src, const int pos);
    bool InsertArray(const CArrayShort * src, const int pos);
    bool AssignArray(const short & src);
    bool AssignArray(const CArrayShort * src);
    short At(const int index) const;
    int Minimum(const int start, const int count) const;
    int Maximum(const int start, const int count) const;
    bool Update(const int index, const short element);
    bool Shift(const int index, const int shift);
    bool Delete(const int index);
    bool DeleteRange(int from, int to);
    bool CompareArray(const short & array) const;
    bool CompareArray(const CArrayShort * array) const;
    bool InsertSort(const short element);
    int Search(const short element) const;
    int SearchGreat(const short element) const;
    int SearchLess(const short element) const;
    int SearchGreatOrEqual(const short element) const;
    int SearchLessOrEqual(const short element) const;
    int SearchFirst(const short element) const;
    int SearchLast(const short element) const;
    int SearchLinear(const short element) const;
protected:
    short m_data;
    virtual void QuickSort(int beg, int end, const int mode = 0);
    int QuickSearch(const short element) const;
    int MemMove(const int dest, const int src, int count);
};

class CArrayString : public CArray {
public:
    CArrayString(void);
    ~CArrayString();
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    bool Reserve(const int size);
    bool Resize(const int size);
    bool Shutdown(void);
    bool Add(const string element);
    bool AddArray(const string & src);
    bool AddArray(const CArrayString * src);
    bool Insert(const string element, const int pos);
    bool InsertArray(const string & src, const int pos);
    bool InsertArray(const CArrayString * src, const int pos);
    bool AssignArray(const string & src);
    bool AssignArray(const CArrayString * src);
    string At(const int index) const;
    bool Update(const int index, const string element);
    bool Shift(const int index, const int shift);
    bool Delete(const int index);
    bool DeleteRange(int from, int to);
    bool CompareArray(const string & array) const;
    bool CompareArray(const CArrayString * array) const;
    bool InsertSort(const string element);
    int Search(const string element) const;
    int SearchGreat(const string element) const;
    int SearchLess(const string element) const;
    int SearchGreatOrEqual(const string element) const;
    int SearchLessOrEqual(const string element) const;
    int SearchFirst(const string element) const;
    int SearchLast(const string element) const;
    int SearchLinear(const string element) const;
protected:
    string m_data;
    virtual void QuickSort(int beg, int end, const int mode = 0);
    int QuickSearch(const string element) const;
    int MemMove(const int dest, const int src, int count);
};

class CArrayUChar : public CArray {
public:
    CArrayUChar(void);
    ~CArrayUChar();
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    bool Reserve(const int size);
    bool Resize(const int size);
    bool Shutdown(void);
    bool Add(const uchar element);
    bool AddArray(const uchar & src);
    bool AddArray(const CArrayUChar * src);
    bool Insert(const uchar element, const int pos);
    bool InsertArray(const uchar & src, const int pos);
    bool InsertArray(const CArrayUChar * src, const int pos);
    bool AssignArray(const uchar & src);
    bool AssignArray(const CArrayUChar * src);
    uchar At(const int index) const;
    int Minimum(const int start, const int count) const;
    int Maximum(const int start, const int count) const;
    bool Update(const int index, const uchar element);
    bool Shift(const int index, const int shift);
    bool Delete(const int index);
    bool DeleteRange(int from, int to);
    bool CompareArray(const uchar & array) const;
    bool CompareArray(const CArrayUChar * array) const;
    bool InsertSort(const uchar element);
    int Search(const uchar element) const;
    int SearchGreat(const uchar element) const;
    int SearchLess(const uchar element) const;
    int SearchGreatOrEqual(const uchar element) const;
    int SearchLessOrEqual(const uchar element) const;
    int SearchFirst(const uchar element) const;
    int SearchLast(const uchar element) const;
    int SearchLinear(const uchar element) const;
protected:
    uchar m_data;
    virtual void QuickSort(int beg, int end, const int mode = 0);
    int QuickSearch(const uchar element) const;
    int MemMove(const int dest, const int src, int count);
};

class CArrayUInt : public CArray {
public:
    CArrayUInt(void);
    ~CArrayUInt();
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    bool Reserve(const int size);
    bool Resize(const int size);
    bool Shutdown(void);
    bool Add(const uint element);
    bool AddArray(const uint & src);
    bool AddArray(const CArrayUInt * src);
    bool Insert(const uint element, const int pos);
    bool InsertArray(const uint & src, const int pos);
    bool InsertArray(const CArrayUInt * src, const int pos);
    bool AssignArray(const uint & src);
    bool AssignArray(const CArrayUInt * src);
    uint At(const int index) const;
    int Minimum(const int start, const int count) const;
    int Maximum(const int start, const int count) const;
    bool Update(const int index, const uint element);
    bool Shift(const int index, const int shift);
    bool Delete(const int index);
    bool DeleteRange(int from, int to);
    bool CompareArray(const uint & array) const;
    bool CompareArray(const CArrayUInt * array) const;
    bool InsertSort(const uint element);
    int Search(const uint element) const;
    int SearchGreat(const uint element) const;
    int SearchLess(const uint element) const;
    int SearchGreatOrEqual(const uint element) const;
    int SearchLessOrEqual(const uint element) const;
    int SearchFirst(const uint element) const;
    int SearchLast(const uint element) const;
    int SearchLinear(const uint element) const;
protected:
    uint m_data;
    virtual void QuickSort(int beg, int end, const int mode = 0);
    int QuickSearch(const uint element) const;
    int MemMove(const int dest, const int src, int count);
};

class CArrayULong : public CArray {
public:
    CArrayULong(void);
    ~CArrayULong();
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    bool Reserve(const int size);
    bool Resize(const int size);
    bool Shutdown(void);
    bool Add(const ulong element);
    bool AddArray(const ulong & src);
    bool AddArray(const CArrayULong * src);
    bool Insert(const ulong element, const int pos);
    bool InsertArray(const ulong & src, const int pos);
    bool InsertArray(const CArrayULong * src, const int pos);
    bool AssignArray(const ulong & src);
    bool AssignArray(const CArrayULong * src);
    ulong At(const int index) const;
    int Minimum(const int start, const int count) const;
    int Maximum(const int start, const int count) const;
    bool Update(const int index, const ulong element);
    bool Shift(const int index, const int shift);
    bool Delete(const int index);
    bool DeleteRange(int from, int to);
    bool CompareArray(const ulong & array) const;
    bool CompareArray(const CArrayULong * array) const;
    bool InsertSort(const ulong element);
    int Search(const ulong element) const;
    int SearchGreat(const ulong element) const;
    int SearchLess(const ulong element) const;
    int SearchGreatOrEqual(const ulong element) const;
    int SearchLessOrEqual(const ulong element) const;
    int SearchFirst(const ulong element) const;
    int SearchLast(const ulong element) const;
    int SearchLinear(const ulong element) const;
protected:
    ulong m_data;
    virtual void QuickSort(int beg, int end, const int mode = 0);
    int QuickSearch(const ulong element) const;
    int MemMove(const int dest, const int src, int count);
};

class CArrayUShort : public CArray {
public:
    CArrayUShort(void);
    ~CArrayUShort();
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    bool Reserve(const int size);
    bool Resize(const int size);
    bool Shutdown(void);
    bool Add(const ushort element);
    bool AddArray(const ushort & src);
    bool AddArray(const CArrayUShort * src);
    bool Insert(const ushort element, const int pos);
    bool InsertArray(const ushort & src, const int pos);
    bool InsertArray(const CArrayUShort * src, const int pos);
    bool AssignArray(const ushort & src);
    bool AssignArray(const CArrayUShort * src);
    ushort At(const int index) const;
    int Minimum(const int start, const int count) const;
    int Maximum(const int start, const int count) const;
    bool Update(const int index, const ushort element);
    bool Shift(const int index, const int shift);
    bool Delete(const int index);
    bool DeleteRange(int from, int to);
    bool CompareArray(const ushort & array) const;
    bool CompareArray(const CArrayUShort * array) const;
    bool InsertSort(const ushort element);
    int Search(const ushort element) const;
    int SearchGreat(const ushort element) const;
    int SearchLess(const ushort element) const;
    int SearchGreatOrEqual(const ushort element) const;
    int SearchLessOrEqual(const ushort element) const;
    int SearchFirst(const ushort element) const;
    int SearchLast(const ushort element) const;
    int SearchLinear(const ushort element) const;
protected:
    ushort m_data;
    virtual void QuickSort(int beg, int end, const int mode = 0);
    int QuickSearch(const ushort element) const;
    int MemMove(const int dest, const int src, int count);
};

class CList : public CObject {
public:
    CList(void);
    ~CList();
    bool FreeMode(void) const;
    void FreeMode(bool mode);
    int Total(void) const;
    bool IsSorted(void) const;
    int SortMode(void) const;
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    int Add(CObject * new_node);
    int Insert(CObject * new_node, int index);
    int IndexOf(CObject * node);
    bool DeleteCurrent(void);
    bool Delete(int index);
    void Clear(void);
    bool CompareList(CList * List);
    void Sort(int mode);
    bool MoveToIndex(int index);
    bool Exchange(CObject * node1, CObject * node2);
protected:
    int m_curr_idx;
    int m_data_total;
    bool m_free_mode;
    bool m_data_sort;
    int m_sort_mode;
    void QuickSort(int beg, int end, int mode);
};

class CTreeNode : public CObject {
public:
    CTreeNode(void);
    ~CTreeNode();
    void Parent(CTreeNode * node);
    void Left(CTreeNode * node);
    void Right(CTreeNode * node);
    int Balance(void) const;
    int BalanceL(void) const;
    int BalanceR(void) const;
    virtual int Type(void) const;
    int RefreshBalance(void);
    bool SaveNode(const int file_handle);
    bool LoadNode(const int file_handle, CTreeNode * main);
};

class CTree : public CTreeNode {
public:
    CTree(void);
    ~CTree();
    virtual int Type() const;
    bool Detach(CTreeNode * node);
    bool Delete(CTreeNode * node);
    void Clear(void);
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
protected:
    void Balance(CTreeNode * node);
};

class CCanvas {
public:
    CCanvas(void);
    ~CCanvas();
    virtual bool Create(const string name, const int width, const int height, ENUM_COLOR_FORMAT clrfmt = COLOR_FORMAT_XRGB_NOALPHA);
    bool CreateBitmap(const string name, const datetime time, const double price, const int width, const int height, ENUM_COLOR_FORMAT clrfmt = COLOR_FORMAT_XRGB_NOALPHA);
    bool CreateBitmap(const long chart_id, const int subwin, const string name, const datetime time, const double price, const int width, const int height, ENUM_COLOR_FORMAT clrfmt = COLOR_FORMAT_XRGB_NOALPHA);
    bool CreateBitmapLabel(const string name, const int x, const int y, const int width, const int height, ENUM_COLOR_FORMAT clrfmt = COLOR_FORMAT_XRGB_NOALPHA);
    bool CreateBitmapLabel(const long chart_id, const int subwin, const string name, const int x, const int y, const int width, const int height, ENUM_COLOR_FORMAT clrfmt = COLOR_FORMAT_XRGB_NOALPHA);
    virtual bool Attach(const long chart_id, const string objname, ENUM_COLOR_FORMAT clrfmt = COLOR_FORMAT_XRGB_NOALPHA);
    virtual bool Attach(const long chart_id, const string objname, const int width, const int height, ENUM_COLOR_FORMAT clrfmt = COLOR_FORMAT_XRGB_NOALPHA);
    virtual void Destroy(void);
    string ChartObjectName(void) const;
    string ResourceName(void) const;
    int Width(void) const;
    int Height(void) const;
    void Update(const bool redraw = true);
    bool Resize(const int width, const int height);
    void Erase(const uint clr = 0);
    uint PixelGet(const int x, const int y) const;
    void PixelSet(const int x, const int y, const uint clr);
    void LineVertical(int x, int y1, int y2, const uint clr);
    void LineHorizontal(int x1, int x2, int y, const uint clr);
    void Line(int x1, int y1, int x2, int y2, const uint clr);
    void Polyline(int & x, int & y, const uint clr);
    void Polygon(int & x, int & y, const uint clr);
    void Rectangle(int x1, int y1, int x2, int y2, const uint clr);
    void Triangle(int x1, int y1, int x2, int y2, int x3, int y3, const uint clr);
    void Circle(int x, int y, int r, const uint clr);
    void Ellipse(int x1, int y1, int x2, int y2, const uint clr);
    void Arc(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, const uint clr);
    void Arc(int x, int y, int rx, int ry, double fi3, double fi4, const uint clr);
    void Arc(int x, int y, int rx, int ry, double fi3, double fi4, int & x3, int & y3, int & x4, int & y4, const uint clr);
    void Pie(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, const uint clr, const uint fill_clr);
    void Pie(int x, int y, int rx, int ry, double fi3, double fi4, const uint clr, const uint fill_clr);
    void FillRectangle(int x1, int y1, int x2, int y2, const uint clr);
    void FillTriangle(int x1, int y1, int x2, int y2, int x3, int y3, const uint clr);
    void FillPolygon(int & x, int & y, const uint clr);
    void FillCircle(int x, int y, int r, const uint clr);
    void FillEllipse(int x1, int y1, int x2, int y2, const uint clr);
    void Fill(int x, int y, const uint clr);
    void Fill(int x, int y, const uint clr, const uint threshould);
    void PixelSetAA(const double x, const double y, const uint clr);
    void LineAA(const int x1, const int y1, const int x2, const int y2, const uint clr, const uint style = UINT_MAX);
    void PolylineAA(int & x, int & y, const uint clr, const uint style = UINT_MAX);
    void PolygonAA(int & x, int & y, const uint clr, const uint style = UINT_MAX);
    void TriangleAA(const int x1, const int y1, const int x2, const int y2, const int x3, const int y3, const uint clr, const uint style = UINT_MAX);
    void CircleAA(const int x, const int y, const double r, const uint clr, const uint style = UINT_MAX);
    void EllipseAA(const double x1, const double y1, const double x2, const double y2, const uint clr, const uint style = UINT_MAX);
    void LineWu(int x1, int y1, int x2, int y2, const uint clr, const uint style = UINT_MAX);
    void PolylineWu(const int & x, const int & y, const uint clr, const uint style = UINT_MAX);
    void PolygonWu(const int & x, const int & y, const uint clr, const uint style = UINT_MAX);
    void TriangleWu(const int x1, const int y1, const int x2, const int y2, const int x3, const int y3, const uint clr, const uint style = UINT_MAX);
    void CircleWu(const int x, const int y, const double r, const uint clr, const uint style = UINT_MAX);
    void EllipseWu(const int x1, const int y1, const int x2, const int y2, const uint clr, const uint style = UINT_MAX);
    void LineThickVertical(const int x, const int y1, const int y2, const uint clr, const int size, const uint style, ENUM_LINE_END end_style);
    void LineThickHorizontal(const int x1, const int x2, const int y, const uint clr, const int size, const uint style, ENUM_LINE_END end_style);
    void LineThick(const int x1, const int y1, const int x2, const int y2, const uint clr, const int size, const uint style, ENUM_LINE_END end_style);
    void PolylineThick(const int & x, const int & y, const uint clr, const int size, const uint style, ENUM_LINE_END end_style);
    void PolygonThick(const int & x, const int & y, const uint clr, const int size, const uint style, ENUM_LINE_END end_style);
    void PolylineSmooth(const int & x, const int & y, const uint clr, const int size, ENUM_LINE_STYLE style = STYLE_SOLID, ENUM_LINE_END end_style = LINE_END_ROUND, double tension = 0.5, double step = 10);
    void PolygonSmooth(int & x, int & y, const uint clr, const int size, ENUM_LINE_STYLE style = STYLE_SOLID, ENUM_LINE_END end_style = LINE_END_ROUND, double tension = 0.5, double step = 10);
    void BitBlt(int dst_x, int dst_y, const uint & src, int src_width, int src_height, int src_x, int src_y, int src_dx, int src_dy, uint mode = 0);
    bool FontSet(const string name, const int size, const uint flags = 0, const uint angle = 0);
    bool FontNameSet(string name);
    bool FontSizeSet(int size);
    bool FontFlagsSet(uint flags);
    bool FontAngleSet(uint angle);
    void FontGet(string & name, int & size, uint & flags, uint & angle);
    string FontNameGet(void) const;
    int FontSizeGet(void) const;
    uint FontFlagsGet(void) const;
    uint FontAngleGet(void) const;
    void TextOut(int x, int y, string text, const uint clr, uint alignment = 0);
    int TextWidth(const string text);
    int TextHeight(const string text);
    void TextSize(const string text, int & width, int & height);
    static uint GetDefaultColor(const int i);
    void TransparentLevelSet(const uchar value);
    bool LoadFromFile(const string filename);
    uint LineStyleGet(void) const;
    void LineStyleSet(const uint style);
    static bool LoadBitmap(const string filename, uint & data, int & width, int & height);
protected:
    long m_chart_id;
    string m_objname;
    ENUM_OBJECT m_objtype;
    string m_rcname;
    int m_width;
    int m_height;
    ENUM_COLOR_FORMAT m_format;
    string m_fontname;
    int m_fontsize;
    uint m_fontflags;
    uint m_fontangle;
    uint m_pixels;
    virtual double FilterFunction(const double x);
};

struct BitmapHeader {
public:
    ushort type;
    uint size;
    uint reserv;
    uint offbits;
    uint imgSSize;
    uint imgWidth;
    uint imgHeight;
    ushort imgPlanes;
    ushort imgBitCount;
    uint imgCompression;
    uint imgSizeImage;
    uint imgXPelsPerMeter;
    uint imgYPelsPerMeter;
    uint imgClrUsed;
    uint imgClrImportant;
};

class CChartCanvas : public CCanvas {
public:
    CChartCanvas(void);
    ~CChartCanvas();
    virtual bool Create(const string name, const int width, const int height, ENUM_COLOR_FORMAT clrfmt = COLOR_FORMAT_XRGB_NOALPHA);
    uint ColorBackground(void) const;
    void ColorBackground(const uint value);
    uint ColorBorder(void) const;
    void ColorBorder(const uint value);
    uint ColorText(void) const;
    void ColorText(const uint value);
    uint ColorGrid(void) const;
    void ColorGrid(const uint value);
    uint MaxData(void) const;
    void MaxData(const uint value);
    uint MaxDescrLen(void) const;
    void MaxDescrLen(const uint value);
    void AllowedShowFlags(const uint flags);
    uint ShowFlags(void) const;
    void ShowFlags(const uint flags);
    bool IsShowLegend(void) const;
    bool IsShowScaleLeft(void) const;
    bool IsShowScaleRight(void) const;
    bool IsShowScaleTop(void) const;
    bool IsShowScaleBottom(void) const;
    bool IsShowGrid(void) const;
    bool IsShowDescriptors(void) const;
    bool IsShowPercent(void) const;
    void ShowLegend(const bool flag = true);
    void ShowScaleLeft(const bool flag = true);
    void ShowScaleRight(const bool flag = true);
    void ShowScaleTop(const bool flag = true);
    void ShowScaleBottom(const bool flag = true);
    void ShowGrid(const bool flag = true);
    void ShowDescriptors(const bool flag = true);
    void ShowValue(const bool flag = true);
    void ShowPercent(const bool flag = true);
    void LegendAlignment(const ENUM_ALIGNMENT value);
    void Accumulative(const bool flag = true);
    double VScaleMin(void) const;
    void VScaleMin(const double value);
    double VScaleMax(void) const;
    void VScaleMax(const double value);
    uint NumGrid(void) const;
    void NumGrid(const uint value);
    void VScaleParams(const double max, const double min, const uint grid);
    int DataOffset(void) const;
    void DataOffset(const int value);
    uint DataTotal(void) const;
    bool DescriptorUpdate(const uint pos, const string descr);
    bool ColorUpdate(const uint pos, const uint clr);
protected:
    uint m_color_background;
    uint m_color_border;
    uint m_color_text;
    uint m_color_grid;
    uint m_max_data;
    uint m_max_descr_len;
    uint m_allowed_show_flags;
    uint m_show_flags;
    ENUM_ALIGNMENT m_legend_alignment;
    uint m_threshold_drawing;
    bool m_accumulative;
    double m_v_scale_min;
    double m_v_scale_max;
    uint m_num_grid;
    int m_scale_digits;
    int m_data_offset;
    uint m_data_total;
    CArrayUInt m_colors;
    CArrayString m_descriptors;
    CArrayInt m_index;
    uint m_index_size;
    double m_sum;
    double m_others;
    uint m_max_descr_width;
    uint m_max_value_width;
    CRect m_data_area;
    double m_scale_x;
    int m_x_min;
    int m_x_0;
    int m_x_max;
    int m_dx_grid;
    double m_scale_y;
    int m_y_min;
    int m_y_0;
    int m_y_max;
    int m_dy_grid;
    string m_scale_text;
    virtual void ValuesCheck(void);
    virtual void Redraw(void);
    virtual void DrawBackground(void);
    virtual void DrawLegend(void);
    int DrawLegendVertical(const int w, const int h);
    int DrawLegendHorizontal(const int w, const int h);
    virtual void CalcScales(void);
    virtual void DrawScales(void);
    virtual int DrawScaleLeft(const bool draw = true);
    virtual int DrawScaleRight(const bool draw = true);
    virtual int DrawScaleTop(const bool draw = true);
    virtual int DrawScaleBottom(const bool draw = true);
    virtual void DrawGrid(void);
    virtual void DrawDescriptors(void);
    virtual void DrawChart(void);
    virtual void DrawData(const uint idx = 0);
};

class CHistogramChart : public CChartCanvas {
public:
    CHistogramChart(void);
    ~CHistogramChart();
    virtual bool Create(const string name, const int width, const int height, ENUM_COLOR_FORMAT clrfmt = COLOR_FORMAT_ARGB_NORMALIZE);
    void Gradient(const bool flag = true);
    void BarGap(const uint value);
    void BarMinSize(const uint value);
    void BarBorder(const uint value);
    bool SeriesAdd(const double & value, const string descr = "", const uint clr = 0);
    bool SeriesInsert(const uint pos, const double & value, const string descr = "", const uint clr = 0);
    bool SeriesUpdate(const uint pos, const double & value, const string descr = NULL, const uint clr = 0);
    bool SeriesDelete(const uint pos);
    bool ValueUpdate(const uint series, const uint pos, double value);
protected:
    virtual void DrawData(const uint idx);
    void DrawBar(const int x, const int y, const int w, const int h, const uint clr);
    void GradientBrush(const int size, const uint fill_clr);
};

class CLineChart : public CChartCanvas {
public:
    CLineChart(void);
    ~CLineChart();
    virtual bool Create(const string name, const int width, const int height, ENUM_COLOR_FORMAT clrfmt = COLOR_FORMAT_ARGB_NORMALIZE);
    void Filled(const bool flag = true);
    bool SeriesAdd(const double & value, const string descr = "", const uint clr = 0);
    bool SeriesInsert(const uint pos, const double & value, const string descr = "", const uint clr = 0);
    bool SeriesUpdate(const uint pos, const double & value, const string descr = NULL, const uint clr = 0);
    bool SeriesDelete(const uint pos);
    bool ValueUpdate(const uint series, const uint pos, double value);
protected:
    virtual void DrawChart(void);
    virtual void DrawData(const uint index = 0);
};

class CPieChart : public CChartCanvas {
public:
    CPieChart(void);
    ~CPieChart();
    virtual bool Create(const string name, const int width, const int height, ENUM_COLOR_FORMAT clrfmt = COLOR_FORMAT_XRGB_NOALPHA);
    bool SeriesSet(const double & value, const string & text, const uint & clr);
    bool ValueAdd(const double value, const string descr = "", const uint clr = 0);
    bool ValueInsert(const uint pos, const double value, const string descr = "", const uint clr = 0);
    bool ValueUpdate(const uint pos, const double value, const string descr = NULL, const uint clr = 0);
    bool ValueDelete(const uint pos);
protected:
    virtual void DrawChart(void);
    void DrawPie(double fi3, double fi4, int idx, CPoint & p, const uint clr);
    string LabelMake(const string text, const double value, const bool to_left);
};

class CDXMesh : public CDXObject {
public:
    CDXMesh(void);
    ~CDXMesh();
    bool Create(CDXDispatcher & dispatcher, CDXInput* buffer_scene, const DXVertex & vertices, const uint & indices, ENUM_DX_PRIMITIVE_TOPOLOGY topology = DX_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
    bool Create(CDXDispatcher & dispatcher, CDXInput* buffer_scene, string obj_path, float scale = 1.0f, bool inverse_winding = false);
    bool VerticesSet(const DXVertex & vertices);
    bool IndicesSet(const uint & indices);
    bool TopologySet(ENUM_DX_PRIMITIVE_TOPOLOGY topology);
    void TransformMatrixGet(DXMatrix & mat) const;
    void TransformMatrixSet(const DXMatrix & mat);
    void DiffuseColorGet(DXColor & clr) const;
    void DiffuseColorSet(const DXColor & clr);
    void SpecularColorGet(DXColor & clr) const;
    void SpecularColorSet(const DXColor & clr);
    void SpecularPowerGet(float & power) const;
    void SpecularPowerSet(float power);
    void EmissionColorGet(DXColor & clr) const;
    void EmissionColorSet(const DXColor & clr);
    virtual bool Render(void);
    bool TextureSet(CDXDispatcher & dispatcher, string path, uint data_x = 0, uint data_y = 0, uint data_width = 0, uint data_height = 0);
    bool TextureSet(CDXDispatcher & dispatcher, ENUM_DX_FORMAT format, uint width, uint height, const uint & data, uint data_x = 0, uint data_y = 0, uint data_width = 0, uint data_height = 0);
    void TextureDelete();
    virtual void Shutdown(void);
protected:
    DXMatrix m_transform_matrix;
    DXColor m_diffuse_color;
    DXColor m_emission_color;
    DXColor m_specular_color;
    float m_specular_power;
    ENUM_DX_PRIMITIVE_TOPOLOGY m_topology;
};

class CDXBox : public CDXMesh {
public:
    CDXBox();
    ~CDXBox();
    bool Create(CDXDispatcher & dispatcher, CDXInput* buffer_scene, const DXVector3 & from, const DXVector3 & to);
    bool Update(const DXVector3 & from, const DXVector3 & to);
};

class CDXVertexBuffer : public CDXHandleShared {
public:
    virtual ~CDXVertexBuffer();
    bool Render(uint start = 0, uint count = WHOLE_ARRAY);
    void Shutdown(void);
};

class CDXIndexBuffer : public CDXHandleShared {
public:
    virtual ~CDXIndexBuffer();
    bool Create(int context_handle, const uint & indices, uint start = 0, uint count = WHOLE_ARRAY);
    bool Render(uint start = 0, uint count = WHOLE_ARRAY);
    void Shutdown(void);
};

class CDXDispatcher : public CDXObjectBase {
public:
    CDXDispatcher(void);
    ~CDXDispatcher();
    bool Create(int context);
    void Destroy(void);
    void Check(void);
    int DXContext(void) const;
    CDXIndexBuffer* IndexBufferCreate(const uint & indicies, uint start = 0, uint count = WHOLE_ARRAY);
    CDXTexture* TextureCreateFromFile(string path, uint data_x = 0, uint data_y = 0, uint data_width = 0, uint data_height = 0);
    CDXTexture* TextureCreateFromData(ENUM_DX_FORMAT format, uint width, uint height, const uint & data, uint data_x = 0, uint data_y = 0, uint data_width = 0, uint data_height = 0);
protected:
    CDXObjectBase m_dx_resources;
};

struct DXColor {
public:
    float r;
    float g;
    float b;
    float a;
    DXColor(void);
    DXColor(float red, float green, float blue, float alpha);
    DXColor(const DXVector4 & v);
    DXColor(const DXVector3 & v);
    DXColor(const DXColor   & c);
};

struct DXPlane {
public:
    float a;
    float b;
    float c;
    float d;
};

struct DXVector2 {
public:
    float x;
    float y;
    DXVector2(void);
    DXVector2(float v);
    DXVector2(float vx, float vy);
    DXVector2(const DXVector3 & v);
    DXVector2(const DXVector4 & v);
};

struct DXVector3 {
public:
    float x;
    float y;
    float z;
    DXVector3(void);
    DXVector3(float v);
    DXVector3(float vx, float vy, float vz);
    DXVector3(const DXVector2 & v);
    DXVector3(const DXVector4 & v);
};

struct DXVector4 {
public:
    float x;
    float y;
    float z;
    float w;
    DXVector4(void);
    DXVector4(float v);
    DXVector4(float vx, float vy, float vz, float vw);
    DXVector4(const DXVector2 & v);
    DXVector4(const DXVector3 & v);
    DXVector4(const DXVector4 & v);
};

struct DXMatrix {
};

struct DXQuaternion {
public:
    float x;
    float y;
    float z;
    float w;
};

struct DViewport {
public:
    ulong x;
    ulong y;
    ulong width;
    ulong height;
    float minz;
    float maxz;
};

class CDXSurface : public CDXMesh {
public:
    enum EN_SURFACE_FLAGS;
    enum EN_COLOR_SCHEME;
    CDXSurface();
    ~CDXSurface();
    bool Create(CDXDispatcher & dispatcher, CDXInput* buffer_scene, double & data, uint m_data_widht, uint m_data_height, float data_range, const DXVector3 & from, const DXVector3 & to, DXVector2 & texture_size, uint flags = SF_NONE, EN_COLOR_SCHEME color_scheme = CS_NONE);
    bool Update(double & data, uint m_data_widht, uint m_data_height, float data_range, const DXVector3 & from, const DXVector3 & to, DXVector2 & texture_size, uint flags = 0, EN_COLOR_SCHEME color_scheme = CS_NONE);
protected:
    uint m_data_width;
    uint m_data_height;
    uint m_flags;
    EN_COLOR_SCHEME m_color_scheme;
};

struct OBJFaceType {
public:
    int total;
    int v;
    int t;
    int n;
};

struct GRADIENT_COLOR {
public:
    uint clr;
    uint pos;
};

struct GRADIENT_SIZE {
public:
    uint size;
    uint pos;
};

class CFlameCanvas : public CCanvas {
public:
    CFlameCanvas(void);
    ~CFlameCanvas();
    bool FlameCreate(const string name, const datetime time, const int future_bars, const int back_bars = 0);
    void RatesTotal(const int value);
    void PaletteSet(uint clr = 0xFF0000);
    void FlameDraw(const double & prices, const int width, const int lenght);
    void FlameSet(datetime xb1, double yb1, datetime xe1, double ye1, datetime xb2, double yb2, datetime xe2, double ye2);
    void ChartEventHandler(const int id, const long & lparam, const double & dparam, const string & sparam);
protected:
    bool Resize(void);
    void ChartScale(void);
    void FlameSet(void);
    void CloudDraw(const double & prices, const int width, const int lenght, GRADIENT_SIZE & size, GRADIENT_COLOR & gradient, const uchar t_level = 255, const bool custom_gradient = true);
    void FlameDraw(const int width, const int lenght, GRADIENT_SIZE & size, GRADIENT_COLOR & gradient);
    void GradientVertical(const int xb, const int xe, const int yb1, const int ye1, const int yb2, const int ye2, const GRADIENT_COLOR & gradient);
    void GradientVerticalLine(int x, int y1, int y2, const GRADIENT_COLOR & gradient);
    void GradientVerticalLineMonochrome(int x, int y1, int y2, uint clr1, uint clr2);
    void FlameCreate(void);
    void FlameCalculate(void);
    void Delay(const uint value);
};

class CChartObject : public CObject {
public:
    CChartObject(void);
    ~CChartObject();
    virtual int Type(void) const;
    long ChartId(void) const;
    int Window(void) const;
    string Name(void) const;
    bool Name(const string name);
    int NumPoints(void) const;
    bool Attach(long chart_id, const string name, const int window, const int points);
    bool SetPoint(const int point, const datetime time, const double price) const;
    bool Delete(void);
    void Detach(void);
    datetime Time(const int point) const;
    bool Time(const int point, const datetime time) const;
    double Price(const int point) const;
    bool Price(const int point, const double price) const;
    color Color(void) const;
    bool Color(const color new_color) const;
    ENUM_LINE_STYLE Style(void) const;
    bool Style(const ENUM_LINE_STYLE new_style) const;
    int Width(void) const;
    bool Width(const int new_width) const;
    bool Background(void) const;
    bool Background(const bool new_back) const;
    bool Fill(void) const;
    bool Fill(const bool new_fill) const;
    long Z_Order(void) const;
    bool Z_Order(const long value) const;
    bool Selected(void) const;
    bool Selected(const bool new_sel) const;
    bool Selectable(void) const;
    bool Selectable(const bool new_sel) const;
    string Description(void) const;
    bool Description(const string new_text) const;
    string Tooltip(void) const;
    bool Tooltip(const string new_text) const;
    int Timeframes(void) const;
    virtual bool Timeframes(const int timeframes) const;
    datetime CreateTime(void) const;
    int LevelsCount(void) const;
    bool LevelsCount(const int new_count) const;
    color LevelColor(const int level) const;
    bool LevelColor(const int level, const color new_color) const;
    ENUM_LINE_STYLE LevelStyle(const int level) const;
    bool LevelStyle(const int level, const ENUM_LINE_STYLE new_style) const;
    int LevelWidth(const int level) const;
    bool LevelWidth(const int level, const int new_width) const;
    double LevelValue(const int level) const;
    bool LevelValue(const int level, const double new_value) const;
    string LevelDescription(const int level) const;
    bool LevelDescription(const int level, const string new_text) const;
    long GetInteger(const ENUM_OBJECT_PROPERTY_INTEGER prop_id, const int modifier = -1) const;
    bool GetInteger(const ENUM_OBJECT_PROPERTY_INTEGER prop_id, const int modifier, long & value) const;
    bool SetInteger(const ENUM_OBJECT_PROPERTY_INTEGER prop_id, const int modifier, const long value) const;
    bool SetInteger(const ENUM_OBJECT_PROPERTY_INTEGER prop_id, const long value) const;
    double GetDouble(const ENUM_OBJECT_PROPERTY_DOUBLE prop_id, const int modifier = -1) const;
    bool GetDouble(const ENUM_OBJECT_PROPERTY_DOUBLE prop_id, const int modifier, double & value) const;
    bool SetDouble(const ENUM_OBJECT_PROPERTY_DOUBLE prop_id, const int modifier, const double value) const;
    bool SetDouble(const ENUM_OBJECT_PROPERTY_DOUBLE prop_id, const double value) const;
    string GetString(const ENUM_OBJECT_PROPERTY_STRING prop_id, const int modifier = -1) const;
    bool GetString(const ENUM_OBJECT_PROPERTY_STRING prop_id, const int modifier, string & value) const;
    bool SetString(const ENUM_OBJECT_PROPERTY_STRING prop_id, const int modifier, const string value) const;
    bool SetString(const ENUM_OBJECT_PROPERTY_STRING prop_id, const string value) const;
    bool ShiftObject(const datetime d_time, const double d_price) const;
    bool ShiftPoint(const int point, const datetime d_time, const double d_price) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
protected:
    long m_chart_id;
    int m_window;
    string m_name;
    int m_num_points;
};

class CChartObjectText : public CChartObject {
public:
    CChartObjectText(void);
    ~CChartObjectText();
    bool Create(long chart_id, const string name, const int window, const datetime time, const double price);
    virtual int Type(void) const;
    double Angle(void) const;
    bool Angle(const double angle) const;
    string Font(void) const;
    bool Font(const string font) const;
    int FontSize(void) const;
    bool FontSize(const int size) const;
    ENUM_ANCHOR_POINT Anchor(void) const;
    bool Anchor(const ENUM_ANCHOR_POINT anchor) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectLabel : public CChartObjectText {
public:
    CChartObjectLabel(void);
    ~CChartObjectLabel();
    bool Create(long chart_id, const string name, const int window, const int X, const int Y);
    virtual int Type(void) const;
    int X_Distance(void) const;
    bool X_Distance(const int X) const;
    int Y_Distance(void) const;
    bool Y_Distance(const int Y) const;
    int X_Size(void) const;
    int Y_Size(void) const;
    ENUM_BASE_CORNER Corner(void) const;
    bool Corner(const ENUM_BASE_CORNER corner) const;
    datetime Time(const int point) const;
    bool Time(const int point, const datetime time) const;
    double Price(const int point) const;
    bool Price(const int point, const double price) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectEdit : public CChartObjectLabel {
public:
    CChartObjectEdit(void);
    ~CChartObjectEdit();
    bool Create(long chart_id, const string name, const int window, const int X, const int Y, const int sizeX, const int sizeY);
    virtual int Type(void) const;
    bool X_Size(const int X) const;
    int X_Size(void) const;
    bool Y_Size(const int Y) const;
    int Y_Size(void) const;
    color BackColor(void) const;
    bool BackColor(const color new_color) const;
    color BorderColor(void) const;
    bool BorderColor(const color new_color) const;
    bool ReadOnly(void) const;
    bool ReadOnly(const bool flag) const;
    ENUM_ALIGN_MODE TextAlign(void) const;
    bool TextAlign(const ENUM_ALIGN_MODE align) const;
    bool Angle(const double angle) const;
    double Angle(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectButton : public CChartObjectEdit {
public:
    CChartObjectButton(void);
    ~CChartObjectButton();
    virtual int Type(void) const;
    bool State(void) const;
    bool State(const bool state) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectPanel : public CChartObjectButton {
public:
    CChartObjectPanel();
    ~CChartObjectPanel();
    bool Attach(CChartObjectLabel * chart_object);
    bool X_Distance(const int X);
    int X_Distance(void) const;
    bool Y_Distance(const int Y);
    int Y_Distance(void) const;
    int X_Size() const;
    int X_Size(const int Y) const;
    int Y_Size() const;
    int Y_Size(const int Y) const;
    int Timeframes(void) const;
    virtual bool Timeframes(const int timeframes);
    bool State(const bool state);
    bool State(void) const;
    bool CheckState();
protected:
    CArrayObj m_attachment;
    CArrayInt m_dX;
    CArrayInt m_dY;
    bool m_expanded;
};

class CChartObjectArrow : public CChartObject {
public:
    CChartObjectArrow(void);
    ~CChartObjectArrow();
    bool Create(long chart_id, const string name, const int window, const datetime time, const double price, const char code);
    virtual int Type(void) const;
    char ArrowCode(void) const;
    virtual bool ArrowCode(const char code) const;
    ENUM_ARROW_ANCHOR Anchor(void) const;
    virtual bool Anchor(const ENUM_ARROW_ANCHOR anchor) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectArrowThumbUp : public CChartObjectArrow {
public:
    CChartObjectArrowThumbUp(void);
    ~CChartObjectArrowThumbUp();
    bool Create(long chart_id, const string name, const int window, const datetime time, const double price);
    virtual int Type(void) const;
    virtual bool ArrowCode(const char code) const;
    char ArrowCode(void) const;
};

class CChartObjectArrowThumbDown : public CChartObjectArrow {
public:
    CChartObjectArrowThumbDown(void);
    ~CChartObjectArrowThumbDown();
    bool Create(long chart_id, const string name, const int window, const datetime time, const double price);
    virtual int Type(void) const;
    virtual bool ArrowCode(const char code) const;
    char ArrowCode(void) const;
};

class CChartObjectArrowUp : public CChartObjectArrow {
public:
    CChartObjectArrowUp(void);
    ~CChartObjectArrowUp();
    bool Create(long chart_id, const string name, const int window, const datetime time, const double price);
    virtual int Type(void) const;
    virtual bool ArrowCode(const char code) const;
    char ArrowCode(void) const;
};

class CChartObjectArrowDown : public CChartObjectArrow {
public:
    CChartObjectArrowDown(void);
    ~CChartObjectArrowDown();
    bool Create(long chart_id, const string name, const int window, const datetime time, const double price);
    virtual int Type(void) const;
    virtual bool ArrowCode(const char code) const;
    char ArrowCode(void) const;
};

class CChartObjectArrowStop : public CChartObjectArrow {
public:
    CChartObjectArrowStop(void);
    ~CChartObjectArrowStop();
    bool Create(long chart_id, const string name, const int window, const datetime time, const double price);
    virtual int Type(void) const;
    virtual bool ArrowCode(const char code) const;
    char ArrowCode(void) const;
};

class CChartObjectArrowCheck : public CChartObjectArrow {
public:
    CChartObjectArrowCheck(void);
    ~CChartObjectArrowCheck();
    bool Create(long chart_id, const string name, const int window, const datetime time, const double price);
    virtual int Type(void) const;
    virtual bool ArrowCode(const char code) const;
    char ArrowCode(void) const;
};

class CChartObjectArrowLeftPrice : public CChartObjectArrow {
public:
    CChartObjectArrowLeftPrice(void);
    ~CChartObjectArrowLeftPrice();
    bool Create(long chart_id, const string name, const int window, const datetime time, const double price);
    virtual int Type(void) const;
    virtual bool ArrowCode(const char code) const;
    char ArrowCode(void) const;
    virtual bool Anchor(const ENUM_ARROW_ANCHOR anchor) const;
    ENUM_ARROW_ANCHOR Anchor(void) const;
};

class CChartObjectArrowRightPrice : public CChartObjectArrow {
public:
    CChartObjectArrowRightPrice(void);
    ~CChartObjectArrowRightPrice();
    bool Create(long chart_id, const string name, const int window, const datetime time, const double price);
    virtual int Type(void) const;
    virtual bool ArrowCode(const char code) const;
    char ArrowCode(void) const;
    virtual bool Anchor(const ENUM_ARROW_ANCHOR anchor) const;
    ENUM_ARROW_ANCHOR Anchor(void) const;
};

class CChartObjectBitmap : public CChartObject {
public:
    CChartObjectBitmap(void);
    ~CChartObjectBitmap();
    string BmpFile(void) const;
    bool BmpFile(const string name) const;
    int X_Offset(void) const;
    bool X_Offset(const int X) const;
    int Y_Offset(void) const;
    bool Y_Offset(const int Y) const;
    bool Create(long chart_id, const string name, const int window, const datetime time, const double price);
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectBmpLabel : public CChartObject {
public:
    CChartObjectBmpLabel(void);
    ~CChartObjectBmpLabel();
    int X_Distance(void) const;
    bool X_Distance(const int X) const;
    int Y_Distance(void) const;
    bool Y_Distance(const int Y) const;
    int X_Size(void) const;
    int Y_Size(void) const;
    ENUM_BASE_CORNER Corner(void) const;
    bool Corner(const ENUM_BASE_CORNER corner) const;
    string BmpFileOn(void) const;
    bool BmpFileOn(const string name) const;
    string BmpFileOff(void) const;
    bool BmpFileOff(const string name) const;
    bool State(void) const;
    bool State(const bool state) const;
    int X_Offset(void) const;
    bool X_Offset(const int X) const;
    int Y_Offset(void) const;
    bool Y_Offset(const int Y) const;
    bool Time(const datetime time) const;
    bool Price(const double price) const;
    bool Create(long chart_id, const string name, const int window, const int X, const int Y);
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectTrend : public CChartObject {
public:
    CChartObjectTrend(void);
    ~CChartObjectTrend();
    bool RayLeft(void) const;
    bool RayLeft(const bool new_sel) const;
    bool RayRight(void) const;
    bool RayRight(const bool new_sel) const;
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2);
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectChannel : public CChartObjectTrend {
public:
    CChartObjectChannel(void);
    ~CChartObjectChannel();
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2, const datetime time3, const double price3);
    virtual int Type(void) const;
};

class CChartObjectStdDevChannel : public CChartObjectTrend {
public:
    CChartObjectStdDevChannel(void);
    ~CChartObjectStdDevChannel();
    double Deviations(void) const;
    bool Deviations(const double deviation) const;
    bool Create(long chart_id, const string name, const int window, const datetime time1, const datetime time2, const double deviation);
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectRegression : public CChartObjectTrend {
public:
    CChartObjectRegression(void);
    ~CChartObjectRegression();
    bool Create(long chart_id, const string name, const int window, const datetime time1, const datetime time2);
    virtual int Type(void) const;
};

class CChartObjectPitchfork : public CChartObjectTrend {
public:
    CChartObjectPitchfork(void);
    ~CChartObjectPitchfork();
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2, const datetime time3, const double price3);
    virtual int Type(void) const;
};

class CChartObjectElliottWave3 : public CChartObject {
public:
    CChartObjectElliottWave3(void);
    ~CChartObjectElliottWave3();
    ENUM_ELLIOT_WAVE_DEGREE Degree(void) const;
    bool Degree(const ENUM_ELLIOT_WAVE_DEGREE degree) const;
    bool Lines(void) const;
    bool Lines(const bool lines) const;
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2, const datetime time3, const double price3);
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectElliottWave5 : public CChartObjectElliottWave3 {
public:
    CChartObjectElliottWave5(void);
    ~CChartObjectElliottWave5();
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2, const datetime time3, const double price3, const datetime time4, const double price4, const datetime time5, const double price5);
    virtual int Type(void) const;
};

class CChartObjectFibo : public CChartObjectTrend {
public:
    CChartObjectFibo(void);
    ~CChartObjectFibo();
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2);
    virtual int Type(void) const;
};

class CChartObjectFiboTimes : public CChartObject {
public:
    CChartObjectFiboTimes(void);
    ~CChartObjectFiboTimes();
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2);
    virtual int Type(void) const;
};

class CChartObjectFiboFan : public CChartObject {
public:
    CChartObjectFiboFan(void);
    ~CChartObjectFiboFan();
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2);
    virtual int Type(void) const;
};

class CChartObjectFiboArc : public CChartObject {
public:
    CChartObjectFiboArc(void);
    ~CChartObjectFiboArc();
    double Scale(void) const;
    bool Scale(const double scale) const;
    bool Ellipse(void) const;
    bool Ellipse(const bool ellipse) const;
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2, const double scale);
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectFiboChannel : public CChartObjectTrend {
public:
    CChartObjectFiboChannel(void);
    ~CChartObjectFiboChannel();
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2, const datetime time3, const double price3);
    virtual int Type(void) const;
};

class CChartObjectFiboExpansion : public CChartObjectTrend {
public:
    CChartObjectFiboExpansion(void);
    ~CChartObjectFiboExpansion();
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2, const datetime time3, const double price3);
    virtual int Type(void) const;
};

class CChartObjectTrendByAngle : public CChartObjectTrend {
public:
    CChartObjectTrendByAngle(void);
    ~CChartObjectTrendByAngle();
    double Angle(void) const;
    bool Angle(const double angle) const;
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2);
    virtual int Type(void) const;
};

class CChartObjectGannLine : public CChartObjectTrendByAngle {
public:
    CChartObjectGannLine(void);
    ~CChartObjectGannLine();
    double PipsPerBar(void) const;
    bool PipsPerBar(const double ppb) const;
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double ppb);
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectGannFan : public CChartObjectTrend {
public:
    CChartObjectGannFan(void);
    ~CChartObjectGannFan();
    double PipsPerBar(void) const;
    bool PipsPerBar(const double ppb) const;
    bool Downtrend(void) const;
    bool Downtrend(const bool downtrend) const;
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double ppb);
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectGannGrid : public CChartObjectTrend {
public:
    CChartObjectGannGrid(void);
    ~CChartObjectGannGrid();
    double PipsPerBar(void) const;
    bool PipsPerBar(const double ppb) const;
    bool Downtrend(void) const;
    bool Downtrend(const bool downtrend) const;
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double ppb);
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectVLine : public CChartObject {
public:
    CChartObjectVLine(void);
    ~CChartObjectVLine();
    bool Create(long chart_id, const string name, const int window, const datetime time);
    virtual int Type(void) const;
};

class CChartObjectHLine : public CChartObject {
public:
    CChartObjectHLine(void);
    ~CChartObjectHLine();
    bool Create(long chart_id, const string name, const int window, const double price);
    virtual int Type(void) const;
};

class CChartObjectCycles : public CChartObject {
public:
    CChartObjectCycles(void);
    ~CChartObjectCycles();
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2);
    virtual int Type(void) const;
};

class CChartObjectRectangle : public CChartObject {
public:
    CChartObjectRectangle(void);
    ~CChartObjectRectangle();
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2);
    virtual int Type(void) const;
};

class CChartObjectTriangle : public CChartObject {
public:
    CChartObjectTriangle(void);
    ~CChartObjectTriangle();
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2, const datetime time3, const double price3);
    virtual int Type(void) const;
};

class CChartObjectEllipse : public CChartObject {
public:
    CChartObjectEllipse(void);
    ~CChartObjectEllipse();
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2, const datetime time3, const double price3);
    virtual int Type(void) const;
};

class CChartObjectRectLabel : public CChartObjectLabel {
public:
    CChartObjectRectLabel(void);
    ~CChartObjectRectLabel();
    bool Create(long chart_id, const string name, const int window, const int X, const int Y, const int sizeX, const int sizeY);
    virtual int Type(void) const;
    bool X_Size(const int X) const;
    int X_Size(void) const;
    bool Y_Size(const int Y) const;
    int Y_Size(void) const;
    color BackColor(void) const;
    bool BackColor(const color new_color) const;
    ENUM_BORDER_TYPE BorderType(void) const;
    bool BorderType(const ENUM_BORDER_TYPE flag) const;
    bool Angle(const double angle) const;
    double Angle(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectSubChart : public CChartObject {
public:
    CChartObjectSubChart(void);
    ~CChartObjectSubChart();
    bool Create(long chart_id, const string name, const int window, const int X, const int Y, const int sizeX, const int sizeY);
    virtual int Type(void) const;
    int X_Distance(void) const;
    bool X_Distance(const int X) const;
    int Y_Distance(void) const;
    bool Y_Distance(const int Y) const;
    ENUM_BASE_CORNER Corner(void) const;
    bool Corner(const ENUM_BASE_CORNER corner) const;
    int X_Size(void) const;
    bool X_Size(const int size) const;
    int Y_Size(void) const;
    bool Y_Size(const int size) const;
    string Symbol(void) const;
    bool Symbol(const string symbol) const;
    int Period(void) const;
    bool Period(const int period) const;
    int Scale(void) const;
    bool Scale(const int scale) const;
    bool DateScale(void) const;
    bool DateScale(const bool scale) const;
    bool PriceScale(void) const;
    bool PriceScale(const bool scale) const;
    datetime Time(const int point) const;
    bool Time(const int point, const datetime time) const;
    double Price(const int point) const;
    bool Price(const int point, const double price) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChart : public CObject {
public:
    CChart(void);
    ~CChart();
    long ChartId(void) const;
    virtual int Type(void) const;
    ENUM_CHART_MODE Mode(void) const;
    bool Mode(const ENUM_CHART_MODE mode) const;
    bool Foreground(void) const;
    bool Foreground(const bool foreground) const;
    bool Shift(void) const;
    bool Shift(const bool shift) const;
    double ShiftSize(void) const;
    bool ShiftSize(double shift) const;
    bool AutoScroll(void) const;
    bool AutoScroll(const bool auto_scroll) const;
    int Scale(void) const;
    bool Scale(int scale) const;
    bool ScaleFix(void) const;
    bool ScaleFix(const bool scale_fix) const;
    bool ScaleFix_11(void) const;
    bool ScaleFix_11(const bool scale_fix_11) const;
    double FixedMax(void) const;
    bool FixedMax(const double fixed_max) const;
    double FixedMin(void) const;
    bool FixedMin(const double fixed_min) const;
    bool ScalePPB(void) const;
    bool ScalePPB(const bool scale_ppb) const;
    double PointsPerBar(void) const;
    bool PointsPerBar(const double points_per_bar) const;
    bool ShowOHLC(void) const;
    bool ShowOHLC(const bool show) const;
    bool ShowLineBid(void) const;
    bool ShowLineBid(const bool show) const;
    bool ShowLineAsk(void) const;
    bool ShowLineAsk(const bool show) const;
    bool ShowLastLine(void) const;
    bool ShowLastLine(const bool show) const;
    bool ShowPeriodSep(void) const;
    bool ShowPeriodSep(const bool show) const;
    bool ShowGrid(void) const;
    bool ShowGrid(const bool show) const;
    ENUM_CHART_VOLUME_MODE ShowVolumes(void) const;
    bool ShowVolumes(const ENUM_CHART_VOLUME_MODE show) const;
    bool ShowObjectDescr(void) const;
    bool ShowObjectDescr(const bool show) const;
    bool ShowDateScale(const bool show) const;
    bool ShowPriceScale(const bool show) const;
    color ColorBackground(void) const;
    bool ColorBackground(const color new_color) const;
    color ColorForeground(void) const;
    bool ColorForeground(const color new_color) const;
    color ColorGrid(void) const;
    bool ColorGrid(const color new_color) const;
    color ColorBarUp(void) const;
    bool ColorBarUp(const color new_color) const;
    color ColorBarDown(void) const;
    bool ColorBarDown(const color new_color) const;
    color ColorCandleBull(void) const;
    bool ColorCandleBull(const color new_color) const;
    color ColorCandleBear(void) const;
    bool ColorCandleBear(const color new_color) const;
    color ColorChartLine(void) const;
    bool ColorChartLine(const color new_color) const;
    color ColorVolumes(void) const;
    bool ColorVolumes(const color new_color) const;
    color ColorLineBid(void) const;
    bool ColorLineBid(const color new_color) const;
    color ColorLineAsk(void) const;
    bool ColorLineAsk(const color new_color) const;
    color ColorLineLast(void) const;
    bool ColorLineLast(const color new_color) const;
    color ColorStopLevels(void) const;
    bool ColorStopLevels(const color new_color) const;
    bool BringToTop(void) const;
    bool EventObjectCreate(const bool flag = true) const;
    bool EventObjectDelete(const bool flag = true) const;
    bool EventMouseMove(const bool flag = true) const;
    bool MouseScroll(const bool flag = true) const;
    int VisibleBars(void) const;
    int WindowsTotal(void) const;
    bool WindowIsVisible(const int num) const;
    int WindowHandle(void) const;
    int FirstVisibleBar(void) const;
    int WidthInBars(void) const;
    int WidthInPixels(void) const;
    int HeightInPixels(const int num) const;
    int SubwindowY(const int num) const;
    double PriceMin(const int num) const;
    double PriceMax(const int num) const;
    bool IsObject(void) const;
    void Attach(void);
    void Attach(const long chart);
    void FirstChart(void);
    void NextChart(void);
    long Open(const string symbol_name, const ENUM_TIMEFRAMES timeframe);
    void Detach(void);
    void Close(void);
    bool Navigate(const ENUM_CHART_POSITION position, const int shift = 0) const;
    string Symbol(void) const;
    ENUM_TIMEFRAMES Period(void) const;
    void Redraw(void) const;
    long GetInteger(const ENUM_CHART_PROPERTY_INTEGER prop_id, const int sub_window = 0) const;
    bool GetInteger(const ENUM_CHART_PROPERTY_INTEGER prop_id, const int sub_window, long & value) const;
    bool SetInteger(const ENUM_CHART_PROPERTY_INTEGER prop_id, const long value) const;
    double GetDouble(const ENUM_CHART_PROPERTY_DOUBLE prop_id, const int sub_window = 0) const;
    bool GetDouble(const ENUM_CHART_PROPERTY_DOUBLE prop_id, const int sub_window, double & value) const;
    bool SetDouble(const ENUM_CHART_PROPERTY_DOUBLE prop_id, const double value) const;
    string GetString(const ENUM_CHART_PROPERTY_STRING prop_id) const;
    bool GetString(const ENUM_CHART_PROPERTY_STRING prop_id, string & value) const;
    bool SetString(const ENUM_CHART_PROPERTY_STRING prop_id, const string value) const;
    bool SetSymbolPeriod(const string symbol, const ENUM_TIMEFRAMES period) const;
    bool ApplyTemplate(const string filename) const;
    bool ScreenShot(const string filename, const int width, const int height, const ENUM_ALIGN_MODE align_mode = ALIGN_RIGHT) const;
    int WindowOnDropped(void) const;
    double PriceOnDropped(void) const;
    datetime TimeOnDropped(void) const;
    int XOnDropped(void) const;
    int YOnDropped(void) const;
    bool IndicatorAdd(const int subwin, const int handle) const;
    bool IndicatorDelete(const int subwin, const string name) const;
    int IndicatorsTotal(const int subwin) const;
    string IndicatorName(const int subwin, const int index) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
protected:
    long m_chart_id;
};

class CWnd : public CObject {
public:
    CWnd(void);
    ~CWnd();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual void Destroy(const int reason = 0);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    virtual bool OnMouseEvent(const int x, const int y, const int flags);
    string Name(void) const;
    int ControlsTotal(void) const;
    virtual CWnd* ControlFind(const long id);
    CRect Rect(void) const;
    int Left(void) const;
    virtual void Left(const int x);
    int Top(void) const;
    virtual void Top(const int y);
    int Right(void) const;
    virtual void Right(const int x);
    int Bottom(void) const;
    virtual void Bottom(const int y);
    int Width(void) const;
    virtual bool Width(const int w);
    int Height(void) const;
    virtual bool Height(const int h);
    CSize Size(void) const;
    virtual bool Size(const int w, const int h);
    virtual bool Size(const CSize & size);
    virtual bool Move(const int x, const int y);
    virtual bool Move(const CPoint & point);
    virtual bool Shift(const int dx, const int dy);
    bool Contains(const int x, const int y) const;
    bool Contains(CWnd * control) const;
    void Alignment(const int flags, const int left, const int top, const int right, const int bottom);
    virtual bool Align(const CRect & rect);
    virtual long Id(const long id);
    long Id(void) const;
    bool IsEnabled(void) const;
    virtual bool Enable(void);
    virtual bool Disable(void);
    bool IsVisible(void) const;
    virtual bool Visible(const bool flag);
    virtual bool Show(void);
    virtual bool Hide(void);
    bool IsActive(void) const;
    virtual bool Activate(void);
    virtual bool Deactivate(void);
    int StateFlags(void) const;
    void StateFlags(const int flags);
    void StateFlagsSet(const int flags);
    void StateFlagsReset(const int flags);
    int PropFlags(void) const;
    void PropFlags(const int flags);
    void PropFlagsSet(const int flags);
    void PropFlagsReset(const int flags);
    int MouseX(void) const;
    void MouseX(const int value);
    int MouseY(void) const;
    void MouseY(const int value);
    int MouseFlags(void) const;
    virtual void MouseFlags(const int value);
    bool MouseFocusKill(const long id = CONTROLS_INVALID_ID);
    bool BringToTop(void);
protected:
    long m_chart_id;
    int m_subwin;
    string m_name;
    CRect m_rect;
    long m_id;
    int m_state_flags;
    int m_prop_flags;
    int m_align_flags;
    int m_align_left;
    int m_align_top;
    int m_align_right;
    int m_align_bottom;
    int m_mouse_x;
    int m_mouse_y;
    int m_mouse_flags;
    uint m_last_click;
    virtual bool OnCreate(void);
    virtual bool OnDestroy(void);
    virtual bool OnMove(void);
    virtual bool OnResize(void);
    virtual bool OnEnable(void);
    virtual bool OnDisable(void);
    virtual bool OnShow(void);
    virtual bool OnHide(void);
    virtual bool OnActivate(void);
    virtual bool OnDeactivate(void);
    virtual bool OnClick(void);
    virtual bool OnDblClick(void);
    virtual bool OnChange(void);
    virtual bool OnMouseDown(void);
    virtual bool OnMouseUp(void);
    virtual bool OnDragStart(void);
    virtual bool OnDragProcess(const int x, const int y);
    virtual bool OnDragEnd(void);
    virtual bool DragObjectCreate(void);
    virtual bool DragObjectDestroy(void);
};

class CWndObj : public CWnd {
public:
    CWndObj(void);
    ~CWndObj();
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    string Text(void) const;
    bool Text(const string value);
    color Color(void) const;
    bool Color(const color value);
    color ColorBackground(void) const;
    bool ColorBackground(const color value);
    color ColorBorder(void) const;
    bool ColorBorder(const color value);
    string Font(void) const;
    bool Font(const string value);
    int FontSize(void) const;
    bool FontSize(const int value);
    long ZOrder(void) const;
    bool ZOrder(const long value);
protected:
    string m_text;
    color m_color;
    color m_color_background;
    color m_color_border;
    string m_font;
    int m_font_size;
    long m_zorder;
    virtual bool OnObjectCreate(void);
    virtual bool OnObjectChange(void);
    virtual bool OnObjectDelete(void);
    virtual bool OnObjectDrag(void);
    virtual bool OnSetText(void);
    virtual bool OnSetColor(void);
    virtual bool OnSetColorBackground(void);
    virtual bool OnSetColorBorder(void);
    virtual bool OnSetFont(void);
    virtual bool OnSetFontSize(void);
    virtual bool OnSetZOrder(void);
    virtual bool OnDestroy(void);
    virtual bool OnChange(void);
};

class CBmpButton : public CWndObj {
public:
    CBmpButton(void);
    ~CBmpButton();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    int Border(void) const;
    bool Border(const int value);
    bool BmpNames(const string off = "", const string on = "");
    string BmpOffName(void) const;
    bool BmpOffName(const string name);
    string BmpOnName(void) const;
    bool BmpOnName(const string name);
    string BmpPassiveName(void) const;
    bool BmpPassiveName(const string name);
    string BmpActiveName(void) const;
    bool BmpActiveName(const string name);
    bool Pressed(void) const;
    bool Pressed(const bool pressed);
    bool Locking(void) const;
    void Locking(const bool locking);
protected:
    virtual bool OnSetZOrder(void);
    virtual bool OnCreate(void);
    virtual bool OnShow(void);
    virtual bool OnHide(void);
    virtual bool OnMove(void);
    virtual bool OnChange(void);
    virtual bool OnActivate(void);
    virtual bool OnDeactivate(void);
    virtual bool OnMouseDown(void);
    virtual bool OnMouseUp(void);
};

class CButton : public CWndObj {
public:
    CButton(void);
    ~CButton();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    bool Pressed(void) const;
    bool Pressed(const bool pressed);
    bool Locking(void) const;
    void Locking(const bool flag);
protected:
    virtual bool OnSetText(void);
    virtual bool OnSetColor(void);
    virtual bool OnSetColorBackground(void);
    virtual bool OnSetColorBorder(void);
    virtual bool OnSetFont(void);
    virtual bool OnSetFontSize(void);
    virtual bool OnCreate(void);
    virtual bool OnShow(void);
    virtual bool OnHide(void);
    virtual bool OnMove(void);
    virtual bool OnResize(void);
    virtual bool OnMouseDown(void);
    virtual bool OnMouseUp(void);
};

class CWndContainer : public CWnd {
public:
    CWndContainer(void);
    ~CWndContainer();
    virtual void Destroy(const int reason = 0);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    virtual bool OnMouseEvent(const int x, const int y, const int flags);
    int ControlsTotal(void) const;
    virtual CWnd* ControlFind(const long id);
    virtual bool MouseFocusKill(const long id = -1);
    bool Add(CWnd * control);
    bool Add(CWnd & control);
    bool Delete(CWnd * control);
    bool Delete(CWnd & control);
    virtual bool Move(const int x, const int y);
    virtual bool Move(const CPoint & point);
    virtual bool Shift(const int dx, const int dy);
    virtual long Id(const long id);
    long Id(void) const;
    virtual bool Enable(void);
    virtual bool Disable(void);
    virtual bool Show(void);
    virtual bool Hide(void);
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
protected:
    virtual bool OnResize(void);
    virtual bool OnActivate(void);
    virtual bool OnDeactivate(void);
};

class CCheckBox : public CWndContainer {
public:
    CCheckBox(void);
    ~CCheckBox();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    string Text(void) const;
    bool Text(const string value);
    color Color(void) const;
    bool Color(const color value);
    bool Checked(void) const;
    bool Checked(const bool flag);
    int Value(void) const;
    void Value(const int value);
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
protected:
    virtual bool CreateButton(void);
    virtual bool CreateLabel(void);
    virtual bool OnClickButton(void);
    virtual bool OnClickLabel(void);
};

class CWndClient : public CWndContainer {
public:
    CWndClient(void);
    ~CWndClient();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    virtual bool ColorBackground(const color value);
    virtual bool ColorBorder(const color value);
    virtual bool BorderType(const ENUM_BORDER_TYPE flag);
    virtual bool VScrolled(void);
    virtual bool VScrolled(const bool flag);
    virtual bool HScrolled(void);
    virtual bool HScrolled(const bool flag);
    virtual long Id(const long id);
    virtual long Id(void) const;
    virtual bool Show(void);
protected:
    bool m_v_scrolled;
    bool m_h_scrolled;
    CPanel m_background;
    CScrollV m_scroll_v;
    CScrollH m_scroll_h;
    virtual bool CreateBack(void);
    virtual bool CreateScrollV(void);
    virtual bool CreateScrollH(void);
    virtual bool OnResize(void);
    virtual bool OnVScrollShow(void);
    virtual bool OnVScrollHide(void);
    virtual bool OnHScrollShow(void);
    virtual bool OnHScrollHide(void);
    virtual bool OnScrollLineDown(void);
    virtual bool OnScrollLineUp(void);
    virtual bool OnScrollLineLeft(void);
    virtual bool OnScrollLineRight(void);
    virtual bool Rebound(const CRect & rect);
};

class CCheckGroup : public CWndClient {
public:
    CCheckGroup(void);
    ~CCheckGroup();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual void Destroy(const int reason = 0);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    virtual bool AddItem(const string item, const long value = 0);
    long Value(void) const;
    bool Value(const long value);
    int Check(const int idx) const;
    bool Check(const int idx, const int value);
    virtual bool Show(void);
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
protected:
    bool CreateButton(int index);
    virtual bool OnVScrollShow(void);
    virtual bool OnVScrollHide(void);
    virtual bool OnScrollLineDown(void);
    virtual bool OnScrollLineUp(void);
    virtual bool OnChangeItem(const int row_index);
    bool Redraw(void);
    bool RowState(const int index, const bool select);
};

class CComboBox : public CWndContainer {
public:
    CComboBox(void);
    ~CComboBox();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    bool AddItem(const string item, const long value = 0);
    void ListViewItems(const int value);
    virtual bool ItemAdd(const string item, const long value = 0);
    virtual bool ItemInsert(const int index, const string item, const long value = 0);
    virtual bool ItemUpdate(const int index, const string item, const long value = 0);
    virtual bool ItemDelete(const int index);
    virtual bool ItemsClear(void);
    string Select(void);
    bool Select(const int index);
    bool SelectByText(const string text);
    bool SelectByValue(const long value);
    long Value(void);
    virtual bool Show(void);
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
protected:
    virtual bool CreateEdit(void);
    virtual bool CreateButton(void);
    virtual bool CreateList(void);
    virtual bool OnClickEdit(void);
    virtual bool OnClickButton(void);
    virtual bool OnChangeList(void);
    bool ListShow(void);
    bool ListHide(void);
    void CheckListHide(const int id, int x, int y);
};

class CDateDropList : public CWndContainer {
public:
    CDateDropList(void);
    ~CDateDropList();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    datetime Value(void);
    void Value(datetime value);
    void Value(MqlDateTime& value);
    virtual bool Show(void);
protected:
    virtual bool OnClick(void);
    virtual bool CreateButtons(void);
    virtual bool CreateList(void);
    void DrawCanvas(void);
    void DrawClickRect(const int idx, int x, int y, string text, const uint clr, uint alignment = 0);
    virtual bool OnClickDec(void);
    virtual bool OnClickInc(void);
    virtual bool OnClickList(void);
};

class CDatePicker : public CWndContainer {
public:
    CDatePicker(void);
    ~CDatePicker();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    datetime Value(void) const;
    void Value(datetime value);
    virtual bool Show(void);
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
protected:
    virtual bool CreateEdit(void);
    virtual bool CreateButton(void);
    virtual bool CreateList(void);
    virtual bool OnClickEdit(void);
    virtual bool OnClickButton(void);
    virtual bool OnChangeList(void);
    bool ListShow(void);
    bool ListHide(void);
    void CheckListHide(const int id, int x, int y);
};

class CDialog : public CWndContainer {
public:
    CDialog(void);
    ~CDialog();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    string Caption(void) const;
    bool Caption(const string text);
    bool Add(CWnd * control);
    bool Add(CWnd & control);
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
protected:
    bool m_panel_flag;
    bool m_minimized;
    CRect m_min_rect;
    CRect m_norm_rect;
    virtual bool CreateWhiteBorder(void);
    virtual bool CreateBackground(void);
    virtual bool CreateCaption(void);
    virtual bool CreateButtonClose(void);
    virtual bool CreateClientArea(void);
    virtual void OnClickCaption(void);
    virtual void OnClickButtonClose(void);
    void CaptionAlignment(const int flags, const int left, const int top, const int right, const int bottom);
    bool ClientAreaVisible(const bool visible);
    int ClientAreaLeft(void) const;
    int ClientAreaTop(void) const;
    int ClientAreaRight(void) const;
    int ClientAreaBottom(void) const;
    int ClientAreaWidth(void) const;
    int ClientAreaHeight(void) const;
    virtual bool OnDialogDragStart(void);
    virtual bool OnDialogDragProcess(void);
    virtual bool OnDialogDragEnd(void);
};

class CAppDialog : public CDialog {
public:
    CAppDialog(void);
    ~CAppDialog();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual void Destroy(const int reason = REASON_PROGRAM);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    bool Run(void);
    void ChartEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    void Minimized(const bool flag);
    void IniFileSave(void);
    void IniFileLoad(void);
    virtual string IniFileName(void) const;
    virtual string IniFileExt(void) const;
    virtual bool Load(const int file_handle);
    virtual bool Save(const int file_handle);
protected:
    CChart m_chart;
    virtual bool CreateButtonMinMax(void);
    virtual void OnClickButtonClose(void);
    virtual void OnClickButtonMinMax(void);
    virtual void OnAnotherApplicationClose(const long & lparam, const double & dparam, const string & sparam);
    virtual bool Rebound(const CRect & rect);
    virtual void Minimize(void);
    virtual void Maximize(void);
    string CreateInstanceId(void);
    string ProgramName(void) const;
    void SubwinOff(void);
};

class CEdit : public CWndObj {
public:
    CEdit(void);
    ~CEdit();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    bool ReadOnly(void) const;
    bool ReadOnly(const bool flag);
    ENUM_ALIGN_MODE TextAlign(void) const;
    bool TextAlign(const ENUM_ALIGN_MODE align);
    string Text(void) const;
    bool Text(const string value);
protected:
    virtual bool OnObjectEndEdit(void);
    virtual bool OnSetText(void);
    virtual bool OnSetColor(void);
    virtual bool OnSetColorBackground(void);
    virtual bool OnSetColorBorder(void);
    virtual bool OnSetFont(void);
    virtual bool OnSetFontSize(void);
    virtual bool OnSetZOrder(void);
    virtual bool OnCreate(void);
    virtual bool OnShow(void);
    virtual bool OnHide(void);
    virtual bool OnMove(void);
    virtual bool OnResize(void);
    virtual bool OnChange(void);
    virtual bool OnClick(void);
};

class CLabel : public CWndObj {
public:
    CLabel(void);
    ~CLabel();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
protected:
    virtual bool OnSetText(void);
    virtual bool OnSetColor(void);
    virtual bool OnSetFont(void);
    virtual bool OnSetFontSize(void);
    virtual bool OnCreate(void);
    virtual bool OnShow(void);
    virtual bool OnHide(void);
    virtual bool OnMove(void);
};

class CListView : public CWndClient {
public:
    CListView(void);
    ~CListView();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual void Destroy(const int reason = 0);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    bool TotalView(const int value);
    virtual bool AddItem(const string item, const long value = 0);
    virtual bool ItemAdd(const string item, const long value = 0);
    virtual bool ItemInsert(const int index, const string item, const long value = 0);
    virtual bool ItemUpdate(const int index, const string item, const long value = 0);
    virtual bool ItemDelete(const int index);
    virtual bool ItemsClear(void);
    int Current(void);
    string Select(void);
    bool Select(const int index);
    bool SelectByText(const string text);
    bool SelectByValue(const long value);
    long Value(void);
    virtual bool Show(void);
protected:
    bool CreateRow(const int index);
    virtual bool OnResize(void);
    virtual bool OnVScrollShow(void);
    virtual bool OnVScrollHide(void);
    virtual bool OnScrollLineDown(void);
    virtual bool OnScrollLineUp(void);
    virtual bool OnItemClick(const int index);
    bool Redraw(void);
    bool RowState(const int index, const bool select);
    bool CheckView(void);
};

class CPanel : public CWndObj {
public:
    CPanel(void);
    ~CPanel();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    ENUM_BORDER_TYPE BorderType(void) const;
    bool BorderType(const ENUM_BORDER_TYPE type);
protected:
    virtual bool OnSetText(void);
    virtual bool OnSetColorBackground(void);
    virtual bool OnSetColorBorder(void);
    virtual bool OnCreate(void);
    virtual bool OnShow(void);
    virtual bool OnHide(void);
    virtual bool OnMove(void);
    virtual bool OnResize(void);
    virtual bool OnChange(void);
};

class CPicture : public CWndObj {
public:
    CPicture(void);
    ~CPicture();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    int Border(void) const;
    bool Border(const int value);
    string BmpName(void) const;
    bool BmpName(const string name);
protected:
    virtual bool OnCreate(void);
    virtual bool OnShow(void);
    virtual bool OnHide(void);
    virtual bool OnMove(void);
    virtual bool OnChange(void);
};

class CRadioButton : public CWndContainer {
public:
    CRadioButton(void);
    ~CRadioButton();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    string Text(void) const;
    bool Text(const string value);
    color Color(void) const;
    bool Color(const color value);
    bool State(void) const;
    bool State(const bool flag);
protected:
    virtual bool CreateButton(void);
    virtual bool CreateLabel(void);
    virtual bool OnClickButton(void);
    virtual bool OnClickLabel(void);
};

class CRadioGroup : public CWndClient {
public:
    CRadioGroup(void);
    ~CRadioGroup();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual void Destroy(const int reason = 0);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    virtual bool AddItem(const string item, const long value = 0);
    long Value(void) const;
    bool Value(const long value);
    bool ValueCheck(long value) const;
    virtual bool Show(void);
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
protected:
    bool CreateButton(const int index);
    virtual bool OnVScrollShow(void);
    virtual bool OnVScrollHide(void);
    virtual bool OnScrollLineDown(void);
    virtual bool OnScrollLineUp(void);
    virtual bool OnChangeItem(const int row_index);
    bool Redraw(void);
    bool RowState(const int index, const bool select);
    void Select(const int index);
};

struct CPoint {
public:
    int x;
    int y;
};

struct CSize {
public:
    int cx;
    int cy;
};

struct CRect {
public:
    int left;
    int top;
    int right;
    int bottom;
    CPoint LeftTop(void) const;
    void LeftTop(const int x, const int y);
    void LeftTop(const CPoint& point);
    CPoint RightBottom(void) const;
    void RightBottom(const int x, const int y);
    void RightBottom(const CPoint& point);
    CPoint CenterPoint(void) const;
    int Width(void) const;
    void Width(const int w);
    int Height(void) const;
    void Height(const int h);
    CSize Size(void) const;
    void Size(const int cx, const int cy);
    void Size(const CSize& size);
    void SetBound(const int l, const int t, const int r, const int b);
    void SetBound(const CRect& rect);
    void SetBound(const CPoint& point, const CSize& size);
    void SetBound(const CPoint& left_top, const CPoint& right_bottom);
    void Move(const int x, const int y);
    void Move(const CPoint& point);
    void Shift(const int dx, const int dy);
    void Shift(const CPoint& point);
    void Shift(const CSize& size);
    bool Contains(const int x, const int y) const;
    bool Contains(const CPoint& point) const;
    void Normalize(void);
};

class CScroll : public CWndContainer {
public:
    CScroll(void);
    ~CScroll();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    int MinPos(void) const;
    void MinPos(const int value);
    int MaxPos(void) const;
    void MaxPos(const int value);
    int CurrPos(void) const;
    bool CurrPos(int value);
protected:
    CPanel m_back;
    CBmpButton m_inc;
    CBmpButton m_dec;
    CBmpButton m_thumb;
    int m_min_pos;
    int m_max_pos;
    int m_curr_pos;
    virtual bool CreateBack(void);
    virtual bool CreateInc(void);
    virtual bool CreateDec(void);
    virtual bool CreateThumb(void);
    virtual bool OnClickInc(void);
    virtual bool OnClickDec(void);
    virtual bool OnShow(void);
    virtual bool OnHide(void);
    virtual bool OnChangePos(void);
    virtual bool OnThumbDragStart(void);
    virtual bool OnThumbDragProcess(void);
    virtual bool OnThumbDragEnd(void);
    virtual int CalcPos(const int coord);
};

class CScrollV : public CScroll {
public:
    CScrollV(void);
    ~CScrollV();
protected:
    virtual bool CreateInc(void);
    virtual bool CreateDec(void);
    virtual bool CreateThumb(void);
    virtual bool OnResize(void);
    virtual bool OnChangePos(void);
    virtual bool OnThumbDragStart(void);
    virtual bool OnThumbDragProcess(void);
    virtual bool OnThumbDragEnd(void);
    virtual int CalcPos(const int coord);
};

class CScrollH : public CScroll {
public:
    CScrollH(void);
    ~CScrollH();
protected:
    virtual bool CreateInc(void);
    virtual bool CreateDec(void);
    virtual bool CreateThumb(void);
    virtual bool OnResize(void);
    virtual bool OnChangePos(void);
    virtual bool OnThumbDragStart(void);
    virtual bool OnThumbDragProcess(void);
    virtual bool OnThumbDragEnd(void);
    virtual int CalcPos(const int coord);
};

class CSpinEdit : public CWndContainer {
public:
    CSpinEdit(void);
    ~CSpinEdit();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    int MinValue(void) const;
    void MinValue(const int value);
    int MaxValue(void) const;
    void MaxValue(const int value);
    int Value(void) const;
    bool Value(int value);
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
protected:
    virtual bool CreateEdit(void);
    virtual bool CreateInc(void);
    virtual bool CreateDec(void);
    virtual bool OnClickInc(void);
    virtual bool OnClickDec(void);
    virtual bool OnChangeValue(void);
};

class CDragWnd : public CWnd {
public:
    CDragWnd(void);
    ~CDragWnd();
    void Limits(const int l, const int t, const int r, const int b);
protected:
    int m_limit_left;
    int m_limit_top;
    int m_limit_right;
    int m_limit_bottom;
    virtual bool OnDragProcess(const int x, const int y);
};

class CExpertBase : public CObject {
public:
    CExpertBase(void);
    ~CExpertBase();
    ENUM_INIT_PHASE InitPhase(void) const;
    void TrendType(ENUM_TYPE_TREND value);
    int UsedSeries(void) const;
    void EveryTick(bool value);
    double Open(int ind) const;
    double High(int ind) const;
    double Low(int ind) const;
    double Close(int ind) const;
    int Spread(int ind) const;
    datetime Time(int ind) const;
    long TickVolume(int ind) const;
    long RealVolume(int ind) const;
    virtual bool Init(CSymbolInfo * symbol, ENUM_TIMEFRAMES period, double point);
    bool Symbol(string name);
    bool Period(ENUM_TIMEFRAMES value);
    void Magic(ulong value);
    void SetMarginMode(void);
    virtual bool ValidationSettings();
    virtual bool SetPriceSeries(CiOpen * open, CiHigh * high, CiLow * low, CiClose * close);
    virtual bool SetOtherSeries(CiSpread * spread, CiTime * time, CiTickVolume * tick_volume, CiRealVolume * real_volume);
    virtual bool InitIndicators(CIndicators * indicators = NULL);
protected:
    ulong m_magic;
    ENUM_INIT_PHASE m_init_phase;
    bool m_other_symbol;
    bool m_other_period;
    ENUM_TIMEFRAMES m_period;
    double m_adjusted_point;
    CAccountInfo m_account;
    ENUM_ACCOUNT_MARGIN_MODE m_margin_mode;
    ENUM_TYPE_TREND m_trend_type;
    bool m_every_tick;
    int m_used_series;
    bool InitOpen(CIndicators * indicators);
    bool InitHigh(CIndicators * indicators);
    bool InitLow(CIndicators * indicators);
    bool InitClose(CIndicators * indicators);
    bool InitSpread(CIndicators * indicators);
    bool InitTime(CIndicators * indicators);
    bool InitTickVolume(CIndicators * indicators);
    bool InitRealVolume(CIndicators * indicators);
    virtual double PriceLevelUnit(void);
    virtual int StartIndex(void);
    virtual bool CompareMagic(ulong magic);
    bool IsHedging(void) const;
};

class CExpertMoney : public CExpertBase {
public:
    CExpertMoney(void);
    ~CExpertMoney();
    void Percent(double percent);
    virtual bool ValidationSettings();
    virtual double CheckOpenLong(double price, double sl);
    virtual double CheckOpenShort(double price, double sl);
    virtual double CheckReverse(CPositionInfo * position, double sl);
    virtual double CheckClose(CPositionInfo * position);
protected:
    double m_percent;
};

class CExpertSignal : public CExpertBase {
public:
    CExpertSignal(void);
    ~CExpertSignal();
    void BasePrice(double value);
    int UsedSeries(void);
    void Weight(double value);
    void PatternsUsage(int value);
    void General(int value);
    void Ignore(long value);
    void Invert(long value);
    void ThresholdOpen(int value);
    void ThresholdClose(int value);
    void PriceLevel(double value);
    void StopLevel(double value);
    void TakeLevel(double value);
    void Expiration(int value);
    void Magic(ulong value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual bool AddFilter(CExpertSignal * filter);
    virtual bool CheckOpenLong(double & price, double & sl, double & tp, datetime & expiration);
    virtual bool CheckOpenShort(double & price, double & sl, double & tp, datetime & expiration);
    virtual bool OpenLongParams(double & price, double & sl, double & tp, datetime & expiration);
    virtual bool OpenShortParams(double & price, double & sl, double & tp, datetime & expiration);
    virtual bool CheckCloseLong(double & price);
    virtual bool CheckCloseShort(double & price);
    virtual bool CloseLongParams(double & price);
    virtual bool CloseShortParams(double & price);
    virtual bool CheckReverseLong(double & price, double & sl, double & tp, datetime & expiration);
    virtual bool CheckReverseShort(double & price, double & sl, double & tp, datetime & expiration);
    virtual bool CheckTrailingOrderLong(COrderInfo * order, double & price);
    virtual bool CheckTrailingOrderShort(COrderInfo * order, double & price);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
    virtual double Direction(void);
    void SetDirection(void);
protected:
    double m_base_price;
    CArrayObj m_filters;
    double m_weight;
    int m_patterns_usage;
    int m_general;
    long m_ignore;
    long m_invert;
    int m_threshold_open;
    int m_threshold_close;
    double m_price_level;
    double m_stop_level;
    double m_take_level;
    int m_expiration;
    double m_direction;
};

class CTrade : public CObject {
public:
    CTrade(void);
    ~CTrade();
    void LogLevel(const ENUM_LOG_LEVELS log_level);
    void Request(MqlTradeRequest & request) const;
    ENUM_TRADE_REQUEST_ACTIONS RequestAction(void) const;
    string RequestActionDescription(void) const;
    ulong RequestMagic(void) const;
    ulong RequestOrder(void) const;
    ulong RequestPosition(void) const;
    ulong RequestPositionBy(void) const;
    string RequestSymbol(void) const;
    double RequestVolume(void) const;
    double RequestPrice(void) const;
    double RequestStopLimit(void) const;
    double RequestSL(void) const;
    double RequestTP(void) const;
    ulong RequestDeviation(void) const;
    ENUM_ORDER_TYPE RequestType(void) const;
    string RequestTypeDescription(void) const;
    ENUM_ORDER_TYPE_FILLING RequestTypeFilling(void) const;
    string RequestTypeFillingDescription(void) const;
    ENUM_ORDER_TYPE_TIME RequestTypeTime(void) const;
    string RequestTypeTimeDescription(void) const;
    datetime RequestExpiration(void) const;
    string RequestComment(void) const;
    void Result(MqlTradeResult & result) const;
    uint ResultRetcode(void) const;
    string ResultRetcodeDescription(void) const;
    int ResultRetcodeExternal(void) const;
    ulong ResultDeal(void) const;
    ulong ResultOrder(void) const;
    double ResultVolume(void) const;
    double ResultPrice(void) const;
    double ResultBid(void) const;
    double ResultAsk(void) const;
    string ResultComment(void) const;
    void CheckResult(MqlTradeCheckResult & check_result) const;
    uint CheckResultRetcode(void) const;
    string CheckResultRetcodeDescription(void) const;
    double CheckResultBalance(void) const;
    double CheckResultEquity(void) const;
    double CheckResultProfit(void) const;
    double CheckResultMargin(void) const;
    double CheckResultMarginFree(void) const;
    double CheckResultMarginLevel(void) const;
    string CheckResultComment(void) const;
    void SetAsyncMode(const bool mode);
    void SetExpertMagicNumber(const ulong magic);
    void SetDeviationInPoints(const ulong deviation);
    void SetTypeFilling(const ENUM_ORDER_TYPE_FILLING filling);
    bool SetTypeFillingBySymbol(const string symbol);
    void SetMarginMode(void);
    bool PositionOpen(const string symbol, const ENUM_ORDER_TYPE order_type, const double volume, const double price, const double sl, const double tp, const string comment = "");
    bool PositionModify(const string symbol, const double sl, const double tp);
    bool PositionModify(const ulong ticket, const double sl, const double tp);
    bool PositionClose(const string symbol, const ulong deviation = ULONG_MAX);
    bool PositionClose(const ulong ticket, const ulong deviation = ULONG_MAX);
    bool PositionCloseBy(const ulong ticket, const ulong ticket_by);
    bool PositionClosePartial(const string symbol, const double volume, const ulong deviation = ULONG_MAX);
    bool PositionClosePartial(const ulong ticket, const double volume, const ulong deviation = ULONG_MAX);
    bool OrderOpen(const string symbol, const ENUM_ORDER_TYPE order_type, const double volume, const double limit_price, const double price, const double sl, const double tp, ENUM_ORDER_TYPE_TIME type_time = ORDER_TIME_GTC, const datetime expiration = 0, const string comment = "");
    bool OrderModify(const ulong ticket, const double price, const double sl, const double tp, const ENUM_ORDER_TYPE_TIME type_time, const datetime expiration, const double stoplimit = 0.0);
    bool OrderDelete(const ulong ticket);
    bool Buy(const double volume, const string symbol = NULL, double price = 0.0, const double sl = 0.0, const double tp = 0.0, const string comment = "");
    bool Sell(const double volume, const string symbol = NULL, double price = 0.0, const double sl = 0.0, const double tp = 0.0, const string comment = "");
    bool BuyLimit(const double volume, const double price, const string symbol = NULL, const double sl = 0.0, const double tp = 0.0, const ENUM_ORDER_TYPE_TIME type_time = ORDER_TIME_GTC, const datetime expiration = 0, const string comment = "");
    bool BuyStop(const double volume, const double price, const string symbol = NULL, const double sl = 0.0, const double tp = 0.0, const ENUM_ORDER_TYPE_TIME type_time = ORDER_TIME_GTC, const datetime expiration = 0, const string comment = "");
    bool SellLimit(const double volume, const double price, const string symbol = NULL, const double sl = 0.0, const double tp = 0.0, const ENUM_ORDER_TYPE_TIME type_time = ORDER_TIME_GTC, const datetime expiration = 0, const string comment = "");
    bool SellStop(const double volume, const double price, const string symbol = NULL, const double sl = 0.0, const double tp = 0.0, const ENUM_ORDER_TYPE_TIME type_time = ORDER_TIME_GTC, const datetime expiration = 0, const string comment = "");
    virtual double CheckVolume(const string symbol, double volume, double price, ENUM_ORDER_TYPE order_type);
    virtual bool OrderCheck(const MqlTradeRequest & request, MqlTradeCheckResult & check_result);
    virtual bool OrderSend(const MqlTradeRequest & request, MqlTradeResult & result);
    void PrintRequest(void) const;
    void PrintResult(void) const;
    string FormatPositionType(string & str, const uint type) const;
    string FormatOrderType(string & str, const uint type) const;
    string FormatOrderStatus(string & str, const uint status) const;
    string FormatOrderTypeFilling(string & str, const uint type) const;
    string FormatOrderTypeTime(string & str, const uint type) const;
    string FormatOrderPrice(string & str, const double price_order, const double price_trigger, const uint digits) const;
    string FormatRequest(string & str, const MqlTradeRequest & request) const;
    string FormatRequestResult(string & str, const MqlTradeRequest & request, const MqlTradeResult & result) const;
protected:
    MqlTradeRequest m_request;
    MqlTradeResult m_result;
    MqlTradeCheckResult m_check_result;
    bool m_async_mode;
    ulong m_magic;
    ulong m_deviation;
    ENUM_ORDER_TYPE_FILLING m_type_filling;
    ENUM_ACCOUNT_MARGIN_MODE m_margin_mode;
    ENUM_LOG_LEVELS m_log_level;
    bool FillingCheck(const string symbol);
    bool ExpirationCheck(const string symbol);
    bool OrderTypeCheck(const string symbol);
    void ClearStructures(void);
    bool IsStopped(const string function);
    bool IsHedging(void) const;
    bool SelectPosition(const string symbol);
};

class CExpertTrade : public CTrade {
public:
    CExpertTrade(void);
    ~CExpertTrade();
    bool SetSymbol(CSymbolInfo * symbol);
    bool SetOrderTypeTime(ENUM_ORDER_TYPE_TIME order_type_time);
    bool SetOrderExpiration(datetime order_expiration);
    bool Buy(double volume, double price, double sl, double tp, const string comment = "");
    bool Sell(double volume, double price, double sl, double tp, const string comment = "");
protected:
    ENUM_ORDER_TYPE_TIME m_order_type_time;
    datetime m_order_expiration;
    CAccountInfo m_account;
};

class CExpertTrailing : public CExpertBase {
public:
    CExpertTrailing(void);
    ~CExpertTrailing();
    virtual bool CheckTrailingStopLong(CPositionInfo * position, double & sl, double & tp);
    virtual bool CheckTrailingStopShort(CPositionInfo * position, double & sl, double & tp);
};

class CMoneyFixedLot : public CExpertMoney {
public:
    CMoneyFixedLot(void);
    ~CMoneyFixedLot();
    void Lots(double lots);
    virtual bool ValidationSettings(void);
    virtual double CheckOpenLong(double price, double sl);
    virtual double CheckOpenShort(double price, double sl);
protected:
    double m_lots;
};

class CMoneyFixedMargin : public CExpertMoney {
public:
    CMoneyFixedMargin(void);
    ~CMoneyFixedMargin();
    virtual double CheckOpenLong(double price, double sl);
    virtual double CheckOpenShort(double price, double sl);
};

class CMoneyFixedRisk : public CExpertMoney {
public:
    CMoneyFixedRisk(void);
    ~CMoneyFixedRisk();
    virtual double CheckOpenLong(double price, double sl);
    virtual double CheckOpenShort(double price, double sl);
    virtual double CheckClose(CPositionInfo * position);
};

class CMoneyNone : public CExpertMoney {
public:
    CMoneyNone(void);
    ~CMoneyNone();
    virtual bool ValidationSettings(void);
    virtual double CheckOpenLong(double price, double sl);
    virtual double CheckOpenShort(double price, double sl);
};

class CMoneySizeOptimized : public CExpertMoney {
public:
    CMoneySizeOptimized(void);
    ~CMoneySizeOptimized();
    void DecreaseFactor(double decrease_factor);
    virtual bool ValidationSettings(void);
    virtual double CheckOpenLong(double price, double sl);
    virtual double CheckOpenShort(double price, double sl);
protected:
    double m_decrease_factor;
    double Optimize(double lots);
};

class CSignalAC : public CExpertSignal {
public:
    CSignalAC(void);
    ~CSignalAC();
    void Pattern_0(int value);
    void Pattern_1(int value);
    void Pattern_2(int value);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiAC m_ac;
    int m_pattern_0;
    int m_pattern_1;
    int m_pattern_2;
    bool InitAC(CIndicators * indicators);
    double AC(int ind);
    double DiffAC(int ind);
};

class CSignalAMA : public CExpertSignal {
public:
    CSignalAMA(void);
    ~CSignalAMA();
    void PeriodMA(int value);
    void PeriodFast(int value);
    void PeriodSlow(int value);
    void Shift(int value);
    void Applied(ENUM_APPLIED_PRICE value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    void Pattern_2(int value);
    void Pattern_3(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiAMA m_ma;
    int m_ma_period;
    int m_period_fast;
    int m_period_slow;
    int m_ma_shift;
    ENUM_APPLIED_PRICE m_ma_applied;
    int m_pattern_0;
    int m_pattern_1;
    int m_pattern_2;
    int m_pattern_3;
    bool InitMA(CIndicators * indicators);
    double MA(int ind);
    double DiffMA(int ind);
    double DiffOpenMA(int ind);
    double DiffHighMA(int ind);
    double DiffLowMA(int ind);
    double DiffCloseMA(int ind);
};

class CSignalAO : public CExpertSignal {
public:
    CSignalAO(void);
    ~CSignalAO();
    void Pattern_0(int value);
    void Pattern_1(int value);
    void Pattern_2(int value);
    void Pattern_3(int value);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiAO m_ao;
    int m_pattern_0;
    int m_pattern_1;
    int m_pattern_2;
    int m_pattern_3;
    double m_extr_osc;
    double m_extr_pr;
    int m_extr_pos;
    uint m_extr_map;
    bool InitAO(CIndicators * indicators);
    double AO(int ind);
    double DiffAO(int ind);
    int StateAO(int ind);
    bool ExtStateAO(int ind);
};

class CSignalBearsPower : public CExpertSignal {
public:
    CSignalBearsPower(void);
    ~CSignalBearsPower();
    void PeriodBears(int value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
protected:
    CiBearsPower m_bears;
    int m_period_bears;
    int m_pattern_0;
    int m_pattern_1;
    double m_extr_osc;
    double m_extr_pr;
    int m_extr_pos;
    uint m_extr_map;
    bool InitBears(CIndicators * indicators);
    double Bears(int ind);
    double DiffBears(int ind);
    int StateBears(int ind);
    bool ExtStateBears(int ind);
};

class CSignalBullsPower : public CExpertSignal {
public:
    CSignalBullsPower(void);
    ~CSignalBullsPower();
    void PeriodBulls(int value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int ShortCondition(void);
protected:
    CiBullsPower m_bulls;
    int m_period_bulls;
    int m_pattern_0;
    int m_pattern_1;
    double m_extr_osc;
    double m_extr_pr;
    int m_extr_pos;
    uint m_extr_map;
    bool InitBears(CIndicators * indicators);
    double Bulls(int ind);
    double DiffBulls(int ind);
    int StateBulls(int ind);
    bool ExtStateBulls(int ind);
};

class CSignalCCI : public CExpertSignal {
public:
    CSignalCCI(void);
    ~CSignalCCI();
    void PeriodCCI(int value);
    void Applied(ENUM_APPLIED_PRICE value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    void Pattern_2(int value);
    void Pattern_3(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiCCI m_cci;
    int m_periodCCI;
    ENUM_APPLIED_PRICE m_applied;
    int m_pattern_0;
    int m_pattern_1;
    int m_pattern_2;
    int m_pattern_3;
    double m_extr_osc;
    double m_extr_pr;
    int m_extr_pos;
    uint m_extr_map;
    bool InitStoch(CIndicators * indicators);
    double CCI(int ind);
    double Diff(int ind);
    int State(int ind);
    bool ExtState(int ind);
    bool CompareMaps(int map, int count, bool minimax = false, int start = 0);
};

class CSignalDEMA : public CExpertSignal {
public:
    CSignalDEMA(void);
    ~CSignalDEMA();
    void PeriodMA(int value);
    void Shift(int value);
    void Applied(ENUM_APPLIED_PRICE value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    void Pattern_2(int value);
    void Pattern_3(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiDEMA m_ma;
    int m_ma_period;
    int m_ma_shift;
    ENUM_APPLIED_PRICE m_ma_applied;
    int m_pattern_0;
    int m_pattern_1;
    int m_pattern_2;
    int m_pattern_3;
    bool InitMA(CIndicators * indicators);
    double MA(int ind);
    double DiffMA(int ind);
    double DiffOpenMA(int ind);
    double DiffHighMA(int ind);
    double DiffLowMA(int ind);
    double DiffCloseMA(int ind);
};

class CSignalDeM : public CExpertSignal {
public:
    CSignalDeM(void);
    ~CSignalDeM();
    void PeriodDeM(int value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    void Pattern_2(int value);
    void Pattern_3(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiDeMarker m_dem;
    int m_periodDeM;
    int m_pattern_0;
    int m_pattern_1;
    int m_pattern_2;
    int m_pattern_3;
    double m_extr_osc;
    double m_extr_pr;
    int m_extr_pos;
    uint m_extr_map;
    bool InitStoch(CIndicators * indicators);
    double DeM(int ind);
    double DiffDeM(int ind);
    int StateDeM(int ind);
    bool ExtStateDeM(int ind);
    bool CompareMaps(int map, int count, bool minimax = false, int start = 0);
};

class CSignalEnvelopes : public CExpertSignal {
public:
    CSignalEnvelopes(void);
    ~CSignalEnvelopes();
    void PeriodMA(int value);
    void Shift(int value);
    void Method(ENUM_MA_METHOD value);
    void Applied(ENUM_APPLIED_PRICE value);
    void Deviation(double value);
    void LimitIn(double value);
    void LimitOut(double value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiEnvelopes m_env;
    int m_ma_period;
    int m_ma_shift;
    ENUM_MA_METHOD m_ma_method;
    ENUM_APPLIED_PRICE m_ma_applied;
    double m_deviation;
    double m_limit_in;
    double m_limit_out;
    int m_pattern_0;
    int m_pattern_1;
    bool InitMA(CIndicators * indicators);
    double Upper(int ind);
    double Lower(int ind);
};

class CSignalFrAMA : public CExpertSignal {
public:
    CSignalFrAMA(void);
    ~CSignalFrAMA();
    void PeriodMA(int value);
    void Shift(int value);
    void Applied(ENUM_APPLIED_PRICE value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    void Pattern_2(int value);
    void Pattern_3(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiFrAMA m_ma;
    int m_ma_period;
    int m_ma_shift;
    ENUM_APPLIED_PRICE m_ma_applied;
    int m_pattern_0;
    int m_pattern_1;
    int m_pattern_2;
    int m_pattern_3;
    bool InitMA(CIndicators * indicators);
    double MA(int ind);
    double DiffMA(int ind);
    double DiffOpenMA(int ind);
    double DiffHighMA(int ind);
    double DiffLowMA(int ind);
    double DiffCloseMA(int ind);
};

class CSignalITF : public CExpertSignal {
public:
    CSignalITF(void);
    ~CSignalITF();
    void GoodMinuteOfHour(int value);
    void BadMinutesOfHour(long value);
    void GoodHourOfDay(int value);
    void BadHoursOfDay(int value);
    void GoodDayOfWeek(int value);
    void BadDaysOfWeek(int value);
    virtual double Direction(void);
protected:
    int m_good_minute_of_hour;
    long m_bad_minutes_of_hour;
    int m_good_hour_of_day;
    int m_bad_hours_of_day;
    int m_good_day_of_week;
    int m_bad_days_of_week;
};

class CSignalMA : public CExpertSignal {
public:
    CSignalMA(void);
    ~CSignalMA();
    void PeriodMA(int value);
    void Shift(int value);
    void Method(ENUM_MA_METHOD value);
    void Applied(ENUM_APPLIED_PRICE value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    void Pattern_2(int value);
    void Pattern_3(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiMA m_ma;
    int m_ma_period;
    int m_ma_shift;
    ENUM_MA_METHOD m_ma_method;
    ENUM_APPLIED_PRICE m_ma_applied;
    int m_pattern_0;
    int m_pattern_1;
    int m_pattern_2;
    int m_pattern_3;
    bool InitMA(CIndicators * indicators);
    double MA(int ind);
    double DiffMA(int ind);
    double DiffOpenMA(int ind);
    double DiffHighMA(int ind);
    double DiffLowMA(int ind);
    double DiffCloseMA(int ind);
};

class CSignalMACD : public CExpertSignal {
public:
    CSignalMACD(void);
    ~CSignalMACD();
    void PeriodFast(int value);
    void PeriodSlow(int value);
    void PeriodSignal(int value);
    void Applied(ENUM_APPLIED_PRICE value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    void Pattern_2(int value);
    void Pattern_3(int value);
    void Pattern_4(int value);
    void Pattern_5(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiMACD m_MACD;
    int m_period_fast;
    int m_period_slow;
    int m_period_signal;
    ENUM_APPLIED_PRICE m_applied;
    int m_pattern_0;
    int m_pattern_1;
    int m_pattern_2;
    int m_pattern_3;
    int m_pattern_4;
    int m_pattern_5;
    double m_extr_osc;
    double m_extr_pr;
    int m_extr_pos;
    uint m_extr_map;
    bool InitMACD(CIndicators * indicators);
    double Main(int ind);
    double Signal(int ind);
    double DiffMain(int ind);
    int StateMain(int ind);
    double State(int ind);
    bool ExtState(int ind);
    bool CompareMaps(int map, int count, bool minimax = false, int start = 0);
};

class CSignalRSI : public CExpertSignal {
public:
    CSignalRSI(void);
    ~CSignalRSI();
    void PeriodRSI(int value);
    void Applied(ENUM_APPLIED_PRICE value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    void Pattern_2(int value);
    void Pattern_3(int value);
    void Pattern_4(int value);
    void Pattern_5(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiRSI m_rsi;
    int m_periodRSI;
    ENUM_APPLIED_PRICE m_applied;
    int m_pattern_0;
    int m_pattern_1;
    int m_pattern_2;
    int m_pattern_3;
    int m_pattern_4;
    int m_pattern_5;
    double m_extr_osc;
    double m_extr_pr;
    int m_extr_pos;
    uint m_extr_map;
    bool InitRSI(CIndicators * indicators);
    double RSI(int ind);
    double DiffRSI(int ind);
    int StateRSI(int ind);
    bool ExtStateRSI(int ind);
    bool CompareMaps(int map, int count, bool minimax = false, int start = 0);
};

class CSignalRVI : public CExpertSignal {
public:
    CSignalRVI(void);
    ~CSignalRVI();
    void PeriodRVI(int value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiRVI m_rvi;
    int m_periodRVI;
    int m_pattern_0;
    int m_pattern_1;
    bool InitRVI(CIndicators * indicators);
    double Main(int ind);
    double DiffMain(int ind);
    double Signal(int ind);
    double DiffSignal(int ind);
    double DiffMainSignal(int ind);
};

class CSignalSAR : public CExpertSignal {
public:
    CSignalSAR(void);
    ~CSignalSAR();
    void Step(double value);
    void Maximum(double value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiSAR m_sar;
    double m_step;
    double m_maximum;
    int m_pattern_0;
    int m_pattern_1;
    bool InitSAR(CIndicators * indicators);
    double SAR(int ind);
    double Close(int ind);
    double DiffClose(int ind);
};

class CSignalStoch : public CExpertSignal {
public:
    CSignalStoch(void);
    ~CSignalStoch();
    void PeriodK(int value);
    void PeriodD(int value);
    void PeriodSlow(int value);
    void Applied(ENUM_STO_PRICE value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    void Pattern_2(int value);
    void Pattern_3(int value);
    void Pattern_4(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiStochastic m_stoch;
    int m_periodK;
    int m_periodD;
    int m_period_slow;
    ENUM_STO_PRICE m_applied;
    int m_pattern_0;
    int m_pattern_1;
    int m_pattern_2;
    int m_pattern_3;
    int m_pattern_4;
    double m_extr_osc;
    double m_extr_pr;
    int m_extr_pos;
    uint m_extr_map;
    bool InitStoch(CIndicators * indicators);
    double Main(int ind);
    double DiffMain(int ind);
    double Signal(int ind);
    double DiffSignal(int ind);
    double DiffMainSignal(int ind);
    int StateStoch(int ind);
    bool ExtStateStoch(int ind);
    bool CompareMaps(int map, int count, bool minimax = false, int start = 0);
    void DiverDebugPrint();
};

class CSignalTEMA : public CExpertSignal {
public:
    CSignalTEMA(void);
    ~CSignalTEMA();
    void PeriodMA(int value);
    void Shift(int value);
    void Applied(ENUM_APPLIED_PRICE value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    void Pattern_2(int value);
    void Pattern_3(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiTEMA m_ma;
    int m_ma_period;
    int m_ma_shift;
    ENUM_APPLIED_PRICE m_ma_applied;
    int m_pattern_0;
    int m_pattern_1;
    int m_pattern_2;
    int m_pattern_3;
    bool InitMA(CIndicators * indicators);
    double MA(int ind);
    double DiffMA(int ind);
    double DiffOpenMA(int ind);
    double DiffHighMA(int ind);
    double DiffLowMA(int ind);
    double DiffCloseMA(int ind);
};

class CSignalTriX : public CExpertSignal {
public:
    CSignalTriX(void);
    ~CSignalTriX();
    void PeriodTriX(int value);
    void Applied(ENUM_APPLIED_PRICE value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    void Pattern_2(int value);
    void Pattern_3(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiTriX m_trix;
    int m_period_trix;
    ENUM_APPLIED_PRICE m_applied;
    int m_pattern_0;
    int m_pattern_1;
    int m_pattern_2;
    int m_pattern_3;
    double m_extr_osc;
    double m_extr_pr;
    int m_extr_pos;
    uint m_extr_map;
    bool InitTriX(CIndicators * indicators);
    double TriX(int ind);
    double DiffTriX(int ind);
    int State(int ind);
    bool ExtState(int ind);
    bool CompareMaps(int map, int count, bool minimax = false, int start = 0);
};

class CSignalWPR : public CExpertSignal {
public:
    CSignalWPR(void);
    ~CSignalWPR();
    void PeriodWPR(int value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    void Pattern_2(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiWPR m_wpr;
    int m_period_wpr;
    int m_pattern_0;
    int m_pattern_1;
    int m_pattern_2;
    double m_extr_osc;
    double m_extr_pr;
    int m_extr_pos;
    uint m_extr_map;
    bool InitWPR(CIndicators * indicators);
    double WPR(int ind);
    double Diff(int ind);
    int State(int ind);
    bool ExtState(int ind);
    bool CompareMaps(int map, int count, bool minimax = false, int start = 0);
};

class CTrailingFixedPips : public CExpertTrailing {
public:
    CTrailingFixedPips(void);
    ~CTrailingFixedPips();
    void StopLevel(int stop_level);
    void ProfitLevel(int profit_level);
    virtual bool ValidationSettings(void);
    virtual bool CheckTrailingStopLong(CPositionInfo * position, double & sl, double & tp);
    virtual bool CheckTrailingStopShort(CPositionInfo * position, double & sl, double & tp);
protected:
    int m_stop_level;
    int m_profit_level;
};

class CTrailingMA : public CExpertTrailing {
public:
    CTrailingMA(void);
    ~CTrailingMA();
    void Period(int period);
    void Shift(int shift);
    void Method(ENUM_MA_METHOD method);
    void Applied(ENUM_APPLIED_PRICE applied);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual bool ValidationSettings(void);
    virtual bool CheckTrailingStopLong(CPositionInfo * position, double & sl, double & tp);
    virtual bool CheckTrailingStopShort(CPositionInfo * position, double & sl, double & tp);
protected:
    int m_ma_period;
    int m_ma_shift;
    ENUM_MA_METHOD m_ma_method;
    ENUM_APPLIED_PRICE m_ma_applied;
};

class CTrailingNone : public CExpertTrailing {
public:
    CTrailingNone(void);
    ~CTrailingNone();
};

class CTrailingPSAR : public CExpertTrailing {
public:
    CTrailingPSAR(void);
    ~CTrailingPSAR();
    void Step(double step);
    void Maximum(double maximum);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual bool CheckTrailingStopLong(CPositionInfo * position, double & sl, double & tp);
    virtual bool CheckTrailingStopShort(CPositionInfo * position, double & sl, double & tp);
protected:
    CiSAR m_sar;
    double m_step;
    double m_maximum;
};

class CFile : public CObject {
public:
    CFile(void);
    ~CFile();
    int Handle(void) const;
    string FileName(void) const;
    int Flags(void) const;
    void SetUnicode(const bool unicode);
    void SetCommon(const bool common);
    int Open(const string file_name, int open_flags, const short delimiter = '\t');
    void Close(void);
    void Delete(void);
    ulong Size(void);
    ulong Tell(void);
    void Seek(const long offset, const ENUM_FILE_POSITION origin);
    void Flush(void);
    bool IsEnding(void);
    bool IsLineEnding(void);
    void Delete(const string file_name, const int common_flag = 0);
    bool IsExist(const string file_name, const int common_flag = 0);
    bool Copy(const string src_name, const int common_flag, const string dst_name, const int mode_flags);
    bool Move(const string src_name, const int common_flag, const string dst_name, const int mode_flags);
    bool FolderCreate(const string folder_name);
    bool FolderDelete(const string folder_name);
    bool FolderClean(const string folder_name);
    long FileFindFirst(const string file_filter, string & returned_filename);
    bool FileFindNext(const long search_handle, string & returned_filename);
    void FileFindClose(const long search_handle);
protected:
    int m_handle;
    string m_name;
    int m_flags;
};

class CFileBin : public CFile {
public:
    CFileBin(void);
    ~CFileBin();
    int Open(const string file_name, const int open_flags);
    uint WriteChar(const char value);
    uint WriteShort(const short value);
    uint WriteInteger(const int value);
    uint WriteLong(const long value);
    uint WriteFloat(const float value);
    uint WriteDouble(const double value);
    uint WriteString(const string value);
    uint WriteString(const string value, const int size);
    uint WriteCharArray(const char & array, const int start_item = 0, const int items_count = WHOLE_ARRAY);
    uint WriteShortArray(const short& array, const int start_item = 0, const int items_count = WHOLE_ARRAY);
    uint WriteIntegerArray(const int& array, const int start_item = 0, const int items_count = WHOLE_ARRAY);
    uint WriteLongArray(const long & array, const int start_item = 0, const int items_count = WHOLE_ARRAY);
    uint WriteFloatArray(const float & array, const int start_item = 0, const int items_count = WHOLE_ARRAY);
    uint WriteDoubleArray(const double & array, const int start_item = 0, const int items_count = WHOLE_ARRAY);
    bool WriteObject(CObject * object);
    bool ReadChar(char & value);
    bool ReadShort(short & value);
    bool ReadInteger(int & value);
    bool ReadLong(long & value);
    bool ReadFloat(float & value);
    bool ReadDouble(double & value);
    bool ReadString(string & value);
    bool ReadString(string & value, const int size);
    uint ReadCharArray(char & array, const int start_item = 0, const int items_count = WHOLE_ARRAY);
    uint ReadShortArray(short& array, const int start_item = 0, const int items_count = WHOLE_ARRAY);
    uint ReadIntegerArray(int& array, const int start_item = 0, const int items_count = WHOLE_ARRAY);
    uint ReadLongArray(long & array, const int start_item = 0, const int items_count = WHOLE_ARRAY);
    uint ReadFloatArray(float & array, const int start_item = 0, const int items_count = WHOLE_ARRAY);
    uint ReadDoubleArray(double & array, const int start_item = 0, const int items_count = WHOLE_ARRAY);
    bool ReadObject(CObject * object);
};

struct BITMAPFILEHEADER {
public:
    ushort bfType;
    uint bfSize;
    ushort bfReserved1;
    ushort bfReserved2;
    uint bfOffBits;
};

struct BITMAPINFOHEADER {
public:
    uint biSize;
    int biWidth;
    int biHeight;
    ushort biPlanes;
    ushort biBitCount;
    uint biCompression;
    uint biSizeImage;
    int biXPelsPerMeter;
    int biYPelsPerMeter;
    uint biClrUsed;
    uint biClrImportant;
};

class CFileBMP : public CObject {
public:
    CFileBMP(void);
    ~CFileBMP();
    int OpenWrite(const string file_name, bool common_flag = false);
    int OpenRead(const string file_name, bool common_flag = false);
    int Write32BitsArray(uint& uint_array, const int width, const int height);
    int Read32BitsArray(uint& uint_array, int& width, int& height);
    void Close(void);
protected:
    int m_handle;
    BITMAPFILEHEADER m_file_header;
    BITMAPINFOHEADER m_info_header;
};

class CFilePipe : public CFile {
public:
    CFilePipe(void);
    ~CFilePipe();
    int Open(const string file_name, const int open_flags);
    bool WaitForRead(const ulong size);
    uint WriteLong(const long value);
    uint WriteFloat(const float value);
    uint WriteDouble(const double value);
    uint WriteString(const string value);
    uint WriteString(const string value, const int size);
    bool WriteObject(CObject * object);
    bool ReadLong(long & value);
    bool ReadFloat(float & value);
    bool ReadDouble(double & value);
    bool ReadString(string & value);
    bool ReadString(string & value, const int size);
    bool ReadObject(CObject * object);
};

class CFileTxt : public CFile {
public:
    CFileTxt(void);
    ~CFileTxt();
    int Open(const string file_name, const int open_flags);
    uint WriteString(const string value);
    string ReadString(void);
};

template<typename T>
struct Slot {
public:
    int hash_code;
    T value;
    int next;
    Slot(void);
};

struct Introsort {
public:
    TKey keys;
    TItem items;
    Introsort(void);
    ~Introsort();
    void Sort(const int index, const int length);
};

class CPrimeGenerator {
public:
    static bool IsPrime(const int candidate);
    static int GetPrime(const int min);
    static int ExpandPrime(const int old_size);
};

template<typename T>
class CLinkedListNode {
public:
    CLinkedListNode(T value);
    CLinkedListNode(CLinkedList<T>* list, T value);
    ~CLinkedListNode();
    void List(CLinkedList<T>* value);
    void Next(CLinkedListNode<T>* value);
    void Previous(CLinkedListNode<T>* value);
    T Value(void);
    void Value(T value);
protected:
    T m_item;
};

class CAxis {
public:
    CAxis(void);
    ~CAxis();
    double Step(void) const;
    double Min(void) const;
    void Min(const double min);
    double Max(void) const;
    void Max(const double max);
    string Name(void) const;
    void Name(const string name);
    ENUM_AXIS_TYPE Type(void) const;
    void Type(ENUM_AXIS_TYPE type);
    uint Color(void) const;
    void Color(const uint clr);
    bool AutoScale(void) const;
    void AutoScale(const bool auto);
    int ValuesSize(void) const;
    void ValuesSize(const int size);
    int ValuesWidth(void) const;
    void ValuesWidth(const int width);
    string ValuesFormat(void) const;
    void ValuesFormat(const string format);
    int ValuesDateTimeMode(void) const;
    void ValuesDateTimeMode(const int mode);
    DoubleToStringFunction ValuesFunctionFormat(void) const;
    void ValuesFunctionFormat(DoubleToStringFunction func);
    void ValuesFunctionFormatCBData(void * cbdata);
    string ValuesFontName(void) const;
    void ValuesFontName(const string fontname);
    uint ValuesFontAngle(void) const;
    void ValuesFontAngle(const uint fontangle);
    uint ValuesFontFlags(void) const;
    void ValuesFontFlags(const uint fontflags);
    int NameSize(void) const;
    void NameSize(const int size);
    double ZeroLever(void) const;
    void ZeroLever(const double value);
    double DefaultStep(void) const;
    void DefaultStep(const double value);
    double MaxLabels(void) const;
    void MaxLabels(const double value);
    double MinGrace(void) const;
    void MinGrace(const double value);
    double MaxGrace(void) const;
    void MaxGrace(const double value);
    void SelectAxisScale(void);
};

class CColorGenerator {
public:
    CColorGenerator(void);
    ~CColorGenerator();
    uint Next(void);
    void Reset(void);
};

struct CPoint2D {
public:
    double x;
    double y;
};

class CCurve : public CObject {
public:
    CCurve(const double & y, const uint clr, ENUM_CURVE_TYPE type, const string name);
    CCurve(const double & x, const double & y, const uint clr, ENUM_CURVE_TYPE type, const string name);
    CCurve(const CPoint2D & points, const uint clr, ENUM_CURVE_TYPE type, const string name);
    CCurve(CurveFunction function, const double from, const double to, const double step, const uint clr, ENUM_CURVE_TYPE type, const string name);
    ~CCurve();
    void GetX(double & x) const;
    void GetY(double & y) const;
    double XMax(void) const;
    double XMin(void) const;
    double YMax(void) const;
    double YMin(void) const;
    int Size(void) const;
    void Update(const double & y);
    void Update(const double & x, const double & y);
    void Update(const CPoint2D & points);
    void Update(CurveFunction function, const double from, const double to, const double step);
    uint Color(void) const;
    int Type(void) const;
    string Name(void) const;
    bool Visible(void) const;
    void Color(const uint clr);
    void Type(const int type);
    void Name(const string name);
    void Visible(const bool visible);
    ENUM_LINE_STYLE LinesStyle(void) const;
    ENUM_LINE_END LinesEndStyle(void) const;
    int LinesWidth(void) const;
    bool LinesSmooth(void) const;
    double LinesSmoothTension(void) const;
    double LinesSmoothStep(void) const;
    void LinesStyle(ENUM_LINE_STYLE style);
    void LinesEndStyle(ENUM_LINE_END end_style);
    void LinesWidth(const int width);
    void LinesSmooth(const bool smooth);
    void LinesSmoothTension(const double tension);
    void LinesSmoothStep(const double step);
    int PointsSize(void) const;
    ENUM_POINT_TYPE PointsType(void) const;
    bool PointsFill(void) const;
    uint PointsColor(void) const;
    void PointsSize(const int size);
    void PointsType(ENUM_POINT_TYPE type);
    void PointsFill(const bool fill);
    void PointsColor(const uint clr);
    int StepsDimension(void) const;
    void StepsDimension(const int dimension);
    int HistogramWidth(void) const;
    void HistogramWidth(const int width);
    PlotFucntion CustomPlotFunction(void) const;
    void CustomPlotFunction(PlotFucntion func);
    void CustomPlotCBData(void * cbdata);
    bool TrendLineVisible(void) const;
    uint TrendLineColor(void) const;
    void TrendLineVisible(const bool visible);
    void TrendLineColor(const uint clr);
    void TrendLineCoefficients(double & coefficients);
protected:
    bool m_trend_calc;
    double m_trend_coeff;
    virtual void CalculateCoefficients(void);
};

class CSeries : public CArrayObj {
public:
    CSeries(void);
    ~CSeries();
    string Name(void) const;
    int BuffersTotal(void) const;
    int BufferSize(void) const;
    int Timeframe(void) const;
    string Symbol(void) const;
    ENUM_TIMEFRAMES Period(void) const;
    string PeriodDescription(const int val = 0);
    void RefreshCurrent(const bool flag);
    virtual bool BufferResize(const int size);
    virtual void Refresh(const int flags);
protected:
    string m_name;
    int m_buffers_total;
    int m_buffer_size;
    int m_timeframe_flags;
    string m_symbol;
    ENUM_TIMEFRAMES m_period;
    bool m_refresh_current;
    datetime m_first_date;
    bool SetSymbolPeriod(const string symbol, const ENUM_TIMEFRAMES period);
    void PeriodToTimeframeFlag(const ENUM_TIMEFRAMES period);
    bool CheckLoadHistory(const int size);
    bool CheckTerminalHistory(const int size);
    bool CheckServerHistory(const int size);
};

class CIndicator : public CSeries {
public:
    CIndicator(void);
    ~CIndicator();
    int Handle(void) const;
    string Status(void) const;
    void FullRelease(const bool flag = true);
    void Redrawer(const bool flag = true);
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const ENUM_INDICATOR type, const int num_params, const MqlParam & params);
    virtual bool BufferResize(const int size);
    int BarsCalculated(void) const;
    double GetData(const int buffer_num, const int index) const;
    int GetData(const int start_pos, const int count, const int buffer_num, double & buffer) const;
    int GetData(const datetime start_time, const int count, const int buffer_num, double & buffer) const;
    int GetData(const datetime start_time, const datetime stop_time, const int buffer_num, double & buffer) const;
    int Minimum(const int buffer_num, const int start, const int count) const;
    double MinValue(const int buffer_num, const int start, const int count, int & index) const;
    int Maximum(const int buffer_num, const int start, const int count) const;
    double MaxValue(const int buffer_num, const int start, const int count, int & index) const;
    virtual void Refresh(const int flags = OBJ_ALL_PERIODS);
    bool AddToChart(const long chart, const int subwin);
    bool DeleteFromChart(const long chart, const int subwin);
    static string MethodDescription(const int val);
    static string PriceDescription(const int val);
    static string VolumeDescription(const int val);
protected:
    int m_handle;
    string m_status;
    bool m_full_release;
    bool m_redrawer;
    bool CreateBuffers(const string symbol, const ENUM_TIMEFRAMES period, const int buffers);
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
};

class CiAC : public CIndicator {
public:
    CiAC(void);
    ~CiAC();
    bool Create(const string symbol, const ENUM_TIMEFRAMES period);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period);
};

class CiAlligator : public CIndicator {
public:
    CiAlligator(void);
    ~CiAlligator();
    int JawPeriod(void) const;
    int JawShift(void) const;
    int TeethPeriod(void) const;
    int TeethShift(void) const;
    int LipsPeriod(void) const;
    int LipsShift(void) const;
    ENUM_MA_METHOD MaMethod(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int jaw_period, const int jaw_shift, const int teeth_period, const int teeth_shift, const int lips_period, const int lips_shift, const ENUM_MA_METHOD ma_method, const int applied);
    double Jaw(const int index) const;
    double Teeth(const int index) const;
    double Lips(const int index) const;
    virtual int Type(void) const;
protected:
    int m_jaw_period;
    int m_jaw_shift;
    int m_teeth_period;
    int m_teeth_shift;
    int m_lips_period;
    int m_lips_shift;
    ENUM_MA_METHOD m_ma_method;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int jaw_period, const int jaw_shift, const int teeth_period, const int teeth_shift, const int lips_period, const int lips_shift, const ENUM_MA_METHOD ma_method, const int applied);
};

class CiAO : public CIndicator {
public:
    CiAO(void);
    ~CiAO();
    bool Create(const string symbol, const ENUM_TIMEFRAMES period);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period);
};

class CiFractals : public CIndicator {
public:
    CiFractals(void);
    ~CiFractals();
    bool Create(const string symbol, const ENUM_TIMEFRAMES period);
    double Upper(const int index) const;
    double Lower(const int index) const;
    virtual int Type(void) const;
protected:
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period);
};

class CiGator : public CIndicator {
public:
    CiGator(void);
    ~CiGator();
    int JawPeriod(void) const;
    int JawShift(void) const;
    int TeethPeriod(void) const;
    int TeethShift(void) const;
    int LipsPeriod(void) const;
    int LipsShift(void) const;
    ENUM_MA_METHOD MaMethod(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int jaw_period, const int jaw_shift, const int teeth_period, const int teeth_shift, const int lips_period, const int lips_shift, const ENUM_MA_METHOD ma_method, const int applied);
    double Upper(const int index) const;
    double Lower(const int index) const;
    virtual int Type(void) const;
protected:
    int m_jaw_period;
    int m_jaw_shift;
    int m_teeth_period;
    int m_teeth_shift;
    int m_lips_period;
    int m_lips_shift;
    ENUM_MA_METHOD m_ma_method;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int jaw_period, const int jaw_shift, const int teeth_period, const int teeth_shift, const int lips_period, const int lips_shift, const ENUM_MA_METHOD ma_method, const int applied);
};

class CiBWMFI : public CIndicator {
public:
    CiBWMFI(void);
    ~CiBWMFI();
    ENUM_APPLIED_VOLUME Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const ENUM_APPLIED_VOLUME applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    ENUM_APPLIED_VOLUME m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const ENUM_APPLIED_VOLUME applied);
};

class CiCustom : public CIndicator {
public:
    CiCustom(void);
    ~CiCustom();
    bool NumBuffers(const int buffers);
    int NumParams(void) const;
    ENUM_DATATYPE ParamType(const int ind) const;
    long ParamLong(const int ind) const;
    double ParamDouble(const int ind) const;
    string ParamString(const int ind) const;
    virtual int Type(void) const;
protected:
    int m_num_params;
    MqlParam m_params;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
};

class CDoubleBuffer : public CArrayDouble {
public:
    CDoubleBuffer(void);
    ~CDoubleBuffer();
    void Size(const int size);
    double At(const int index) const;
    virtual bool Refresh(void);
    virtual bool RefreshCurrent(void);
    void SetSymbolPeriod(const string symbol, const ENUM_TIMEFRAMES period);
protected:
    string m_symbol;
    ENUM_TIMEFRAMES m_period;
    int m_size;
};

class CIndicatorBuffer : public CDoubleBuffer {
public:
    CIndicatorBuffer(void);
    ~CIndicatorBuffer();
    int Offset(void) const;
    void Offset(const int offset);
    string Name(void) const;
    void Name(const string name);
    double At(const int index) const;
    bool Refresh(const int handle, const int num);
    bool RefreshCurrent(const int handle, const int num);
protected:
    int m_offset;
    string m_name;
};

class CIndicators : public CArrayObj {
public:
    CIndicators(void);
    ~CIndicators();
    bool BufferResize(const int size);
    int Refresh(void);
protected:
    MqlDateTime m_prev_time;
    int TimeframesFlags(const MqlDateTime & time);
};

class CiATR : public CIndicator {
public:
    CiATR(void);
    ~CiATR();
    int MaPeriod(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period);
};

class CiBearsPower : public CIndicator {
public:
    CiBearsPower(void);
    ~CiBearsPower();
    int MaPeriod(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period);
};

class CiBullsPower : public CIndicator {
public:
    CiBullsPower(void);
    ~CiBullsPower();
    int MaPeriod(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period);
};

class CiCCI : public CIndicator {
public:
    CiCCI(void);
    ~CiCCI();
    int MaPeriod(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int applied);
};

class CiChaikin : public CIndicator {
public:
    CiChaikin(void);
    ~CiChaikin();
    int FastMaPeriod(void) const;
    int SlowMaPeriod(void) const;
    ENUM_MA_METHOD MaMethod(void) const;
    ENUM_APPLIED_VOLUME Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int fast_ma_period, const int slow_ma_period, const ENUM_MA_METHOD ma_method, const ENUM_APPLIED_VOLUME applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_fast_ma_period;
    int m_slow_ma_period;
    ENUM_MA_METHOD m_ma_method;
    ENUM_APPLIED_VOLUME m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int fast_ma_period, const int slow_ma_period, const ENUM_MA_METHOD ma_method, const ENUM_APPLIED_VOLUME applied);
};

class CiDeMarker : public CIndicator {
public:
    CiDeMarker(void);
    ~CiDeMarker();
    int MaPeriod(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period);
};

class CiForce : public CIndicator {
public:
    CiForce(void);
    ~CiForce();
    int MaPeriod(void) const;
    ENUM_MA_METHOD MaMethod(void) const;
    ENUM_APPLIED_VOLUME Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const ENUM_MA_METHOD ma_method, const ENUM_APPLIED_VOLUME applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    ENUM_MA_METHOD m_ma_method;
    ENUM_APPLIED_VOLUME m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const ENUM_MA_METHOD ma_method, const ENUM_APPLIED_VOLUME applied);
};

class CiMACD : public CIndicator {
public:
    CiMACD(void);
    ~CiMACD();
    int FastEmaPeriod(void) const;
    int SlowEmaPeriod(void) const;
    int SignalPeriod(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int fast_ema_period, const int slow_ema_period, const int signal_period, const int applied);
    double Main(const int index) const;
    double Signal(const int index) const;
    virtual int Type(void) const;
protected:
    int m_fast_ema_period;
    int m_slow_ema_period;
    int m_signal_period;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int fast_ema_period, const int slow_ema_period, const int signal_period, const int applied);
};

class CiMomentum : public CIndicator {
public:
    CiMomentum(void);
    ~CiMomentum();
    int MaPeriod(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int applied);
};

class CiOsMA : public CIndicator {
public:
    CiOsMA(void);
    ~CiOsMA();
    int FastEmaPeriod(void) const;
    int SlowEmaPeriod(void) const;
    int SignalPeriod(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int fast_ema_period, const int slow_ema_period, const int signal_period, const int applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_fast_ema_period;
    int m_slow_ema_period;
    int m_signal_period;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int fast_ema_period, const int slow_ema_period, const int signal_period, const int applied);
};

class CiRSI : public CIndicator {
public:
    CiRSI(void);
    ~CiRSI();
    int MaPeriod(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int applied);
};

class CiRVI : public CIndicator {
public:
    CiRVI(void);
    ~CiRVI();
    int MaPeriod(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period);
    double Main(const int index) const;
    double Signal(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period);
};

class CiStochastic : public CIndicator {
public:
    CiStochastic(void);
    ~CiStochastic();
    int Kperiod(void) const;
    int Dperiod(void) const;
    int Slowing(void) const;
    ENUM_MA_METHOD MaMethod(void) const;
    ENUM_STO_PRICE PriceField(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int Kperiod, const int Dperiod, const int slowing, const ENUM_MA_METHOD ma_method, const ENUM_STO_PRICE price_field);
    double Main(const int index) const;
    double Signal(const int index) const;
    virtual int Type(void) const;
protected:
    int m_Kperiod;
    int m_Dperiod;
    int m_slowing;
    ENUM_MA_METHOD m_ma_method;
    ENUM_STO_PRICE m_price_field;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int Kperiod, const int Dperiod, const int slowing, const ENUM_MA_METHOD ma_method, const ENUM_STO_PRICE price_field);
};

class CiWPR : public CIndicator {
public:
    CiWPR(void);
    ~CiWPR();
    int CalcPeriod(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int calc_period);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_calc_period;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int calc_period);
};

class CiTriX : public CIndicator {
public:
    CiTriX(void);
    ~CiTriX();
    int MaPeriod(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int applied);
};

class CPriceSeries : public CSeries {
public:
    CPriceSeries(void);
    ~CPriceSeries();
    virtual bool BufferResize(const int size);
    virtual int MinIndex(const int start, const int count) const;
    virtual double MinValue(const int start, const int count, int & index) const;
    virtual int MaxIndex(const int start, const int count) const;
    virtual double MaxValue(const int start, const int count, int & index) const;
    double GetData(const int index) const;
    virtual void Refresh(const int flags = OBJ_ALL_PERIODS);
};

class COpenBuffer : public CDoubleBuffer {
public:
    COpenBuffer(void);
    ~COpenBuffer();
    virtual bool Refresh(void);
    virtual bool RefreshCurrent(void);
};

class CiOpen : public CPriceSeries {
public:
    CiOpen(void);
    ~CiOpen();
    bool Create(const string symbol, const ENUM_TIMEFRAMES period);
    double GetData(const int index) const;
    int GetData(const int start_pos, const int count, double & buffer) const;
    int GetData(const datetime start_time, const int count, double & buffer) const;
    int GetData(const datetime start_time, const datetime stop_time, double & buffer) const;
};

class CHighBuffer : public CDoubleBuffer {
public:
    CHighBuffer(void);
    ~CHighBuffer();
    virtual bool Refresh(void);
    virtual bool RefreshCurrent(void);
};

class CiHigh : public CPriceSeries {
public:
    CiHigh(void);
    ~CiHigh();
    bool Create(const string symbol, const ENUM_TIMEFRAMES period);
    double GetData(const int index) const;
    int GetData(const int start_pos, const int count, double & buffer) const;
    int GetData(const datetime start_time, const int count, double & buffer) const;
    int GetData(const datetime start_time, const datetime stop_time, double & buffer) const;
};

class CLowBuffer : public CDoubleBuffer {
public:
    CLowBuffer(void);
    ~CLowBuffer();
    virtual bool Refresh(void);
    virtual bool RefreshCurrent(void);
};

class CiLow : public CPriceSeries {
public:
    CiLow(void);
    ~CiLow();
    bool Create(const string symbol, const ENUM_TIMEFRAMES period);
    double GetData(const int index) const;
    int GetData(const int start_pos, const int count, double & buffer) const;
    int GetData(const datetime start_time, const int count, double & buffer) const;
    int GetData(const datetime start_time, const datetime stop_time, double & buffer) const;
};

class CCloseBuffer : public CDoubleBuffer {
public:
    CCloseBuffer(void);
    ~CCloseBuffer();
    virtual bool Refresh(void);
    virtual bool RefreshCurrent(void);
};

class CiClose : public CPriceSeries {
public:
    CiClose(void);
    ~CiClose();
    bool Create(const string symbol, const ENUM_TIMEFRAMES period);
    double GetData(const int index) const;
    int GetData(const int start_pos, const int count, double & buffer) const;
    int GetData(const datetime start_time, const int count, double & buffer) const;
    int GetData(const datetime start_time, const datetime stop_time, double & buffer) const;
};

class CSpreadBuffer : public CArrayInt {
public:
    CSpreadBuffer(void);
    ~CSpreadBuffer();
    void Size(const int size);
    int At(const int index) const;
    virtual bool Refresh(void);
    virtual bool RefreshCurrent(void);
    void SetSymbolPeriod(const string symbol, const ENUM_TIMEFRAMES period);
protected:
    string m_symbol;
    ENUM_TIMEFRAMES m_period;
    int m_freshed_data;
    int m_size;
};

class CiSpread : public CSeries {
public:
    CiSpread(void);
    ~CiSpread();
    bool Create(const string symbol, const ENUM_TIMEFRAMES period);
    virtual bool BufferResize(const int size);
    int GetData(const int index) const;
    int GetData(const int start_pos, const int count, int & buffer) const;
    int GetData(const datetime start_time, const int count, int & buffer) const;
    int GetData(const datetime start_time, const datetime stop_time, int & buffer) const;
    virtual void Refresh(const int flags = OBJ_ALL_PERIODS);
};

class CTimeBuffer : public CArrayDatetime {
public:
    CTimeBuffer(void);
    ~CTimeBuffer();
    void Size(const int size);
    datetime At(const int index) const;
    virtual bool Refresh(void);
    virtual bool RefreshCurrent(void);
    void SetSymbolPeriod(const string symbol, const ENUM_TIMEFRAMES period);
protected:
    string m_symbol;
    ENUM_TIMEFRAMES m_period;
    int m_freshed_data;
    int m_size;
};

class CiTime : public CSeries {
public:
    CiTime(void);
    ~CiTime();
    bool Create(const string symbol, const ENUM_TIMEFRAMES period);
    virtual bool BufferResize(const int size);
    datetime GetData(const int index) const;
    int GetData(const int start_pos, const int count, datetime & buffer) const;
    int GetData(const datetime start_time, const int count, datetime & buffer) const;
    int GetData(const datetime start_time, const datetime stop_time, datetime & buffer) const;
    virtual void Refresh(const int flags = OBJ_ALL_PERIODS);
};

class CTickVolumeBuffer : public CArrayLong {
public:
    CTickVolumeBuffer(void);
    ~CTickVolumeBuffer();
    void Size(const int size);
    long At(const int index) const;
    virtual bool Refresh(void);
    virtual bool RefreshCurrent(void);
    void SetSymbolPeriod(const string symbol, const ENUM_TIMEFRAMES period);
protected:
    string m_symbol;
    ENUM_TIMEFRAMES m_period;
    int m_freshed_data;
    int m_size;
};

class CiTickVolume : public CSeries {
public:
    CiTickVolume(void);
    ~CiTickVolume();
    bool Create(const string symbol, const ENUM_TIMEFRAMES period);
    virtual bool BufferResize(const int size);
    long GetData(const int index) const;
    int GetData(const int start_pos, const int count, long & buffer) const;
    int GetData(const datetime start_time, const int count, long & buffer) const;
    int GetData(const datetime start_time, const datetime stop_time, long & buffer) const;
    virtual void Refresh(const int flags = OBJ_ALL_PERIODS);
};

class CRealVolumeBuffer : public CArrayLong {
public:
    CRealVolumeBuffer(void);
    ~CRealVolumeBuffer();
    void Size(const int size);
    long At(const int index) const;
    virtual bool Refresh(void);
    virtual bool RefreshCurrent(void);
    void SetSymbolPeriod(const string symbol, const ENUM_TIMEFRAMES period);
protected:
    string m_symbol;
    ENUM_TIMEFRAMES m_period;
    int m_freshed_data;
    int m_size;
};

class CiRealVolume : public CSeries {
public:
    CiRealVolume(void);
    ~CiRealVolume();
    bool Create(const string symbol, const ENUM_TIMEFRAMES period);
    virtual bool BufferResize(const int size);
    long GetData(const int index) const;
    int GetData(const int start_pos, const int count, long & buffer) const;
    int GetData(const datetime start_time, const int count, long & buffer) const;
    int GetData(const datetime start_time, const datetime stop_time, long & buffer) const;
    virtual void Refresh(const int flags = OBJ_ALL_PERIODS);
};

class CiADX : public CIndicator {
public:
    CiADX(void);
    ~CiADX();
    int MaPeriod(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period);
    double Main(const int index) const;
    double Plus(const int index) const;
    double Minus(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period);
};

class CiADXWilder : public CIndicator {
public:
    CiADXWilder(void);
    ~CiADXWilder();
    int MaPeriod(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period);
    double Main(const int index) const;
    double Plus(const int index) const;
    double Minus(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period);
};

class CiBands : public CIndicator {
public:
    CiBands(void);
    ~CiBands();
    int MaPeriod(void) const;
    int MaShift(void) const;
    double Deviation(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int ma_shift, const double deviation, const int applied);
    double Base(const int index) const;
    double Upper(const int index) const;
    double Lower(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    int m_ma_shift;
    double m_deviation;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int ma_shift, const double deviation, const int applied);
};

class CiEnvelopes : public CIndicator {
public:
    CiEnvelopes(void);
    ~CiEnvelopes();
    int MaPeriod(void) const;
    int MaShift(void) const;
    ENUM_MA_METHOD MaMethod(void) const;
    int Applied(void) const;
    double Deviation(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int ma_shift, const ENUM_MA_METHOD ma_method, const int applied, const double deviation);
    double Upper(const int index) const;
    double Lower(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    int m_ma_shift;
    ENUM_MA_METHOD m_ma_method;
    int m_applied;
    double m_deviation;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int ma_shift, const ENUM_MA_METHOD ma_method, const int applied, const double deviation);
};

class CiIchimoku : public CIndicator {
public:
    CiIchimoku(void);
    ~CiIchimoku();
    int TenkanSenPeriod(void) const;
    int KijunSenPeriod(void) const;
    int SenkouSpanBPeriod(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int tenkan_sen, const int kijun_sen, const int senkou_span_b);
    double TenkanSen(const int index) const;
    double KijunSen(const int index) const;
    double SenkouSpanA(const int index) const;
    double SenkouSpanB(const int index) const;
    double ChinkouSpan(const int index) const;
    virtual int Type(void) const;
protected:
    int m_tenkan_sen;
    int m_kijun_sen;
    int m_senkou_span_b;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int tenkan_sen, const int kijun_sen, const int senkou_span_b);
};

class CiMA : public CIndicator {
public:
    CiMA(void);
    ~CiMA();
    int MaPeriod(void) const;
    int MaShift(void) const;
    ENUM_MA_METHOD MaMethod(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int ma_shift, const ENUM_MA_METHOD ma_method, const int applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    int m_ma_shift;
    ENUM_MA_METHOD m_ma_method;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int ma_shift, const ENUM_MA_METHOD ma_method, const int applied);
};

class CiSAR : public CIndicator {
public:
    CiSAR(void);
    ~CiSAR();
    double SarStep(void) const;
    double Maximum(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const double step, const double maximum);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    double m_step;
    double m_maximum;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const double step, const double maximum);
};

class CiStdDev : public CIndicator {
public:
    CiStdDev(void);
    ~CiStdDev();
    int MaPeriod(void) const;
    int MaShift(void) const;
    ENUM_MA_METHOD MaMethod(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int ma_shift, const ENUM_MA_METHOD ma_method, const int applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    int m_ma_shift;
    ENUM_MA_METHOD m_ma_method;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int ma_shift, const ENUM_MA_METHOD ma_method, const int applied);
};

class CiDEMA : public CIndicator {
public:
    CiDEMA(void);
    ~CiDEMA();
    int MaPeriod(void) const;
    int IndShift(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int ind_shift, const int applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    int m_ind_shift;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int ind_shift, const int applied);
};

class CiTEMA : public CIndicator {
public:
    CiTEMA(void);
    ~CiTEMA();
    int MaPeriod(void) const;
    int IndShift(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int ma_shift, const int applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    int m_ind_shift;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int ma_shift, const int applied);
};

class CiFrAMA : public CIndicator {
public:
    CiFrAMA(void);
    ~CiFrAMA();
    int MaPeriod(void) const;
    int IndShift(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int ind_shift, const int applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    int m_ind_shift;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int ind_shift, const int applied);
};

class CiAMA : public CIndicator {
public:
    CiAMA(void);
    ~CiAMA();
    int MaPeriod(void) const;
    int FastEmaPeriod(void) const;
    int SlowEmaPeriod(void) const;
    int IndShift(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int fast_ema_period, const int slow_ema_period, const int ind_shift, const int applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    int m_fast_ema_period;
    int m_slow_ema_period;
    int m_ind_shift;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int fast_ema_period, const int slow_ema_period, const int ind_shift, const int applied);
};

class CiVIDyA : public CIndicator {
public:
    CiVIDyA(void);
    ~CiVIDyA();
    int CmoPeriod(void) const;
    int EmaPeriod(void) const;
    int IndShift(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int cmo_period, const int ema_period, const int ind_shift, const int applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_cmo_period;
    int m_ema_period;
    int m_ind_shift;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int cmo_period, const int ema_period, const int ind_shift, const int applied);
};

class CiAD : public CIndicator {
public:
    CiAD(void);
    ~CiAD();
    ENUM_APPLIED_VOLUME Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const ENUM_APPLIED_VOLUME applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    ENUM_APPLIED_VOLUME m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const ENUM_APPLIED_VOLUME applied);
};

class CiMFI : public CIndicator {
public:
    CiMFI(void);
    ~CiMFI();
    int MaPeriod(void) const;
    ENUM_APPLIED_VOLUME Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const ENUM_APPLIED_VOLUME applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    ENUM_APPLIED_VOLUME m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const ENUM_APPLIED_VOLUME applied);
};

class CiOBV : public CIndicator {
public:
    CiOBV(void);
    ~CiOBV();
    ENUM_APPLIED_VOLUME Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const ENUM_APPLIED_VOLUME applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    ENUM_APPLIED_VOLUME m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const ENUM_APPLIED_VOLUME applied);
};

class CiVolumes : public CIndicator {
public:
    CiVolumes(void);
    ~CiVolumes();
    ENUM_APPLIED_VOLUME Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const ENUM_APPLIED_VOLUME applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    ENUM_APPLIED_VOLUME m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const ENUM_APPLIED_VOLUME applied);
};

class CAlglib {
public:
    static void HQRndRandomize(CHighQualityRandStateShell & state);
    static void HQRndSeed(const int s1, const int s2, CHighQualityRandStateShell & state);
    static double HQRndUniformR(CHighQualityRandStateShell & state);
    static int HQRndUniformI(CHighQualityRandStateShell & state, const int n);
    static double HQRndNormal(CHighQualityRandStateShell & state);
    static void HQRndNormalV(CHighQualityRandStateShell & state, int n, CRowDouble & x);
    static void HQRndNormalV(CHighQualityRandStateShell & state, int n, vector<double>& x);
    static void HQRndNormalM(CHighQualityRandStateShell & state, int m, int n, CMatrixDouble & x);
    static void HQRndNormalM(CHighQualityRandStateShell & state, int m, int n, matrix<double>& x);
    static void HQRndUnit2(CHighQualityRandStateShell & state, double & x, double & y);
    static void HQRndNormal2(CHighQualityRandStateShell & state, double & x1, double & x2);
    static double HQRndExponential(CHighQualityRandStateShell & state, const double lambdav);
    static double HQRndDiscrete(CHighQualityRandStateShell & state, int n, CRowDouble & x);
    static double HQRndDiscrete(CHighQualityRandStateShell & state, int n, vector<double>& x);
    static double HQRndContinuous(CHighQualityRandStateShell & state, int n, CRowDouble & x);
    static double HQRndContinuous(CHighQualityRandStateShell & state, int n, vector<double>& x);
    static void KDTreeSerialize(CKDTreeShell & obj, string & s_out);
    static void KDTreeUnserialize(string s_in, CKDTreeShell & obj);
    static void KDTreeBuild(CMatrixDouble & xy, const int n, const int nx, const int ny, const int normtype, CKDTreeShell & kdt);
    static void KDTreeBuild(CMatrixDouble & xy, const int nx, const int ny, const int normtype, CKDTreeShell & kdt);
    static void KDTreeBuildTagged(CMatrixDouble & xy, int & tags, const int n, const int nx, const int ny, const int normtype, CKDTreeShell & kdt);
    static void KDTreeBuildTagged(CMatrixDouble & xy, CRowInt & tags, const int n, const int nx, const int ny, const int normtype, CKDTreeShell & kdt);
    static void KDTreeBuildTagged(CMatrixDouble & xy, int & tags, const int nx, const int ny, const int normtype, CKDTreeShell & kdt);
    static void KDTreeBuildTagged(CMatrixDouble & xy, CRowInt & tags, const int nx, const int ny, const int normtype, CKDTreeShell & kdt);
    static void KDTreeCreateRequestBuffer(CKDTreeShell & kdt, CKDTreeRequestBufferShell & buf);
    static int KDTreeQueryKNN(CKDTreeShell & kdt, double & x, const int k, const bool selfmatch = true);
    static int KDTreeQueryKNN(CKDTreeShell & kdt, CRowDouble & x, const int k, const bool selfmatch = true);
    static int KDTreeQueryKNN(CKDTreeShell & kdt, vector<double>& x, const int k, const bool selfmatch = true);
    static int KDTreeTsQueryKNN(CKDTreeShell & kdt, CKDTreeRequestBufferShell & buf, double & x, const int k, const bool selfmatch = true);
    static int KDTreeTsQueryKNN(CKDTreeShell & kdt, CKDTreeRequestBufferShell & buf, CRowDouble & x, const int k, const bool selfmatch = true);
    static int KDTreeTsQueryKNN(CKDTreeShell & kdt, CKDTreeRequestBufferShell & buf, vector<double>& x, const int k, const bool selfmatch = true);
    static int KDTreeQueryRNN(CKDTreeShell & kdt, double & x, const double r, const bool selfmatch = true);
    static int KDTreeQueryRNN(CKDTreeShell & kdt, CRowDouble & x, const double r, const bool selfmatch = true);
    static int KDTreeQueryRNN(CKDTreeShell & kdt, vector<double>& x, const double r, const bool selfmatch = true);
    static int KDTreeQueryRNNU(CKDTreeShell & kdt, double & x, const double r, const bool selfmatch = true);
    static int KDTreeQueryRNNU(CKDTreeShell & kdt, CRowDouble & x, const double r, const bool selfmatch = true);
    static int KDTreeQueryRNNU(CKDTreeShell & kdt, vector<double>& x, const double r, const bool selfmatch = true);
    static int KDTreeTsQueryRNN(CKDTreeShell & kdt, CKDTreeRequestBufferShell & buf, double & x, const double r, const bool selfmatch = true);
    static int KDTreeTsQueryRNN(CKDTreeShell & kdt, CKDTreeRequestBufferShell & buf, CRowDouble & x, const double r, const bool selfmatch = true);
    static int KDTreeTsQueryRNN(CKDTreeShell & kdt, CKDTreeRequestBufferShell & buf, vector<double>& x, const double r, const bool selfmatch = true);
    static int KDTreeTsQueryRNNU(CKDTreeShell & kdt, CKDTreeRequestBufferShell & buf, double & x, const double r, const bool selfmatch = true);
    static int KDTreeTsQueryRNNU(CKDTreeShell & kdt, CKDTreeRequestBufferShell & buf, CRowDouble & x, const double r, const bool selfmatch = true);
    static int KDTreeTsQueryRNNU(CKDTreeShell & kdt, CKDTreeRequestBufferShell & buf, vector<double>& x, const double r, const bool selfmatch = true);
    static int KDTreeQueryAKNN(CKDTreeShell & kdt, double & x, const int k, const bool selfmatch = true, const double eps = 0);
    static int KDTreeQueryAKNN(CKDTreeShell & kdt, vector<double>& x, const int k, const bool selfmatch = true, const double eps = 0);
    static int KDTreeQueryAKNN(CKDTreeShell & kdt, CRowDouble & x, const int k, const bool selfmatch = true, const double eps = 0);
    static int KDTreeQueryBox(CKDTreeShell & kdt, double & boxmin, double & boxmax);
    static int KDTreeQueryBox(CKDTreeShell & kdt, vector<double>& boxmin, vector<double>& boxmax);
    static int KDTreeQueryBox(CKDTreeShell & kdt, CRowDouble & boxmin, CRowDouble & boxmax);
    static int KDTreeTsQueryBox(CKDTreeShell & kdt, CKDTreeRequestBufferShell & buf, double & boxmin, double & boxmax);
    static int KDTreeTsQueryBox(CKDTreeShell & kdt, CKDTreeRequestBufferShell & buf, vector<double>& boxmin, vector<double>& boxmax);
    static int KDTreeTsQueryBox(CKDTreeShell & kdt, CKDTreeRequestBufferShell & buf, CRowDouble & boxmin, CRowDouble & boxmax);
    static void KDTreeQueryResultsX(CKDTreeShell & kdt, CMatrixDouble & x);
    static void KDTreeQueryResultsXY(CKDTreeShell & kdt, CMatrixDouble & xy);
    static void KDTreeQueryResultsTags(CKDTreeShell & kdt, int & tags);
    static void KDTreeQueryResultsTags(CKDTreeShell & kdt, CRowInt & tags);
    static void KDTreeQueryResultsDistances(CKDTreeShell & kdt, double & r);
    static void KDTreeQueryResultsDistances(CKDTreeShell & kdt, vector<double>& r);
    static void KDTreeQueryResultsDistances(CKDTreeShell & kdt, CRowDouble & r);
    static void KDTreeQueryResultsXI(CKDTreeShell & kdt, CMatrixDouble & x);
    static void KDTreeQueryResultsXYI(CKDTreeShell & kdt, CMatrixDouble & xy);
    static void KDTreeQueryResultsTagsI(CKDTreeShell & kdt, int & tags);
    static void KDTreeQueryResultsTagsI(CKDTreeShell & kdt, CRowInt & tags);
    static void KDTreeQueryResultsDistancesI(CKDTreeShell & kdt, double & r);
    static void KDTreeQueryResultsDistancesI(CKDTreeShell & kdt, vector<double>& r);
    static void KDTreeQueryResultsDistancesI(CKDTreeShell & kdt, CRowDouble & r);
    static void DSOptimalSplit2(double & a, int & c, const int n, int & info, double & threshold, double & pal, double & pbl, double & par, double & pbr, double & cve);
    static void DSOptimalSplit2(CRowDouble & a, CRowInt & c, const int n, int & info, double & threshold, double & pal, double & pbl, double & par, double & pbr, double & cve);
    static void DSOptimalSplit2Fast(double & a, int & c, int & tiesbuf, int & cntbuf, double & bufr, int & bufi, const int n, const int nc, const double alpha, int & info, double & threshold, double & rms, double & cvrms);
    static void DSOptimalSplit2Fast(CRowDouble & a, CRowInt & c, CRowInt & tiesbuf, CRowInt & cntbuf, CRowDouble & bufr, CRowInt & bufi, const int n, const int nc, const double alpha, int & info, double & threshold, double & rms, double & cvrms);
    static void DFSerialize(CDecisionForestShell & obj, string & s_out);
    static void DFUnserialize(const string s_in, CDecisionForestShell & obj);
    static void DFCreateBuffer(CDecisionForestShell & model, CDecisionForestBuffer & buf);
    static void DFBuilderCreate(CDecisionForestBuilder & s);
    static void DFBuilderSetDataset(CDecisionForestBuilder & s, CMatrixDouble & xy, int npoints, int nvars, int nclasses);
    static void DFBuilderSetRndVars(CDecisionForestBuilder & s, int rndvars);
    static void DFBuilderSetRndVarsRatio(CDecisionForestBuilder & s, double f);
    static void DFBuilderSetRndVarsAuto(CDecisionForestBuilder & s);
    static void DFBuilderSetSubsampleRatio(CDecisionForestBuilder & s, double f);
    static void DFBuilderSetSeed(CDecisionForestBuilder & s, int seedval);
    static void DFBuilderSetRDFAlgo(CDecisionForestBuilder & s, int algotype);
    static void DFBuilderSetRDFSplitStrength(CDecisionForestBuilder & s, int splitstrength);
    static void DFBuilderSetImportanceTrnGini(CDecisionForestBuilder & s);
    static void DFBuilderSetImportanceOOBGini(CDecisionForestBuilder & s);
    static void DFBuilderSetImportancePermutation(CDecisionForestBuilder & s);
    static void DFBuilderSetImportanceNone(CDecisionForestBuilder & s);
    static double DFBuilderGetProgress(CDecisionForestBuilder & s);
    static double DFBuilderPeekProgress(CDecisionForestBuilder & s);
    static void DFBuilderBuildRandomForest(CDecisionForestBuilder & s, int ntrees, CDecisionForestShell & df, CDFReportShell & rep);
    static double DFBinaryCompression(CDecisionForestShell & df);
    static void DFProcess(CDecisionForestShell & df, double & x, double & y);
    static void DFProcessI(CDecisionForestShell & df, double & x, double & y);
    static double DFProcess0(CDecisionForestShell & model, double & x);
    static double DFProcess0(CDecisionForestShell & model, CRowDouble & x);
    static int DFClassify(CDecisionForestShell & model, double & x);
    static int DFClassify(CDecisionForestShell & model, CRowDouble & x);
    static double DFRelClsError(CDecisionForestShell & df, CMatrixDouble & xy, const int npoints);
    static double DFAvgCE(CDecisionForestShell & df, CMatrixDouble & xy, const int npoints);
    static double DFRMSError(CDecisionForestShell & df, CMatrixDouble & xy, const int npoints);
    static double DFAvgError(CDecisionForestShell & df, CMatrixDouble & xy, const int npoints);
    static double DFAvgRelError(CDecisionForestShell & df, CMatrixDouble & xy, const int npoints);
    static void DFBuildRandomDecisionForest(CMatrixDouble & xy, const int npoints, const int nvars, const int nclasses, const int ntrees, const double r, int & info, CDecisionForestShell & df, CDFReportShell & rep);
    static void DFBuildRandomDecisionForestX1(CMatrixDouble & xy, const int npoints, const int nvars, const int nclasses, const int ntrees, int nrndvars, const double r, int & info, CDecisionForestShell & df, CDFReportShell & rep);
    static void ClusterizerCreate(CClusterizerState & s);
    static void ClusterizerSetPoints(CClusterizerState & s, CMatrixDouble & xy, int npoints, int nfeatures, int disttype);
    static void ClusterizerSetPoints(CClusterizerState & s, CMatrixDouble & xy, int disttype);
    static void ClusterizerSetDistances(CClusterizerState & s, CMatrixDouble & d, int npoints, bool IsUpper);
    static void ClusterizerSetDistances(CClusterizerState & s, CMatrixDouble & d, bool IsUpper);
    static void ClusterizerSetAHCAlgo(CClusterizerState & s, int algo);
    static void ClusterizerSetKMeansLimits(CClusterizerState & s, int restarts, int maxits);
    static void ClusterizerSetKMeansInit(CClusterizerState & s, int initalgo);
    static void ClusterizerSetSeed(CClusterizerState & s, int seed);
    static void ClusterizerRunAHC(CClusterizerState & s, CAHCReport & rep);
    static void ClusterizerRunKMeans(CClusterizerState & s, int k, CKmeansReport & rep);
    static void ClusterizerGetDistances(CMatrixDouble & xy, int npoints, int nfeatures, int disttype, CMatrixDouble & d);
    static void ClusterizerGetKClusters(CAHCReport & rep, int k, CRowInt & cidx, CRowInt & cz);
    static void ClusterizerSeparatedByDist(CAHCReport & rep, double r, int & k, CRowInt & cidx, CRowInt & cz);
    static void ClusterizerSeparatedByCorr(CAHCReport & rep, double r, int & k, CRowInt & cidx, CRowInt & cz);
    static void KMeansGenerate(CMatrixDouble & xy, const int npoints, const int nvars, const int k, const int restarts, int & info, CMatrixDouble & c, int & xyc);
    static void FisherLDA(CMatrixDouble & xy, const int npoints, const int nvars, const int nclasses, int & info, double & w);
    static void FisherLDA(CMatrixDouble & xy, const int npoints, const int nvars, const int nclasses, int & info, CRowDouble & w);
    static void FisherLDAN(CMatrixDouble & xy, const int npoints, const int nvars, const int nclasses, int & info, CMatrixDouble & w);
    static void LRBuild(CMatrixDouble & xy, const int npoints, const int nvars, int & info, CLinearModelShell & lm, CLRReportShell & ar);
    static void LRBuildS(CMatrixDouble & xy, double & s, const int npoints, const int nvars, int & info, CLinearModelShell & lm, CLRReportShell & ar);
    static void LRBuildS(CMatrixDouble & xy, CRowDouble & s, const int npoints, const int nvars, int & info, CLinearModelShell & lm, CLRReportShell & ar);
    static void LRBuildZS(CMatrixDouble & xy, double & s, const int npoints, const int nvars, int & info, CLinearModelShell & lm, CLRReportShell & ar);
    static void LRBuildZS(CMatrixDouble & xy, CRowDouble & s, const int npoints, const int nvars, int & info, CLinearModelShell & lm, CLRReportShell & ar);
    static void LRBuildZ(CMatrixDouble & xy, const int npoints, const int nvars, int & info, CLinearModelShell & lm, CLRReportShell & ar);
    static void LRUnpack(CLinearModelShell & lm, double & v, int & nvars);
    static void LRUnpack(CLinearModelShell & lm, CRowDouble & v, int & nvars);
    static void LRPack(double & v, const int nvars, CLinearModelShell & lm);
    static void LRPack(CRowDouble & v, const int nvars, CLinearModelShell & lm);
    static double LRProcess(CLinearModelShell & lm, double & x);
    static double LRProcess(CLinearModelShell & lm, CRowDouble & x);
    static double LRRMSError(CLinearModelShell & lm, CMatrixDouble & xy, const int npoints);
    static double LRAvgError(CLinearModelShell & lm, CMatrixDouble & xy, const int npoints);
    static double LRAvgRelError(CLinearModelShell & lm, CMatrixDouble & xy, const int npoints);
    static void MLPSerialize(CMultilayerPerceptronShell & obj, string & s_out);
    static void MLPUnserialize(const string s_in, CMultilayerPerceptronShell & obj);
    static void MLPCreate0(const int nin, const int nout, CMultilayerPerceptronShell & network);
    static void MLPCreate1(const int nin, int nhid, const int nout, CMultilayerPerceptronShell & network);
    static void MLPCreate2(const int nin, const int nhid1, const int nhid2, const int nout, CMultilayerPerceptronShell & network);
    static void MLPCreateB0(const int nin, const int nout, const double b, const double d, CMultilayerPerceptronShell & network);
    static void MLPCreateB1(const int nin, int nhid, const int nout, const double b, const double d, CMultilayerPerceptronShell & network);
    static void MLPCreateB2(const int nin, const int nhid1, const int nhid2, const int nout, const double b, const double d, CMultilayerPerceptronShell & network);
    static void MLPCreateR0(const int nin, const int nout, double a, const double b, CMultilayerPerceptronShell & network);
    static void MLPCreateR1(const int nin, int nhid, const int nout, const double a, const double b, CMultilayerPerceptronShell & network);
    static void MLPCreateR2(const int nin, const int nhid1, const int nhid2, const int nout, const double a, const double b, CMultilayerPerceptronShell & network);
    static void MLPCreateC0(const int nin, const int nout, CMultilayerPerceptronShell & network);
    static void MLPCreateC1(const int nin, int nhid, const int nout, CMultilayerPerceptronShell & network);
    static void MLPCreateC2(const int nin, const int nhid1, const int nhid2, const int nout, CMultilayerPerceptronShell & network);
    static void MLPRandomize(CMultilayerPerceptronShell & network);
    static void MLPRandomizeFull(CMultilayerPerceptronShell & network);
    static void MLPInitPreprocessor(CMultilayerPerceptronShell & network, CMatrixDouble & xy, int ssize);
    static void MLPProperties(CMultilayerPerceptronShell & network, int & nin, int & nout, int & wcount);
    static int MLPGetInputsCount(CMultilayerPerceptronShell & network);
    static int MLPGetOutputsCount(CMultilayerPerceptronShell & network);
    static int MLPGetWeightsCount(CMultilayerPerceptronShell & network);
    static bool MLPIsSoftMax(CMultilayerPerceptronShell & network);
    static int MLPGetLayersCount(CMultilayerPerceptronShell & network);
    static int MLPGetLayerSize(CMultilayerPerceptronShell & network, const int k);
    static void MLPGetInputScaling(CMultilayerPerceptronShell & network, const int i, double & mean, double & sigma);
    static void MLPGetOutputScaling(CMultilayerPerceptronShell & network, const int i, double & mean, double & sigma);
    static void MLPGetNeuronInfo(CMultilayerPerceptronShell & network, const int k, const int i, int & fkind, double & threshold);
    static double MLPGetWeight(CMultilayerPerceptronShell & network, const int k0, const int i0, const int k1, const int i1);
    static void MLPSetInputScaling(CMultilayerPerceptronShell & network, const int i, const double mean, const double sigma);
    static void MLPSetOutputScaling(CMultilayerPerceptronShell & network, const int i, const double mean, const double sigma);
    static void MLPSetNeuronInfo(CMultilayerPerceptronShell & network, const int k, const int i, int fkind, double threshold);
    static void MLPSetWeight(CMultilayerPerceptronShell & network, const int k0, const int i0, const int k1, const int i1, const double w);
    static void MLPActivationFunction(const double net, const int k, double & f, double & df, double & d2f);
    static void MLPProcess(CMultilayerPerceptronShell & network, double & x, double & y);
    static void MLPProcessI(CMultilayerPerceptronShell & network, double & x, double & y);
    static double MLPError(CMultilayerPerceptronShell & network, CMatrixDouble & xy, const int ssize);
    static double MLPErrorSparse(CMultilayerPerceptronShell & network, CSparseMatrix & xy, int npoints);
    static double MLPErrorN(CMultilayerPerceptronShell & network, CMatrixDouble & xy, const int ssize);
    static int MLPClsError(CMultilayerPerceptronShell & network, CMatrixDouble & xy, const int ssize);
    static double MLPRelClsError(CMultilayerPerceptronShell & network, CMatrixDouble & xy, const int npoints);
    static double MLPRelClsErrorSparse(CMultilayerPerceptronShell & network, CSparseMatrix & xy, int npoints);
    static double MLPAvgCE(CMultilayerPerceptronShell & network, CMatrixDouble & xy, const int npoints);
    static double MLPAvgCESparse(CMultilayerPerceptronShell & network, CSparseMatrix & xy, int npoints);
    static double MLPRMSError(CMultilayerPerceptronShell & network, CMatrixDouble & xy, const int npoints);
    static double MLPRMSErrorSparse(CMultilayerPerceptronShell & network, CSparseMatrix & xy, int npoints);
    static double MLPAvgError(CMultilayerPerceptronShell & network, CMatrixDouble & xy, const int npoints);
    static double MLPAvgErrorSparse(CMultilayerPerceptronShell & network, CSparseMatrix & xy, int npoints);
    static double MLPAvgRelError(CMultilayerPerceptronShell & network, CMatrixDouble & xy, const int npoints);
    static double MLPAvgRelErrorSparse(CMultilayerPerceptronShell & network, CSparseMatrix & xy, int npoints);
    static void MLPGrad(CMultilayerPerceptronShell & network, double & x, double & desiredy, double & e, double & grad);
    static void MLPGradN(CMultilayerPerceptronShell & network, double & x, double & desiredy, double & e, double & grad);
    static void MLPGradBatch(CMultilayerPerceptronShell & network, CMatrixDouble & xy, const int ssize, double & e, double & grad);
    static void MLPGradBatch(CMultilayerPerceptronShell & network, CMatrixDouble & xy, const int ssize, double & e, CRowDouble & grad);
    static void MLPGradBatchSparse(CMultilayerPerceptronShell & network, CSparseMatrix & xy, int ssize, double & e, CRowDouble & grad);
    static void MLPGradBatchSubset(CMultilayerPerceptronShell & network, CMatrixDouble & xy, int setsize, CRowInt & idx, int subsetsize, double & e, CRowDouble & grad);
    static void MLPGradBatchSparseSubset(CMultilayerPerceptronShell & network, CSparseMatrix & xy, int setsize, CRowInt & idx, int subsetsize, double & e, CRowDouble & grad);
    static void MLPGradNBatch(CMultilayerPerceptronShell & network, CMatrixDouble & xy, const int ssize, double & e, double & grad);
    static void MLPGradNBatch(CMultilayerPerceptronShell & network, CMatrixDouble & xy, const int ssize, double & e, CRowDouble & grad);
    static void MLPHessianNBatch(CMultilayerPerceptronShell & network, CMatrixDouble & xy, const int ssize, double & e, double & grad, CMatrixDouble & h);
    static void MLPHessianNBatch(CMultilayerPerceptronShell & network, CMatrixDouble & xy, const int ssize, double & e, CRowDouble & grad, CMatrixDouble & h);
    static void MLPHessianBatch(CMultilayerPerceptronShell & network, CMatrixDouble & xy, const int ssize, double & e, double & grad, CMatrixDouble & h);
    static void MLPHessianBatch(CMultilayerPerceptronShell & network, CMatrixDouble & xy, const int ssize, double & e, CRowDouble & grad, CMatrixDouble & h);
    static void MLPAllErrorsSubset(CMultilayerPerceptronShell & network, CMatrixDouble & xy, int setsize, CRowInt & subset, int subsetsize, CModelErrors & rep);
    static void MLPAllErrorsSparseSubset(CMultilayerPerceptronShell & network, CSparseMatrix & xy, int setsize, CRowInt & subset, int subsetsize, CModelErrors & rep);
    static double MLPErrorSubset(CMultilayerPerceptronShell & network, CMatrixDouble & xy, int setsize, CRowInt & subset, int subsetsize);
    static double MLPErrorSparseSubset(CMultilayerPerceptronShell & network, CSparseMatrix & xy, int setsize, CRowInt & subset, int subsetsize);
    static void MNLTrainH(CMatrixDouble & xy, const int npoints, const int nvars, const int nclasses, int & info, CLogitModelShell & lm, CMNLReportShell & rep);
    static void MNLProcess(CLogitModelShell & lm, double & x, double & y);
    static void MNLProcess(CLogitModelShell & lm, CRowDouble & x, CRowDouble & y);
    static void MNLProcessI(CLogitModelShell & lm, double & x, double & y);
    static void MNLProcessI(CLogitModelShell & lm, CRowDouble & x, CRowDouble & y);
    static void MNLUnpack(CLogitModelShell & lm, CMatrixDouble & a, int & nvars, int & nclasses);
    static void MNLPack(CMatrixDouble & a, const int nvars, const int nclasses, CLogitModelShell & lm);
    static double MNLAvgCE(CLogitModelShell & lm, CMatrixDouble & xy, const int npoints);
    static double MNLRelClsError(CLogitModelShell & lm, CMatrixDouble & xy, const int npoints);
    static double MNLRMSError(CLogitModelShell & lm, CMatrixDouble & xy, const int npoints);
    static double MNLAvgError(CLogitModelShell & lm, CMatrixDouble & xy, const int npoints);
    static double MNLAvgRelError(CLogitModelShell & lm, CMatrixDouble & xy, const int ssize);
    static int MNLClsError(CLogitModelShell & lm, CMatrixDouble & xy, const int npoints);
    static void MCPDCreate(const int n, CMCPDStateShell & s);
    static void MCPDCreateEntry(const int n, const int entrystate, CMCPDStateShell & s);
    static void MCPDCreateExit(const int n, const int exitstate, CMCPDStateShell & s);
    static void MCPDCreateEntryExit(const int n, const int entrystate, const int exitstate, CMCPDStateShell & s);
    static void MCPDAddTrack(CMCPDStateShell & s, CMatrixDouble & xy, const int k);
    static void MCPDAddTrack(CMCPDStateShell & s, CMatrixDouble & xy);
    static void MCPDSetEC(CMCPDStateShell & s, CMatrixDouble & ec);
    static void MCPDAddEC(CMCPDStateShell & s, const int i, const int j, const double c);
    static void MCPDSetBC(CMCPDStateShell & s, CMatrixDouble & bndl, CMatrixDouble & bndu);
    static void MCPDAddBC(CMCPDStateShell & s, const int i, const int j, const double bndl, const double bndu);
    static void MCPDSetLC(CMCPDStateShell & s, CMatrixDouble & c, int & ct, const int k);
    static void MCPDSetLC(CMCPDStateShell & s, CMatrixDouble & c, CRowInt & ct, const int k);
    static void MCPDSetLC(CMCPDStateShell & s, CMatrixDouble & c, int & ct);
    static void MCPDSetLC(CMCPDStateShell & s, CMatrixDouble & c, CRowInt & ct);
    static void MCPDSetTikhonovRegularizer(CMCPDStateShell & s, const double v);
    static void MCPDSetPrior(CMCPDStateShell & s, CMatrixDouble & pp);
    static void MCPDSetPredictionWeights(CMCPDStateShell & s, double & pw);
    static void MCPDSetPredictionWeights(CMCPDStateShell & s, CRowDouble & pw);
    static void MCPDSolve(CMCPDStateShell & s);
    static void MCPDResults(CMCPDStateShell & s, CMatrixDouble & p, CMCPDReportShell & rep);
    static void MLPTrainLM(CMultilayerPerceptronShell & network, CMatrixDouble & xy, const int npoints, const double decay, const int restarts, int & info, CMLPReportShell & rep);
    static void MLPTrainLBFGS(CMultilayerPerceptronShell & network, CMatrixDouble & xy, const int npoints, const double decay, const int restarts, const double wstep, int maxits, int & info, CMLPReportShell & rep);
    static void MLPTrainES(CMultilayerPerceptronShell & network, CMatrixDouble & trnxy, const int trnsize, CMatrixDouble & valxy, const int valsize, const double decay, const int restarts, int & info, CMLPReportShell & rep);
    static void MLPKFoldCVLBFGS(CMultilayerPerceptronShell & network, CMatrixDouble & xy, const int npoints, const double decay, const int restarts, const double wstep, const int maxits, const int foldscount, int & info, CMLPReportShell & rep, CMLPCVReportShell & cvrep);
    static void MLPKFoldCVLM(CMultilayerPerceptronShell & network, CMatrixDouble & xy, const int npoints, const double decay, const int restarts, const int foldscount, int & info, CMLPReportShell & rep, CMLPCVReportShell & cvrep);
    static void MLPCreateTrainer(int nin, int nout, CMLPTrainer & s);
    static void MLPCreateTrainerCls(int nin, int nclasses, CMLPTrainer & s);
    static void MLPSetDataset(CMLPTrainer & s, CMatrixDouble & xy, int npoints);
    static void MLPSetSparseDataset(CMLPTrainer & s, CSparseMatrix & xy, int npoints);
    static void MLPSetDecay(CMLPTrainer & s, double decay);
    static void MLPSetCond(CMLPTrainer & s, double wstep, int maxits);
    static void MLPSetAlgoBatch(CMLPTrainer & s);
    static void MLPTrainNetwork(CMLPTrainer & s, CMultilayerPerceptronShell & network, int nrestarts, CMLPReportShell & rep);
    static void MLPStartTraining(CMLPTrainer & s, CMultilayerPerceptronShell & network, bool randomstart);
    static bool MLPContinueTraining(CMLPTrainer & s, CMultilayerPerceptronShell & network);
    static void MLPECreate0(const int nin, const int nout, const int ensemblesize, CMLPEnsembleShell & ensemble);
    static void MLPECreate1(const int nin, int nhid, const int nout, const int ensemblesize, CMLPEnsembleShell & ensemble);
    static void MLPECreate2(const int nin, const int nhid1, const int nhid2, const int nout, const int ensemblesize, CMLPEnsembleShell & ensemble);
    static void MLPECreateB0(const int nin, const int nout, const double b, const double d, const int ensemblesize, CMLPEnsembleShell & ensemble);
    static void MLPECreateB1(const int nin, int nhid, const int nout, const double b, const double d, const int ensemblesize, CMLPEnsembleShell & ensemble);
    static void MLPECreateB2(const int nin, const int nhid1, const int nhid2, const int nout, const double b, const double d, const int ensemblesize, CMLPEnsembleShell & ensemble);
    static void MLPECreateR0(const int nin, const int nout, const double a, const double b, const int ensemblesize, CMLPEnsembleShell & ensemble);
    static void MLPECreateR1(const int nin, int nhid, const int nout, const double a, const double b, const int ensemblesize, CMLPEnsembleShell & ensemble);
    static void MLPECreateR2(const int nin, const int nhid1, const int nhid2, const int nout, const double a, const double b, const int ensemblesize, CMLPEnsembleShell & ensemble);
    static void MLPECreateC0(const int nin, const int nout, const int ensemblesize, CMLPEnsembleShell & ensemble);
    static void MLPECreateC1(const int nin, int nhid, const int nout, const int ensemblesize, CMLPEnsembleShell & ensemble);
    static void MLPECreateC2(const int nin, const int nhid1, const int nhid2, const int nout, const int ensemblesize, CMLPEnsembleShell & ensemble);
    static void MLPECreateFromNetwork(CMultilayerPerceptronShell & network, const int ensemblesize, CMLPEnsembleShell & ensemble);
    static void MLPERandomize(CMLPEnsembleShell & ensemble);
    static void MLPEProperties(CMLPEnsembleShell & ensemble, int & nin, int & nout);
    static bool MLPEIsSoftMax(CMLPEnsembleShell & ensemble);
    static void MLPEProcess(CMLPEnsembleShell & ensemble, double & x, double & y);
    static void MLPEProcessI(CMLPEnsembleShell & ensemble, double & x, double & y);
    static double MLPERelClsError(CMLPEnsembleShell & ensemble, CMatrixDouble & xy, const int npoints);
    static double MLPEAvgCE(CMLPEnsembleShell & ensemble, CMatrixDouble & xy, const int npoints);
    static double MLPERMSError(CMLPEnsembleShell & ensemble, CMatrixDouble & xy, const int npoints);
    static double MLPEAvgError(CMLPEnsembleShell & ensemble, CMatrixDouble & xy, const int npoints);
    static double MLPEAvgRelError(CMLPEnsembleShell & ensemble, CMatrixDouble & xy, const int npoints);
    static void MLPEBaggingLM(CMLPEnsembleShell & ensemble, CMatrixDouble & xy, const int npoints, const double decay, const int restarts, int & info, CMLPReportShell & rep, CMLPCVReportShell & ooberrors);
    static void MLPEBaggingLBFGS(CMLPEnsembleShell & ensemble, CMatrixDouble & xy, const int npoints, const double decay, const int restarts, const double wstep, const int maxits, int & info, CMLPReportShell & rep, CMLPCVReportShell & ooberrors);
    static void MLPETrainES(CMLPEnsembleShell & ensemble, CMatrixDouble & xy, const int npoints, const double decay, const int restarts, int & info, CMLPReportShell & rep);
    static void MLPTrainEnsembleES(CMLPTrainer & s, CMLPEnsembleShell & ensemble, int nrestarts, CMLPReportShell & rep);
    static void PCABuildBasis(CMatrixDouble & x, const int npoints, const int nvars, int & info, double & s2, CMatrixDouble & v);
    static void PCABuildBasis(CMatrixDouble & x, const int npoints, const int nvars, int & info, CRowDouble & s2, CMatrixDouble & v);
    static void PCATruncatedSubspace(CMatrixDouble & x, int npoints, int nvars, int nneeded, double eps, int maxits, CRowDouble & s2, CMatrixDouble & v);
    static void PCATruncatedSubspaceSparse(CSparseMatrix & x, int npoints, int nvars, int nneeded, double eps, int maxits, CRowDouble & s2, CMatrixDouble & v);
    static void ODESolverRKCK(double & y, const int n, double & x, const int m, const double eps, const double h, CODESolverStateShell & state);
    static void ODESolverRKCK(double & y, double & x, const double eps, const double h, CODESolverStateShell & state);
    static bool ODESolverIteration(CODESolverStateShell & state);
    static void ODESolverSolve(CODESolverStateShell & state, CNDimensional_ODE_RP & diff, CObject & obj);
    static void ODESolverResults(CODESolverStateShell & state, int & m, double & xtbl, CMatrixDouble & ytbl, CODESolverReportShell & rep);
    static void FilterSMA(CRowDouble & x, int n, int k);
    static void FilterSMA(CRowDouble & x, int k);
    static void FilterEMA(CRowDouble & x, int n, double alpha);
    static void FilterEMA(CRowDouble & x, double alpha);
    static void FilterLRMA(CRowDouble & x, int n, int k);
    static void FilterLRMA(CRowDouble & x, int k);
    static void SSACreate(CSSAModel & s);
    static void SSASetWindow(CSSAModel & s, int windowwidth);
    static void SSASetSeed(CSSAModel & s, int seed);
    static void SSASetPowerUpLength(CSSAModel & s, int pwlen);
    static void SSASetMemoryLimit(CSSAModel & s, int memlimit);
    static void SSAAddSequence(CSSAModel & s, CRowDouble & x, int n);
    static void SSAAddSequence(CSSAModel & s, CRowDouble & x);
    static void SSAAppendPointAndUpdate(CSSAModel & s, double x, double updateits);
    static void SSAAppendSequenceAndUpdate(CSSAModel & s, CRowDouble & x, int nticks, double updateits);
    static void SSAAppendSequenceAndUpdate(CSSAModel & s, CRowDouble & x, double updateits);
    static void SSASetAlgoPrecomputed(CSSAModel & s, CMatrixDouble & a, int windowwidth, int nbasis);
    static void SSASetAlgoPrecomputed(CSSAModel & s, CMatrixDouble & a);
    static void SSASetAlgoTopKDirect(CSSAModel & s, int topk);
    static void SSASetAlgoTopKRealtime(CSSAModel & s, int topk);
    static void SSAClearData(CSSAModel & s);
    static void SSAGetBasis(CSSAModel & s, CMatrixDouble & a, CRowDouble & sv, int & windowwidth, int & nbasis);
    static void SSAGetLRR(CSSAModel & s, CRowDouble & a, int & windowwidth);
    static void SSAAnalyzeLastWindow(CSSAModel & s, CRowDouble & trend, CRowDouble & noise, int & nticks);
    static void SSAAnalyzeLast(CSSAModel & s, int nticks, CRowDouble & trend, CRowDouble & noise);
    static void SSAAnalyzeSequence(CSSAModel & s, CRowDouble & data, int nticks, CRowDouble & trend, CRowDouble & noise);
    static void SSAAnalyzeSequence(CSSAModel & s, CRowDouble & data, CRowDouble & trend, CRowDouble & noise);
    static void SSAForecastLast(CSSAModel & s, int nticks, CRowDouble & trend);
    static void SSAForecastSequence(CSSAModel & s, CRowDouble & data, int datalen, int forecastlen, bool applysmoothing, CRowDouble & trend);
    static void SSAForecastSequence(CSSAModel & s, CRowDouble & data, int forecastlen, CRowDouble & trend);
    static void SSAForecastAvgLast(CSSAModel & s, int m, int nticks, CRowDouble & trend);
    static void SSAForecastAvgSequence(CSSAModel & s, CRowDouble & data, int datalen, int m, int forecastlen, bool applysmoothing, CRowDouble & trend);
    static void SSAForecastAvgSequence(CSSAModel & s, CRowDouble & data, int m, int forecastlen, CRowDouble & trend);
    static void KNNSerialize(CKNNModel & obj, string & s_out);
    static void KNNUnserialize(const string s_in, CKNNModel & obj);
    static void KNNCreateBuffer(CKNNModel & model, CKNNBuffer & buf);
    static void KNNBuilderCreate(CKNNBuilder & s);
    static void KNNBuilderSetDatasetReg(CKNNBuilder & s, CMatrixDouble & xy, int npoints, int nvars, int nout);
    static void KNNBuilderSetDatasetCLS(CKNNBuilder & s, CMatrixDouble & xy, int npoints, int nvars, int nclasses);
    static void KNNBuilderSetNorm(CKNNBuilder & s, int nrmtype);
    static void KNNBuilderBuildKNNModel(CKNNBuilder & s, int k, double eps, CKNNModel & model, CKNNReport & rep);
    static void KNNRewriteKEps(CKNNModel & model, int k, double eps);
    static void KNNProcess(CKNNModel & model, CRowDouble & x, CRowDouble & y);
    static double KNNProcess0(CKNNModel & model, CRowDouble & x);
    static int KNNClassify(CKNNModel & model, CRowDouble & x);
    static void KNNProcessI(CKNNModel & model, CRowDouble & x, CRowDouble & y);
    static void KNNTsProcess(CKNNModel & model, CKNNBuffer & buf, CRowDouble & x, CRowDouble & y);
    static double KNNRelClsError(CKNNModel & model, CMatrixDouble & xy, int npoints);
    static double KNNAvgCE(CKNNModel & model, CMatrixDouble & xy, int npoints);
    static double KNNRMSError(CKNNModel & model, CMatrixDouble & xy, int npoints);
    static double KNNAvgError(CKNNModel & model, CMatrixDouble & xy, int npoints);
    static double KNNAvgRelError(CKNNModel & model, CMatrixDouble & xy, int npoints);
    static void KNNAllErrors(CKNNModel & model, CMatrixDouble & xy, int npoints, CKNNReport & rep);
    static void FFTC1D(complex & a, const int n);
    static void FFTC1D(complex & a);
    static void FFTC1DInv(complex & a, const int n);
    static void FFTC1DInv(complex & a);
    static void FFTR1D(double & a, const int n, complex & f);
    static void FFTR1D(double & a, complex & f);
    static void FFTR1DInv(complex & f, const int n, double & a);
    static void FFTR1DInv(complex & f, double & a);
    static void FFTC1D(CRowComplex & a, const int n);
    static void FFTC1D(CRowComplex & a);
    static void FFTC1DInv(CRowComplex & a, const int n);
    static void FFTC1DInv(CRowComplex & a);
    static void FFTR1D(CRowDouble & a, const int n, CRowComplex & f);
    static void FFTR1D(CRowDouble & a, CRowComplex & f);
    static void FFTR1DInv(CRowComplex & f, const int n, CRowDouble & a);
    static void FFTR1DInv(CRowComplex & f, CRowDouble & a);
    static void ConvC1D(complex & a, const int m, complex & b, const int n, complex & r);
    static void ConvC1DInv(complex & a, const int m, complex & b, const int n, complex & r);
    static void ConvC1DCircular(complex & s, const int m, complex & r, const int n, complex & c);
    static void ConvC1DCircularInv(complex & a, const int m, complex & b, const int n, complex & r);
    static void ConvR1D(double & a, const int m, double & b, const int n, double & r);
    static void ConvR1DInv(double & a, const int m, double & b, const int n, double & r);
    static void ConvR1DCircular(double & s, const int m, double & r, const int n, double & c);
    static void ConvR1DCircularInv(double & a, const int m, double & b, const int n, double & r);
    static void CorrC1D(complex & signal, const int n, complex & pattern, const int m, complex & r);
    static void CorrC1DCircular(complex & signal, const int m, complex & pattern, const int n, complex & c);
    static void CorrR1D(double & signal, const int n, double & pattern, const int m, double & r);
    static void CorrR1DCircular(double & signal, const int m, double & pattern, const int n, double & c);
    static void FHTR1D(double & a, const int n);
    static void FHTR1DInv(double & a, const int n);
    static void GQGenerateRec(double & alpha, double & beta, const double mu0, const int n, int & info, double & x, double & w);
    static void GQGenerateGaussLobattoRec(double & alpha, double & beta, const double mu0, const double a, const double b, const int n, int & info, double & x, double & w);
    static void GQGenerateGaussRadauRec(double & alpha, double & beta, const double mu0, const double a, const int n, int & info, double & x, double & w);
    static void GQGenerateGaussLegendre(const int n, int & info, double & x, double & w);
    static void GQGenerateGaussJacobi(const int n, const double alpha, const double beta, int & info, double & x, double & w);
    static void GQGenerateGaussLaguerre(const int n, const double alpha, int & info, double & x, double & w);
    static void GQGenerateGaussHermite(const int n, int & info, double & x, double & w);
    static void GKQGenerateRec(double & alpha, double & beta, const double mu0, const int n, int & info, double & x, double & wkronrod, double & wgauss);
    static void GKQGenerateGaussLegendre(const int n, int & info, double & x, double & wkronrod, double & wgauss);
    static void GKQGenerateGaussJacobi(const int n, const double alpha, const double beta, int & info, double & x, double & wkronrod, double & wgauss);
    static void GKQLegendreCalc(const int n, int & info, double & x, double & wkronrod, double & wgauss);
    static void GKQLegendreTbl(const int n, double & x, double & wkronrod, double & wgauss, double & eps);
    static void AutoGKSmooth(const double a, const double b, CAutoGKStateShell & state);
    static void AutoGKSmoothW(const double a, const double b, double xwidth, CAutoGKStateShell & state);
    static void AutoGKSingular(const double a, const double b, const double alpha, const double beta, CAutoGKStateShell & state);
    static bool AutoGKIteration(CAutoGKStateShell & state);
    static void AutoGKIntegrate(CAutoGKStateShell & state, CIntegrator1_Func & func, CObject & obj);
    static void AutoGKResults(CAutoGKStateShell & state, double & v, CAutoGKReportShell & rep);
    static void IDWSerialize(CIDWModelShell & obj, string & s_out);
    static void IDWUnserialize(string s_in, CIDWModelShell & obj);
    static void IDWCreateCalcBuffer(CIDWModelShell & s, CIDWCalcBuffer & buf);
    static void IDWBuilderCreate(int nx, int ny, CIDWBuilder & state);
    static void IDWBuilderSetNLayers(CIDWBuilder & state, int nlayers);
    static void IDWBuilderSetPoints(CIDWBuilder & state, CMatrixDouble & xy, int n);
    static void IDWBuilderSetPoints(CIDWBuilder & state, CMatrixDouble & xy);
    static void IDWBuilderSetAlgoMSTAB(CIDWBuilder & state, double srad);
    static void IDWBuilderSetAlgoTextBookShepard(CIDWBuilder & state, double p);
    static void IDWBuilderSetAlgoTextBookModShepard(CIDWBuilder & state, double r);
    static void IDWBuilderSetUserTerm(CIDWBuilder & state, double v);
    static void IDWBuilderSetConstTerm(CIDWBuilder & state);
    static void IDWBuilderSetZeroTerm(CIDWBuilder & state);
    static double IDWCalc1(CIDWModelShell & s, double x0);
    static double IDWCalc2(CIDWModelShell & s, double x0, double x1);
    static double IDWCalc3(CIDWModelShell & s, double x0, double x1, double x2);
    static void IDWCalc(CIDWModelShell & s, CRowDouble & x, CRowDouble & y);
    static void IDWCalcBuf(CIDWModelShell & s, CRowDouble & x, CRowDouble & y);
    static void IDWTsCalcBuf(CIDWModelShell & s, CIDWCalcBuffer & buf, CRowDouble & x, CRowDouble & y);
    static void IDWFit(CIDWBuilder & state, CIDWModelShell & model, CIDWReport & rep);
    static double BarycentricCalc(CBarycentricInterpolantShell & b, const double t);
    static void BarycentricDiff1(CBarycentricInterpolantShell & b, const double t, double & f, double & df);
    static void BarycentricDiff2(CBarycentricInterpolantShell & b, const double t, double & f, double & df, double & d2f);
    static void BarycentricLinTransX(CBarycentricInterpolantShell & b, const double ca, const double cb);
    static void BarycentricLinTransY(CBarycentricInterpolantShell & b, const double ca, const double cb);
    static void BarycentricUnpack(CBarycentricInterpolantShell & b, int & n, double & x, double & y, double & w);
    static void BarycentricBuildXYW(double & x, double & y, double & w, const int n, CBarycentricInterpolantShell & b);
    static void BarycentricBuildFloaterHormann(double & x, double & y, const int n, const int d, CBarycentricInterpolantShell & b);
    static void PolynomialBar2Cheb(CBarycentricInterpolantShell & p, const double a, const double b, double & t);
    static void PolynomialCheb2Bar(double & t, const int n, const double a, const double b, CBarycentricInterpolantShell & p);
    static void PolynomialCheb2Bar(double & t, const double a, const double b, CBarycentricInterpolantShell & p);
    static void PolynomialBar2Pow(CBarycentricInterpolantShell & p, const double c, const double s, double & a);
    static void PolynomialBar2Pow(CBarycentricInterpolantShell & p, double & a);
    static void PolynomialPow2Bar(double & a, const int n, const double c, const double s, CBarycentricInterpolantShell & p);
    static void PolynomialPow2Bar(double & a, CBarycentricInterpolantShell & p);
    static void PolynomialBuild(double & x, double & y, const int n, CBarycentricInterpolantShell & p);
    static void PolynomialBuild(double & x, double & y, CBarycentricInterpolantShell & p);
    static void PolynomialBuildEqDist(const double a, const double b, double & y, const int n, CBarycentricInterpolantShell & p);
    static void PolynomialBuildEqDist(const double a, const double b, double & y, CBarycentricInterpolantShell & p);
    static void PolynomialBuildCheb1(const double a, const double b, double & y, const int n, CBarycentricInterpolantShell & p);
    static void PolynomialBuildCheb1(const double a, const double b, double & y, CBarycentricInterpolantShell & p);
    static void PolynomialBuildCheb2(const double a, const double b, double & y, const int n, CBarycentricInterpolantShell & p);
    static void PolynomialBuildCheb2(const double a, const double b, double & y, CBarycentricInterpolantShell & p);
    static double PolynomialCalcEqDist(const double a, const double b, double & f, const int n, const double t);
    static double PolynomialCalcEqDist(const double a, const double b, double & f, const double t);
    static double PolynomialCalcCheb1(const double a, const double b, double & f, const int n, const double t);
    static double PolynomialCalcCheb1(const double a, const double b, double & f, const double t);
    static double PolynomialCalcCheb2(const double a, const double b, double & f, const int n, const double t);
    static double PolynomialCalcCheb2(const double a, const double b, double & f, const double t);
    static void Spline1DBuildLinear(double & x, double & y, const int n, CSpline1DInterpolantShell & c);
    static void Spline1DBuildLinear(double & x, double & y, CSpline1DInterpolantShell & c);
    static void Spline1DBuildCubic(double & x, double & y, const int n, const int boundltype, const double boundl, const int boundrtype, const double boundr, CSpline1DInterpolantShell & c);
    static void Spline1DBuildCubic(double & x, double & y, CSpline1DInterpolantShell & c);
    static void Spline1DGridDiffCubic(double & x, double & y, const int n, const int boundltype, const double boundl, const int boundrtype, const double boundr, double & d);
    static void Spline1DGridDiffCubic(double & x, double & y, double & d);
    static void Spline1DGridDiff2Cubic(double & x, double & y, const int n, const int boundltype, const double boundl, const int boundrtype, const double boundr, double & d1, double & d2);
    static void Spline1DGridDiff2Cubic(double & x, double & y, double & d1, double & d2);
    static void Spline1DConvCubic(double & x, double & y, const int n, const int boundltype, const double boundl, const int boundrtype, const double boundr, double & x2, int n2, double & y2);
    static void Spline1DConvCubic(double & x, double & y, double & x2, double & y2);
    static void Spline1DConvDiffCubic(double & x, double & y, const int n, const int boundltype, const double boundl, const int boundrtype, const double boundr, double & x2, int n2, double & y2, double & d2);
    static void Spline1DConvDiffCubic(double & x, double & y, double & x2, double & y2, double & d2);
    static void Spline1DConvDiff2Cubic(double & x, double & y, const int n, const int boundltype, const double boundl, const int boundrtype, const double boundr, double & x2, const int n2, double & y2, double & d2, double & dd2);
    static void Spline1DConvDiff2Cubic(double & x, double & y, double & x2, double & y2, double & d2, double & dd2);
    static void Spline1DBuildCatmullRom(double & x, double & y, const int n, const int boundtype, const double tension, CSpline1DInterpolantShell & c);
    static void Spline1DBuildCatmullRom(double & x, double & y, CSpline1DInterpolantShell & c);
    static void Spline1DBuildHermite(double & x, double & y, double & d, const int n, CSpline1DInterpolantShell & c);
    static void Spline1DBuildHermite(double & x, double & y, double & d, CSpline1DInterpolantShell & c);
    static void Spline1DBuildAkima(double & x, double & y, const int n, CSpline1DInterpolantShell & c);
    static void Spline1DBuildAkima(double & x, double & y, CSpline1DInterpolantShell & c);
    static double Spline1DCalc(CSpline1DInterpolantShell & c, const double x);
    static void Spline1DDiff(CSpline1DInterpolantShell & c, const double x, double & s, double & ds, double & d2s);
    static void Spline1DUnpack(CSpline1DInterpolantShell & c, int & n, CMatrixDouble & tbl);
    static void Spline1DLinTransX(CSpline1DInterpolantShell & c, const double a, const double b);
    static void Spline1DLinTransY(CSpline1DInterpolantShell & c, const double a, const double b);
    static double Spline1DIntegrate(CSpline1DInterpolantShell & c, const double x);
    static void Spline1DFit(double & x, double & y, int n, int m, double lambdans, CSpline1DInterpolantShell & s, CSpline1DFitReportShell & rep);
    static void Spline1DFit(double & x, double & y, int m, double lambdans, CSpline1DInterpolantShell & s, CSpline1DFitReportShell & rep);
    static void Spline1DBuildMonotone(double & x, double & y, int n, CSpline1DInterpolantShell & c);
    static void Spline1DBuildMonotone(double & x, double & y, CSpline1DInterpolantShell & c);
    static void Spline1DBuildMonotone(CRowDouble & x, CRowDouble & y, CSpline1DInterpolantShell & c);
    static void PolynomialFit(double & x, double & y, const int n, const int m, int & info, CBarycentricInterpolantShell & p, CPolynomialFitReportShell & rep);
    static void PolynomialFit(double & x, double & y, const int m, int & info, CBarycentricInterpolantShell & p, CPolynomialFitReportShell & rep);
    static void PolynomialFitWC(double & x, double & y, double & w, const int n, double & xc, double & yc, int & dc, const int k, const int m, int & info, CBarycentricInterpolantShell & p, CPolynomialFitReportShell & rep);
    static void PolynomialFitWC(double & x, double & y, double & w, double & xc, double & yc, int & dc, const int m, int & info, CBarycentricInterpolantShell & p, CPolynomialFitReportShell & rep);
    static void BarycentricFitFloaterHormannWC(double & x, double & y, double & w, const int n, double & xc, double & yc, int & dc, const int k, const int m, int & info, CBarycentricInterpolantShell & b, CBarycentricFitReportShell & rep);
    static void BarycentricFitFloaterHormann(double & x, double & y, const int n, const int m, int & info, CBarycentricInterpolantShell & b, CBarycentricFitReportShell & rep);
    static void Spline1DFitPenalized(double & x, double & y, const int n, const int m, const double rho, int & info, CSpline1DInterpolantShell & s, CSpline1DFitReportShell & rep);
    static void Spline1DFitPenalized(double & x, double & y, const int m, const double rho, int & info, CSpline1DInterpolantShell & s, CSpline1DFitReportShell & rep);
    static void Spline1DFitPenalizedW(double & x, double & y, double & w, const int n, const int m, const double rho, int & info, CSpline1DInterpolantShell & s, CSpline1DFitReportShell & rep);
    static void Spline1DFitPenalizedW(double & x, double & y, double & w, const int m, const double rho, int & info, CSpline1DInterpolantShell & s, CSpline1DFitReportShell & rep);
    static void Spline1DFitCubicWC(double & x, double & y, double & w, const int n, double & xc, double & yc, int & dc, const int k, const int m, int & info, CSpline1DInterpolantShell & s, CSpline1DFitReportShell & rep);
    static void Spline1DFitCubicWC(double & x, double & y, double & w, double & xc, double & yc, int & dc, const int m, int & info, CSpline1DInterpolantShell & s, CSpline1DFitReportShell & rep);
    static void Spline1DFitHermiteWC(double & x, double & y, double & w, const int n, double & xc, double & yc, int & dc, const int k, const int m, int & info, CSpline1DInterpolantShell & s, CSpline1DFitReportShell & rep);
    static void Spline1DFitHermiteWC(double & x, double & y, double & w, double & xc, double & yc, int & dc, const int m, int & info, CSpline1DInterpolantShell & s, CSpline1DFitReportShell & rep);
    static void Spline1DFitCubic(double & x, double & y, const int n, const int m, int & info, CSpline1DInterpolantShell & s, CSpline1DFitReportShell & rep);
    static void Spline1DFitCubic(double & x, double & y, const int m, int & info, CSpline1DInterpolantShell & s, CSpline1DFitReportShell & rep);
    static void Spline1DFitHermite(double & x, double & y, const int n, const int m, int & info, CSpline1DInterpolantShell & s, CSpline1DFitReportShell & rep);
    static void Spline1DFitHermite(double & x, double & y, const int m, int & info, CSpline1DInterpolantShell & s, CSpline1DFitReportShell & rep);
    static void LSFitLinearW(double & y, double & w, CMatrixDouble & fmatrix, const int n, const int m, int & info, double & c, CLSFitReportShell & rep);
    static void LSFitLinearW(double & y, double & w, CMatrixDouble & fmatrix, int & info, double & c, CLSFitReportShell & rep);
    static void LSFitLinearWC(double & y, double & w, CMatrixDouble & fmatrix, CMatrixDouble & cmatrix, const int n, const int m, const int k, int & info, double & c, CLSFitReportShell & rep);
    static void LSFitLinearWC(double & y, double & w, CMatrixDouble & fmatrix, CMatrixDouble & cmatrix, int & info, double & c, CLSFitReportShell & rep);
    static void LSFitLinear(double & y, CMatrixDouble & fmatrix, const int n, const int m, int & info, double & c, CLSFitReportShell & rep);
    static void LSFitLinear(double & y, CMatrixDouble & fmatrix, int & info, double & c, CLSFitReportShell & rep);
    static void LSFitLinearC(double & y, CMatrixDouble & fmatrix, CMatrixDouble & cmatrix, const int n, const int m, const int k, int & info, double & c, CLSFitReportShell & rep);
    static void LSFitLinearC(double & y, CMatrixDouble & fmatrix, CMatrixDouble & cmatrix, int & info, double & c, CLSFitReportShell & rep);
    static void LSFitCreateWF(CMatrixDouble & x, double & y, double & w, double & c, const int n, const int m, const int k, const double diffstep, CLSFitStateShell & state);
    static void LSFitCreateWF(CMatrixDouble & x, double & y, double & w, double & c, const double diffstep, CLSFitStateShell & state);
    static void LSFitCreateF(CMatrixDouble & x, double & y, double & c, const int n, const int m, const int k, const double diffstep, CLSFitStateShell & state);
    static void LSFitCreateF(CMatrixDouble & x, double & y, double & c, const double diffstep, CLSFitStateShell & state);
    static void LSFitCreateWFG(CMatrixDouble & x, double & y, double & w, double & c, const int n, const int m, const int k, const bool cheapfg, CLSFitStateShell & state);
    static void LSFitCreateWFG(CMatrixDouble & x, double & y, double & w, double & c, const bool cheapfg, CLSFitStateShell & state);
    static void LSFitCreateFG(CMatrixDouble & x, double & y, double & c, const int n, const int m, const int k, const bool cheapfg, CLSFitStateShell & state);
    static void LSFitCreateFG(CMatrixDouble & x, double & y, double & c, const bool cheapfg, CLSFitStateShell & state);
    static void LSFitCreateWFGH(CMatrixDouble & x, double & y, double & w, double & c, const int n, const int m, const int k, CLSFitStateShell & state);
    static void LSFitCreateWFGH(CMatrixDouble & x, double & y, double & w, double & c, CLSFitStateShell & state);
    static void LSFitCreateFGH(CMatrixDouble & x, double & y, double & c, const int n, const int m, const int k, CLSFitStateShell & state);
    static void LSFitCreateFGH(CMatrixDouble & x, double & y, double & c, CLSFitStateShell & state);
    static void LSFitSetCond(CLSFitStateShell & state, const double epsx, const int maxits);
    static void LSFitSetStpMax(CLSFitStateShell & state, const double stpmax);
    static void LSFitSetXRep(CLSFitStateShell & state, const bool needxrep);
    static void LSFitSetScale(CLSFitStateShell & state, double & s);
    static void LSFitSetBC(CLSFitStateShell & state, double & bndl, double & bndu);
    static bool LSFitIteration(CLSFitStateShell & state);
    static void LSFitFit(CLSFitStateShell & state, CNDimensional_PFunc & func, CNDimensional_Rep & rep, bool rep_status, CObject & obj);
    static void LSFitFit(CLSFitStateShell & state, CNDimensional_PFunc & func, CNDimensional_PGrad & grad, CNDimensional_Rep & rep, bool rep_status, CObject & obj);
    static void LSFitFit(CLSFitStateShell & state, CNDimensional_PFunc & func, CNDimensional_PGrad & grad, CNDimensional_PHess & hess, CNDimensional_Rep & rep, bool rep_status, CObject & obj);
    static void LSFitResults(CLSFitStateShell & state, int & info, double & c, CLSFitReportShell & rep);
    static double LogisticCalc4(double x, double a, double b, double c, double d);
    static double LogisticCalc5(double x, double a, double b, double c, double d, double g);
    static void LogisticFit4(CRowDouble & x, CRowDouble & y, int n, double & a, double & b, double & c, double & d, CLSFitReportShell & rep);
    static void LogisticFit4ec(CRowDouble & x, CRowDouble & y, int n, double cnstrleft, double cnstrright, double & a, double & b, double & c, double & d, CLSFitReportShell & rep);
    static void LogisticFit5(CRowDouble & x, CRowDouble & y, int n, double & a, double & b, double & c, double & d, double & g, CLSFitReportShell & rep);
    static void LogisticFit5ec(CRowDouble & x, CRowDouble & y, int n, double cnstrleft, double cnstrright, double & a, double & b, double & c, double & d, double & g, CLSFitReportShell & rep);
    static void LogisticFit45x(CRowDouble & x, CRowDouble & y, int n, double cnstrleft, double cnstrright, bool is4pl, double lambdav, double epsx, int rscnt, double & a, double & b, double & c, double & d, double & g, CLSFitReportShell & rep);
    static void FitSphereLS(CMatrixDouble & xy, int npoints, int nx, CRowDouble & cx, double & r);
    static void FitSphereMC(CMatrixDouble & xy, int npoints, int nx, CRowDouble & cx, double & rhi);
    static void FitSphereMI(CMatrixDouble & xy, int npoints, int nx, CRowDouble & cx, double & rlo);
    static void FitSphereMZ(CMatrixDouble & xy, int npoints, int nx, CRowDouble & cx, double & rlo, double & rhi);
    static void FitSphereX(CMatrixDouble & xy, int npoints, int nx, int problemtype, double epsx, int aulits, double penalty, CRowDouble & cx, double & rlo, double & rhi);
    static void PSpline2Build(CMatrixDouble & xy, const int n, const int st, const int pt, CPSpline2InterpolantShell & p);
    static void PSpline3Build(CMatrixDouble & xy, const int n, const int st, const int pt, CPSpline3InterpolantShell & p);
    static void PSpline2BuildPeriodic(CMatrixDouble & xy, const int n, const int st, const int pt, CPSpline2InterpolantShell & p);
    static void PSpline3BuildPeriodic(CMatrixDouble & xy, const int n, const int st, const int pt, CPSpline3InterpolantShell & p);
    static void PSpline2ParameterValues(CPSpline2InterpolantShell & p, int & n, double & t);
    static void PSpline3ParameterValues(CPSpline3InterpolantShell & p, int & n, double & t);
    static void PSpline2Calc(CPSpline2InterpolantShell & p, const double t, double & x, double & y);
    static void PSpline3Calc(CPSpline3InterpolantShell & p, const double t, double & x, double & y, double & z);
    static void PSpline2Tangent(CPSpline2InterpolantShell & p, const double t, double & x, double & y);
    static void PSpline3Tangent(CPSpline3InterpolantShell & p, const double t, double & x, double & y, double & z);
    static void PSpline2Diff(CPSpline2InterpolantShell & p, const double t, double & x, double & dx, double & y, double & dy);
    static void PSpline3Diff(CPSpline3InterpolantShell & p, const double t, double & x, double & dx, double & y, double & dy, double & z, double & dz);
    static void PSpline2Diff2(CPSpline2InterpolantShell & p, const double t, double & x, double & dx, double & d2x, double & y, double & dy, double & d2y);
    static void PSpline3Diff2(CPSpline3InterpolantShell & p, const double t, double & x, double & dx, double & d2x, double & y, double & dy, double & d2y, double & z, double & dz, double & d2z);
    static double PSpline2ArcLength(CPSpline2InterpolantShell & p, const double a, const double b);
    static double PSpline3ArcLength(CPSpline3InterpolantShell & p, const double a, const double b);
    static void ParametricRDPFixed(CMatrixDouble & x, int n, int d, int stopm, double stopeps, CMatrixDouble & x2, int & idx2, int & nsections);
    static void Spline2DSerialize(CSpline2DInterpolantShell & obj, string & s_out);
    static void Spline2DUnserialize(string s_in, CSpline2DInterpolantShell & obj);
    static double Spline2DCalc(CSpline2DInterpolantShell & c, const double x, const double y);
    static void Spline2DDiff(CSpline2DInterpolantShell & c, const double x, const double y, double & f, double & fx, double & fy, double & fxy);
    static void Spline2DCalcVBuf(CSpline2DInterpolantShell & c, double x, double y, CRowDouble & f);
    static double Spline2DCalcVi(CSpline2DInterpolantShell & c, double x, double y, int i);
    static void Spline2DCalcV(CSpline2DInterpolantShell & c, double x, double y, CRowDouble & f);
    static void Spline2DDiffVi(CSpline2DInterpolantShell & c, double x, double y, int i, double & f, double & fx, double & fy, double & fxy);
    static void Spline2DLinTransXY(CSpline2DInterpolantShell & c, const double ax, const double bx, const double ay, const double by);
    static void Spline2DLinTransF(CSpline2DInterpolantShell & c, const double a, const double b);
    static void Spline2DCopy(CSpline2DInterpolantShell & c, CSpline2DInterpolantShell & cc);
    static void Spline2DResampleBicubic(CMatrixDouble & a, const int oldheight, const int oldwidth, CMatrixDouble & b, const int newheight, const int newwidth);
    static void Spline2DResampleBilinear(CMatrixDouble & a, const int oldheight, const int oldwidth, CMatrixDouble & b, const int newheight, const int newwidth);
    static void Spline2DBuildBilinearV(CRowDouble & x, int n, CRowDouble & y, int m, CRowDouble & f, int d, CSpline2DInterpolantShell & c);
    static void Spline2DBuildBicubicV(CRowDouble & x, int n, CRowDouble & y, int m, CRowDouble & f, int d, CSpline2DInterpolantShell & c);
    static void Spline2DUnpackV(CSpline2DInterpolantShell & c, int & m, int & n, int & d, CMatrixDouble & tbl);
    static void Spline2DBuildBilinear(double & x, double & y, CMatrixDouble & f, const int m, const int n, CSpline2DInterpolantShell & c);
    static void Spline2DBuildBicubic(double & x, double & y, CMatrixDouble & f, const int m, const int n, CSpline2DInterpolantShell & c);
    static void Spline2DUnpack(CSpline2DInterpolantShell & c, int & m, int & n, CMatrixDouble & tbl);
    static void Spline2DBuilderCreate(int d, CSpline2DBuilder & state);
    static void Spline2DBuilderSetUserTerm(CSpline2DBuilder & state, double v);
    static void Spline2DBuilderSetLinTerm(CSpline2DBuilder & state);
    static void Spline2DBuilderSetConstTerm(CSpline2DBuilder & state);
    static void Spline2DBuilderSetZeroTerm(CSpline2DBuilder & state);
    static void Spline2DBuilderSetPoints(CSpline2DBuilder & state, CMatrixDouble & xy, int n);
    static void Spline2DBuilderSetAreaAuto(CSpline2DBuilder & state);
    static void Spline2DBuilderSetArea(CSpline2DBuilder & state, double xa, double xb, double ya, double yb);
    static void Spline2DBuilderSetGrid(CSpline2DBuilder & state, int kx, int ky);
    static void Spline2DBuilderSetAlgoFastDDM(CSpline2DBuilder & state, int nlayers, double lambdav);
    static void Spline2DBuilderSetAlgoBlockLLS(CSpline2DBuilder & state, double lambdans);
    static void Spline2DBuilderSetAlgoNaiveLLS(CSpline2DBuilder & state, double lambdans);
    static void Spline2DFit(CSpline2DBuilder & state, CSpline2DInterpolantShell & s, CSpline2DFitReport & rep);
    static double Spline3DCalc(CSpline3DInterpolant & c, double x, double y, double z);
    static void Spline3DLinTransXYZ(CSpline3DInterpolant & c, double ax, double bx, double ay, double by, double az, double bz);
    static void Spline3DLinTransF(CSpline3DInterpolant & c, double a, double b);
    static void Spline3DResampleTrilinear(CRowDouble & a, int oldzcount, int oldycount, int oldxcount, int newzcount, int newycount, int newxcount, CRowDouble & b);
    static void Spline3DBuildTrilinearV(CRowDouble & x, int n, CRowDouble & y, int m, CRowDouble & z, int l, CRowDouble & f, int d, CSpline3DInterpolant & c);
    static void Spline3DCalcVBuf(CSpline3DInterpolant & c, double x, double y, double z, CRowDouble & f);
    static void Spline3DCalcV(CSpline3DInterpolant & c, double x, double y, double z, CRowDouble & f);
    static void Spline3DUnpackV(CSpline3DInterpolant & c, int & n, int & m, int & l, int & d, int & stype, CMatrixDouble & tbl);
    static void RBFSerialize(CRBFModel & obj, string & s_out);
    static void RBFUnserialize(string s_in, CRBFModel & obj);
    static void RBFCreate(int nx, int ny, CRBFModel & s);
    static void RBFCreateCalcBuffer(CRBFModel & s, CRBFCalcBuffer & buf);
    static void RBFSetPoints(CRBFModel & s, CMatrixDouble & xy, int n);
    static void RBFSetPoints(CRBFModel & s, CMatrixDouble & xy);
    static void RBFSetPointsAndScales(CRBFModel & r, CMatrixDouble & xy, int n, CRowDouble & s);
    static void RBFSetPointsAndScales(CRBFModel & r, CMatrixDouble & xy, CRowDouble & s);
    static void RBFSetAlgoQNN(CRBFModel & s, double q = 1.0, double z = 5.0);
    static void RBFSetAlgoMultilayer(CRBFModel & s, double rbase, int nlayers, double lambdav = 0.01);
    static void RBFSetAlgoHierarchical(CRBFModel & s, double rbase, int nlayers, double lambdans);
    static void RBFSetAlgoThinPlateSpline(CRBFModel & s, double lambdav = 0.0);
    static void RBFSetAlgoMultiQuadricManual(CRBFModel & s, double alpha, double lambdav = 0.0);
    static void RBFSetAlgoMultiQuadricAuto(CRBFModel & s, double lambdav = 0.0);
    static void RBFSetAlgoBiharmonic(CRBFModel & s, double lambdav = 0.0);
    static void RBFSetLinTerm(CRBFModel & s);
    static void RBFSetConstTerm(CRBFModel & s);
    static void RBFSetZeroTerm(CRBFModel & s);
    static void RBFSetV2BF(CRBFModel & s, int bf);
    static void RBFSetV2Its(CRBFModel & s, int maxits);
    static void RBFSetV2SupportR(CRBFModel & s, double r);
    static void RBFBuildModel(CRBFModel & s, CRBFReport & rep);
    static double RBFCalc1(CRBFModel & s, double x0);
    static double RBFCalc2(CRBFModel & s, double x0, double x1);
    static double RBFCalc3(CRBFModel & s, double x0, double x1, double x2);
    static void RBFDiff1(CRBFModel & s, double x0, double & y, double & dy0);
    static void RBFDiff2(CRBFModel & s, double x0, double x1, double & y, double & dy0, double & dy1);
    static void RBFDiff3(CRBFModel & s, double x0, double x1, double x2, double & y, double & dy0, double & dy1, double & dy2);
    static void RBFCalc(CRBFModel & s, CRowDouble & x, CRowDouble & y);
    static void RBFDiff(CRBFModel & s, CRowDouble & x, CRowDouble & y, CRowDouble & dy);
    static void RBFHess(CRBFModel & s, CRowDouble & x, CRowDouble & y, CRowDouble & dy, CRowDouble & d2y);
    static void RBFCalcBuf(CRBFModel & s, CRowDouble & x, CRowDouble & y);
    static void RBFDiffBuf(CRBFModel & s, CRowDouble & x, CRowDouble & y, CRowDouble & dy);
    static void RBFHessBuf(CRBFModel & s, CRowDouble & x, CRowDouble & y, CRowDouble & dy, CRowDouble & d2y);
    static void RBFTSCalcBuf(CRBFModel & s, CRBFCalcBuffer & buf, CRowDouble & x, CRowDouble & y);
    static void RBFTSDiffBuf(CRBFModel & s, CRBFCalcBuffer & buf, CRowDouble & x, CRowDouble & y, CRowDouble & dy);
    static void RBFTSHessBuf(CRBFModel & s, CRBFCalcBuffer & buf, CRowDouble & x, CRowDouble & y, CRowDouble & dy, CRowDouble & d2y);
    static void RBFGridCalc2(CRBFModel & s, CRowDouble & x0, int n0, CRowDouble & x1, int n1, CMatrixDouble & y);
    static void RBFGridCalc2V(CRBFModel & s, CRowDouble & x0, int n0, CRowDouble & x1, int n1, CRowDouble & y);
    static void RBFGridCalc2VSubset(CRBFModel & s, CRowDouble & x0, int n0, CRowDouble & x1, int n1, bool & flagy, CRowDouble & y);
    static void RBFGridCalc3V(CRBFModel & s, CRowDouble & x0, int n0, CRowDouble & x1, int n1, CRowDouble & x2, int n2, CRowDouble & y);
    static void RBFGridCalc3VSubset(CRBFModel & s, CRowDouble & x0, int n0, CRowDouble & x1, int n1, CRowDouble & x2, int n2, bool & flagy, CRowDouble & y);
    static void RBFUnpack(CRBFModel & s, int & nx, int & ny, CMatrixDouble & xwr, int & nc, CMatrixDouble & v, int & modelversion);
    static int RBFGetModelVersion(CRBFModel & s);
    static double RBFPeekProgress(CRBFModel & s);
    static void RBFRequestTermination(CRBFModel & s);
    static void CMatrixTranspose(const int m, const int n, CMatrixComplex & a, const int ia, const int ja, CMatrixComplex & b, const int ib, const int jb);
    static void RMatrixTranspose(const int m, const int n, CMatrixDouble & a, const int ia, const int ja, CMatrixDouble & b, const int ib, const int jb);
    static void RMatrixEnforceSymmetricity(CMatrixDouble & a, int n, bool IsUpper);
    static void CMatrixCopy(const int m, const int n, CMatrixComplex & a, const int ia, const int ja, CMatrixComplex & b, const int ib, const int jb);
    static void RVectorCopy(int n, CRowDouble & a, int ia, CRowDouble & b, int ib);
    static void RMatrixCopy(const int m, const int n, CMatrixDouble & a, const int ia, const int ja, CMatrixDouble & b, const int ib, const int jb);
    static void RMatrixGenCopy(int m, int n, double alpha, CMatrixDouble & a, int ia, int ja, double beta, CMatrixDouble & b, int ib, int jb);
    static void RMatrixGer(int m, int n, CMatrixDouble & a, int ia, int ja, double alpha, CRowDouble & u, int iu, CRowDouble & v, int iv);
    static void CMatrixRank1(const int m, const int n, CMatrixComplex & a, const int ia, const int ja, complex & u, const int iu, complex & v, const int iv);
    static void RMatrixRank1(const int m, const int n, CMatrixDouble & a, const int ia, const int ja, double & u, const int iu, double & v, const int iv);
    static void RMatrixGemVect(int m, int n, double alpha, CMatrixDouble & a, int ia, int ja, int opa, CRowDouble & x, int ix, double beta, CRowDouble & y, int iy);
    static void CMatrixMVect(const int m, const int n, CMatrixComplex & a, const int ia, const int ja, const int opa, complex & x, const int ix, complex & y, const int iy);
    static void RMatrixMVect(const int m, const int n, CMatrixDouble & a, const int ia, const int ja, const int opa, double & x, const int ix, double & y, const int iy);
    static void RMatrixSymVect(int n, double alpha, CMatrixDouble & a, int ia, int ja, bool IsUpper, CRowDouble & x, int ix, double beta, CRowDouble & y, int iy);
    static double RMatrixSyvMVect(int n, CMatrixDouble & a, int ia, int ja, bool IsUpper, CRowDouble & x, int ix, CRowDouble & tmp);
    static void RMatrixTrsVect(int n, CMatrixDouble & a, int ia, int ja, bool IsUpper, bool IsUnit, int OpType, CRowDouble & x, int ix);
    static void CMatrixRightTrsM(const int m, const int n, CMatrixComplex & a, const int i1, const int j1, const bool IsUpper, const bool IsUnit, const int OpType, CMatrixComplex & x, const int i2, const int j2);
    static void CMatrixLeftTrsM(const int m, const int n, CMatrixComplex & a, const int i1, const int j1, const bool IsUpper, const bool IsUnit, const int OpType, CMatrixComplex & x, const int i2, const int j2);
    static void RMatrixRightTrsM(const int m, const int n, CMatrixDouble & a, const int i1, const int j1, const bool IsUpper, const bool IsUnit, const int OpType, CMatrixDouble & x, const int i2, const int j2);
    static void RMatrixLeftTrsM(const int m, const int n, CMatrixDouble & a, const int i1, const int j1, const bool IsUpper, const bool IsUnit, const int OpType, CMatrixDouble & x, const int i2, const int j2);
    static void CMatrixSyrk(const int n, const int k, const double alpha, CMatrixComplex & a, const int ia, const int ja, const int optypea, const double beta, CMatrixComplex & c, const int ic, const int jc, const bool IsUpper);
    static void RMatrixSyrk(const int n, const int k, const double alpha, CMatrixDouble & a, const int ia, const int ja, const int optypea, const double beta, CMatrixDouble & c, const int ic, const int jc, const bool IsUpper);
    static void CMatrixGemm(const int m, const int n, const int k, complex alpha, CMatrixComplex & a, const int ia, const int ja, const int optypea, CMatrixComplex & b, const int ib, const int jb, const int optypeb, complex beta, CMatrixComplex & c, const int ic, const int jc);
    static void RMatrixGemm(const int m, const int n, const int k, const double alpha, CMatrixDouble & a, const int ia, const int ja, const int optypea, CMatrixDouble & b, const int ib, const int jb, const int optypeb, const double beta, CMatrixDouble & c, const int ic, const int jc);
    static void RMatrixQR(CMatrixDouble & a, const int m, const int n, double & tau);
    static void RMatrixLQ(CMatrixDouble & a, const int m, const int n, double & tau);
    static void CMatrixQR(CMatrixComplex & a, const int m, const int n, complex & tau);
    static void CMatrixLQ(CMatrixComplex & a, const int m, const int n, complex & tau);
    static void RMatrixQRUnpackQ(CMatrixDouble & a, const int m, const int n, double & tau, const int qcolumns, CMatrixDouble & q);
    static void RMatrixQRUnpackR(CMatrixDouble & a, const int m, const int n, CMatrixDouble & r);
    static void RMatrixLQUnpackQ(CMatrixDouble & a, const int m, const int n, double & tau, const int qrows, CMatrixDouble & q);
    static void RMatrixLQUnpackL(CMatrixDouble & a, const int m, const int n, CMatrixDouble & l);
    static void CMatrixQRUnpackQ(CMatrixComplex & a, const int m, const int n, complex & tau, const int qcolumns, CMatrixComplex & q);
    static void CMatrixQRUnpackR(CMatrixComplex & a, const int m, const int n, CMatrixComplex & r);
    static void CMatrixLQUnpackQ(CMatrixComplex & a, const int m, const int n, complex & tau, const int qrows, CMatrixComplex & q);
    static void CMatrixLQUnpackL(CMatrixComplex & a, const int m, const int n, CMatrixComplex & l);
    static void RMatrixBD(CMatrixDouble & a, const int m, const int n, double & tauq, double & taup);
    static void RMatrixBDUnpackQ(CMatrixDouble & qp, const int m, const int n, double & tauq, const int qcolumns, CMatrixDouble & q);
    static void RMatrixBDMultiplyByQ(CMatrixDouble & qp, const int m, const int n, double & tauq, CMatrixDouble & z, const int zrows, const int zcolumns, const bool fromtheright, const bool dotranspose);
    static void RMatrixBDUnpackPT(CMatrixDouble & qp, const int m, const int n, double & taup, const int ptrows, CMatrixDouble & pt);
    static void RMatrixBDMultiplyByP(CMatrixDouble & qp, const int m, const int n, double & taup, CMatrixDouble & z, const int zrows, const int zcolumns, const bool fromtheright, const bool dotranspose);
    static void RMatrixBDUnpackDiagonals(CMatrixDouble & b, const int m, const int n, bool & IsUpper, double & d, double & e);
    static void RMatrixHessenberg(CMatrixDouble & a, const int n, double & tau);
    static void RMatrixHessenbergUnpackQ(CMatrixDouble & a, const int n, double & tau, CMatrixDouble & q);
    static void RMatrixHessenbergUnpackH(CMatrixDouble & a, const int n, CMatrixDouble & h);
    static void SMatrixTD(CMatrixDouble & a, const int n, const bool IsUpper, double & tau, double & d, double & e);
    static void SMatrixTDUnpackQ(CMatrixDouble & a, const int n, const bool IsUpper, double & tau, CMatrixDouble & q);
    static void HMatrixTD(CMatrixComplex & a, const int n, const bool IsUpper, complex & tau, double & d, double & e);
    static void HMatrixTDUnpackQ(CMatrixComplex & a, const int n, const bool IsUpper, complex & tau, CMatrixComplex & q);
    static void EigSubSpaceCreate(int n, int k, CEigSubSpaceState & state);
    static void EigSubSpaceCreateBuf(int n, int k, CEigSubSpaceState & state);
    static void EigSubSpaceSetCond(CEigSubSpaceState & state, double eps, int maxits);
    static void EigSubSpaceSetWarmStart(CEigSubSpaceState & state, bool usewarmstart);
    static void EigSubSpaceOOCStart(CEigSubSpaceState & state, int mtype);
    static bool EigSubSpaceOOCContinue(CEigSubSpaceState & state);
    static void EigSubSpaceOOCGetRequestInfo(CEigSubSpaceState & state, int & requesttype, int & requestsize);
    static void EigSubSpaceOOCGetRequestData(CEigSubSpaceState & state, CMatrixDouble & x);
    static void EigSubSpaceOOCSendResult(CEigSubSpaceState & state, CMatrixDouble & ax);
    static void EigSubSpaceOOCStop(CEigSubSpaceState & state, CRowDouble & w, CMatrixDouble & z, CEigSubSpaceReport & rep);
    static void EigSubSpaceSolveDenses(CEigSubSpaceState & state, CMatrixDouble & a, bool IsUpper, CRowDouble & w, CMatrixDouble & z, CEigSubSpaceReport & rep);
    static void EigSubSpaceSolveSparses(CEigSubSpaceState & state, CSparseMatrix & a, bool IsUpper, CRowDouble & w, CMatrixDouble & z, CEigSubSpaceReport & rep);
    static bool SMatrixEVD(CMatrixDouble & a, const int n, int zneeded, const bool IsUpper, double & d, CMatrixDouble & z);
    static bool SMatrixEVDR(CMatrixDouble & a, const int n, int zneeded, const bool IsUpper, double b1, double b2, int & m, double & w, CMatrixDouble & z);
    static bool SMatrixEVDI(CMatrixDouble & a, const int n, int zneeded, const bool IsUpper, const int i1, const int i2, double & w, CMatrixDouble & z);
    static bool HMatrixEVD(CMatrixComplex & a, const int n, const int zneeded, const bool IsUpper, double & d, CMatrixComplex & z);
    static bool HMatrixEVDR(CMatrixComplex & a, const int n, const int zneeded, const bool IsUpper, double b1, double b2, int & m, double & w, CMatrixComplex & z);
    static bool HMatrixEVDI(CMatrixComplex & a, const int n, const int zneeded, const bool IsUpper, const int i1, const int i2, double & w, CMatrixComplex & z);
    static bool SMatrixTdEVD(double & d, double & e, const int n, const int zneeded, CMatrixDouble & z);
    static bool SMatrixTdEVDR(double & d, double & e, const int n, const int zneeded, const double a, const double b, int & m, CMatrixDouble & z);
    static bool SMatrixTdEVDI(double & d, double & e, const int n, const int zneeded, const int i1, const int i2, CMatrixDouble & z);
    static bool RMatrixEVD(CMatrixDouble & a, const int n, const int vneeded, double & wr, double & wi, CMatrixDouble & vl, CMatrixDouble & vr);
    static void RMatrixRndOrthogonal(const int n, CMatrixDouble & a);
    static void RMatrixRndCond(const int n, const double c, CMatrixDouble & a);
    static void CMatrixRndOrthogonal(const int n, CMatrixComplex & a);
    static void CMatrixRndCond(const int n, const double c, CMatrixComplex & a);
    static void SMatrixRndCond(const int n, const double c, CMatrixDouble & a);
    static void SPDMatrixRndCond(const int n, const double c, CMatrixDouble & a);
    static void HMatrixRndCond(const int n, const double c, CMatrixComplex & a);
    static void HPDMatrixRndCond(const int n, const double c, CMatrixComplex & a);
    static void RMatrixRndOrthogonalFromTheRight(CMatrixDouble & a, const int m, const int n);
    static void RMatrixRndOrthogonalFromTheLeft(CMatrixDouble & a, const int m, const int n);
    static void CMatrixRndOrthogonalFromTheRight(CMatrixComplex & a, const int m, const int n);
    static void CMatrixRndOrthogonalFromTheLeft(CMatrixComplex & a, const int m, const int n);
    static void SMatrixRndMultiply(CMatrixDouble & a, const int n);
    static void HMatrixRndMultiply(CMatrixComplex & a, const int n);
    static void SparseSerialize(CSparseMatrix & obj, string & s_out);
    static void SparseUunserialize(string s_in, CSparseMatrix & obj);
    static void SparseCreate(int m, int n, int k, CSparseMatrix & s);
    static void SparseCreate(int m, int n, CSparseMatrix & s);
    static void SparseCreateBuf(int m, int n, int k, CSparseMatrix & s);
    static void SparseCreateBuf(int m, int n, CSparseMatrix & s);
    static void SparseCreateCRS(int m, int n, CRowInt & ner, CSparseMatrix & s);
    static void SparseCreateCRS(int m, int n, int & ner, CSparseMatrix & s);
    static void SparseCreateCRSBuf(int m, int n, CRowInt & ner, CSparseMatrix & s);
    static void SparseCreateCRSBuf(int m, int n, int & ner, CSparseMatrix & s);
    static void SparseCreateSKS(int m, int n, CRowInt & d, CRowInt & u, CSparseMatrix & s);
    static void SparseCreateSKS(int m, int n, int & d, int & u, CSparseMatrix & s);
    static void SparseCreateSKSBuf(int m, int n, CRowInt & d, CRowInt & u, CSparseMatrix & s);
    static void SparseCreateSKSBuf(int m, int n, int & d, int & u, CSparseMatrix & s);
    static void SparseCreateSKSBand(int m, int n, int bw, CSparseMatrix & s);
    static void SparseCreateSKSBandBuf(int m, int n, int bw, CSparseMatrix & s);
    static void SparseCopy(CSparseMatrix & s0, CSparseMatrix & s1);
    static void SparseCopyBuf(CSparseMatrix & s0, CSparseMatrix & s1);
    static void SparseSwap(CSparseMatrix & s0, CSparseMatrix & s1);
    static void SparseAdd(CSparseMatrix & s, int i, int j, double v);
    static void SparseSet(CSparseMatrix & s, int i, int j, double v);
    static double SparseGet(CSparseMatrix & s, int i, int j);
    static bool SparseExists(CSparseMatrix & s, int i, int j);
    static double SparseGetDiagonal(CSparseMatrix & s, int i);
    static void SparseMV(CSparseMatrix & s, CRowDouble & x, CRowDouble & y);
    static void SparseMTV(CSparseMatrix & s, CRowDouble & x, CRowDouble & y);
    static void SparseGemV(CSparseMatrix & s, double alpha, int ops, CRowDouble & x, int ix, double beta, CRowDouble & y, int iy);
    static void SparseMV2(CSparseMatrix & s, CRowDouble & x, CRowDouble & y0, CRowDouble & y1);
    static void SparseSMV(CSparseMatrix & s, bool IsUpper, CRowDouble & x, CRowDouble & y);
    static double SparseVSMV(CSparseMatrix & s, bool IsUpper, CRowDouble & x);
    static void SparseMM(CSparseMatrix & s, CMatrixDouble & a, int k, CMatrixDouble & b);
    static void SparseMTM(CSparseMatrix & s, CMatrixDouble & a, int k, CMatrixDouble & b);
    static void SparseMM2(CSparseMatrix & s, CMatrixDouble & a, int k, CMatrixDouble & b0, CMatrixDouble & b1);
    static void SparseSMM(CSparseMatrix & s, bool IsUpper, CMatrixDouble & a, int k, CMatrixDouble & b);
    static void SparseTRMV(CSparseMatrix & s, bool IsUpper, bool IsUnit, int OpType, CRowDouble & x, CRowDouble & y);
    static void SparseTRSV(CSparseMatrix & s, bool IsUpper, bool IsUnit, int OpType, CRowDouble & x);
    static void SparseSymmPermTbl(CSparseMatrix & a, bool IsUpper, CRowInt & p, CSparseMatrix & b);
    static void SparseSymmPermTblBuf(CSparseMatrix & a, bool IsUpper, CRowInt & p, CSparseMatrix & b);
    static void SparseResizeMatrix(CSparseMatrix & s);
    static bool SparseEnumerate(CSparseMatrix & s, int & t0, int & t1, int & i, int & j, double & v);
    static bool SparseRewriteExisting(CSparseMatrix & s, int i, int j, double v);
    static void SparseGetRow(CSparseMatrix & s, int i, CRowDouble & irow);
    static void SparseGetCompressedRow(CSparseMatrix & s, int i, CRowInt & colidx, CRowDouble & vals, int & nzcnt);
    static void SparseTransposeSKS(CSparseMatrix & s);
    static void SparseTransposeCRS(CSparseMatrix & s);
    static void SparseCopyTransposeCRS(CSparseMatrix & s0, CSparseMatrix & s1);
    static void SparseCopyTransposeCRSBuf(CSparseMatrix & s0, CSparseMatrix & s1);
    static void SparseConvertTo(CSparseMatrix & s0, int fmt);
    static void SparseCopyToBuf(CSparseMatrix & s0, int fmt, CSparseMatrix & s1);
    static void SparseConvertToHash(CSparseMatrix & s);
    static void SparseCopyToHash(CSparseMatrix & s0, CSparseMatrix & s1);
    static void SparseCopyToHashBuf(CSparseMatrix & s0, CSparseMatrix & s1);
    static void SparseConvertToCRS(CSparseMatrix & s);
    static void SparseCopyToCRS(CSparseMatrix & s0, CSparseMatrix & s1);
    static void SparseCopyToCRSBuf(CSparseMatrix & s0, CSparseMatrix & s1);
    static void SparseConvertToSKS(CSparseMatrix & s);
    static void SparseCopyToSKS(CSparseMatrix & s0, CSparseMatrix & s1);
    static void SparseCopyToSKSBuf(CSparseMatrix & s0, CSparseMatrix & s1);
    static int SparseGetMatrixType(CSparseMatrix & s);
    static bool SparseIsHash(CSparseMatrix & s);
    static bool SparseIsCRS(CSparseMatrix & s);
    static bool SparseIsSKS(CSparseMatrix & s);
    static void SparseFree(CSparseMatrix & s);
    static int SparseGetNRows(CSparseMatrix & s);
    static int SparseGetNCols(CSparseMatrix & s);
    static int SparseGetUpperCount(CSparseMatrix & s);
    static int SparseGetLowerCount(CSparseMatrix & s);
    static void RMatrixLU(CMatrixDouble & a, const int m, const int n, int & pivots);
    static void CMatrixLU(CMatrixComplex & a, const int m, const int n, int & pivots);
    static bool HPDMatrixCholesky(CMatrixComplex & a, const int n, const bool IsUpper);
    static bool SPDMatrixCholesky(CMatrixDouble & a, const int n, const bool IsUpper);
    static void SPDMatrixCholeskyUpdateAdd1(CMatrixDouble & a, int n, bool IsUpper, CRowDouble & u);
    static void SPDMatrixCholeskyUpdateFix(CMatrixDouble & a, int n, bool IsUpper, bool & fix);
    static void SPDMatrixCholeskyUpdateAdd1Buf(CMatrixDouble & a, int n, bool IsUpper, CRowDouble & u, CRowDouble & bufr);
    static void SPDMatrixCholeskyUpdateFixBuf(CMatrixDouble & a, int n, bool IsUpper, bool & fix, CRowDouble & bufr);
    static bool SparseLU(CSparseMatrix & a, int pivottype, CRowInt & p, CRowInt & q);
    static bool SparseCholeskySkyLine(CSparseMatrix & a, int n, bool IsUpper);
    static bool SparseCholesky(CSparseMatrix & a, bool IsUpper);
    static bool SparseCholeskyP(CSparseMatrix & a, bool IsUpper, CRowInt & p);
    static bool sparsecholeskyanalyze(CSparseMatrix & a, bool IsUpper, int facttype, int permtype, CSparseDecompositionAnalysis & analysis);
    static bool SparseCholeskyFactorize(CSparseDecompositionAnalysis & analysis, bool needupper, CSparseMatrix & a, CRowDouble & d, CRowInt & p);
    static void SparseCholeskyReload(CSparseDecompositionAnalysis & analysis, CSparseMatrix & a, bool IsUpper);
    static double RMatrixRCond1(CMatrixDouble & a, const int n);
    static double RMatrixRCondInf(CMatrixDouble & a, const int n);
    static double SPDMatrixRCond(CMatrixDouble & a, const int n, const bool IsUpper);
    static double RMatrixTrRCond1(CMatrixDouble & a, const int n, const bool IsUpper, const bool IsUnit);
    static double RMatrixTrRCondInf(CMatrixDouble & a, const int n, const bool IsUpper, const bool IsUnit);
    static double HPDMatrixRCond(CMatrixComplex & a, const int n, const bool IsUpper);
    static double CMatrixRCond1(CMatrixComplex & a, const int n);
    static double CMatrixRCondInf(CMatrixComplex & a, const int n);
    static double RMatrixLURCond1(CMatrixDouble & lua, const int n);
    static double RMatrixLURCondInf(CMatrixDouble & lua, const int n);
    static double SPDMatrixCholeskyRCond(CMatrixDouble & a, const int n, const bool IsUpper);
    static double HPDMatrixCholeskyRCond(CMatrixComplex & a, const int n, const bool IsUpper);
    static double CMatrixLURCond1(CMatrixComplex & lua, const int n);
    static double CMatrixLURCondInf(CMatrixComplex & lua, const int n);
    static double CMatrixTrRCond1(CMatrixComplex & a, const int n, const bool IsUpper, const bool IsUnit);
    static double CMatrixTrRCondInf(CMatrixComplex & a, const int n, const bool IsUpper, const bool IsUnit);
    static void NormEstimatorCreate(int m, int n, int nstart, int nits, CNormEstimatorState & state);
    static void NormEstimatorSetSeed(CNormEstimatorState & state, int seedval);
    static void NormEstimatorEstimateSparse(CNormEstimatorState & state, CSparseMatrix & a);
    static void NormEstimatorResults(CNormEstimatorState & state, double & nrm);
    static void RMatrixLUInverse(CMatrixDouble & a, int & pivots, const int n, int & info, CMatInvReportShell & rep);
    static void RMatrixLUInverse(CMatrixDouble & a, int & pivots, int & info, CMatInvReportShell & rep);
    static void RMatrixInverse(CMatrixDouble & a, const int n, int & info, CMatInvReportShell & rep);
    static void RMatrixInverse(CMatrixDouble & a, int & info, CMatInvReportShell & rep);
    static void CMatrixLUInverse(CMatrixComplex & a, int & pivots, const int n, int & info, CMatInvReportShell & rep);
    static void CMatrixLUInverse(CMatrixComplex & a, int & pivots, int & info, CMatInvReportShell & rep);
    static void CMatrixInverse(CMatrixComplex & a, const int n, int & info, CMatInvReportShell & rep);
    static void CMatrixInverse(CMatrixComplex & a, int & info, CMatInvReportShell & rep);
    static void SPDMatrixCholeskyInverse(CMatrixDouble & a, const int n, const bool IsUpper, int & info, CMatInvReportShell & rep);
    static void SPDMatrixCholeskyInverse(CMatrixDouble & a, int & info, CMatInvReportShell & rep);
    static void SPDMatrixInverse(CMatrixDouble & a, const int n, const bool IsUpper, int & info, CMatInvReportShell & rep);
    static void SPDMatrixInverse(CMatrixDouble & a, int & info, CMatInvReportShell & rep);
    static void HPDMatrixCholeskyInverse(CMatrixComplex & a, const int n, const bool IsUpper, int & info, CMatInvReportShell & rep);
    static void HPDMatrixCholeskyInverse(CMatrixComplex & a, int & info, CMatInvReportShell & rep);
    static void HPDMatrixInverse(CMatrixComplex & a, const int n, const bool IsUpper, int & info, CMatInvReportShell & rep);
    static void HPDMatrixInverse(CMatrixComplex & a, int & info, CMatInvReportShell & rep);
    static void RMatrixTrInverse(CMatrixDouble & a, const int n, const bool IsUpper, const bool IsUnit, int & info, CMatInvReportShell & rep);
    static void RMatrixTrInverse(CMatrixDouble & a, const bool IsUpper, int & info, CMatInvReportShell & rep);
    static void CMatrixTrInverse(CMatrixComplex & a, const int n, const bool IsUpper, const bool IsUnit, int & info, CMatInvReportShell & rep);
    static void CMatrixTrInverse(CMatrixComplex & a, const bool IsUpper, int & info, CMatInvReportShell & rep);
    static bool RMatrixBdSVD(double & d, double & e, const int n, const bool IsUpper, bool isfractionalaccuracyrequired, CMatrixDouble & u, const int nru, CMatrixDouble & c, const int ncc, CMatrixDouble & vt, const int ncvt);
    static bool RMatrixSVD(CMatrixDouble & a, const int m, const int n, const int uneeded, const int vtneeded, const int additionalmemory, double & w, CMatrixDouble & u, CMatrixDouble & vt);
    static double RMatrixLUDet(CMatrixDouble & a, int & pivots, const int n);
    static double RMatrixLUDet(CMatrixDouble & a, int & pivots);
    static double RMatrixDet(CMatrixDouble & a, const int n);
    static double RMatrixDet(CMatrixDouble & a);
    static complex CMatrixLUDet(CMatrixComplex & a, int & pivots, const int n);
    static complex CMatrixLUDet(CMatrixComplex & a, int & pivots);
    static complex CMatrixDet(CMatrixComplex & a, const int n);
    static complex CMatrixDet(CMatrixComplex & a);
    static double SPDMatrixCholeskyDet(CMatrixDouble & a, const int n);
    static double SPDMatrixCholeskyDet(CMatrixDouble & a);
    static double SPDMatrixDet(CMatrixDouble & a, const int n, const bool IsUpper);
    static double SPDMatrixDet(CMatrixDouble & a);
    static bool SMatrixGEVD(CMatrixDouble & a, const int n, const bool isuppera, CMatrixDouble & b, const bool isupperb, const int zneeded, const int problemtype, double & d, CMatrixDouble & z);
    static bool SMatrixGEVDReduce(CMatrixDouble & a, const int n, const bool isuppera, CMatrixDouble & b, const bool isupperb, const int problemtype, CMatrixDouble & r, bool & isupperr);
    static void RMatrixInvUpdateSimple(CMatrixDouble & inva, const int n, const int updrow, const int updcolumn, const double updval);
    static void RMatrixInvUpdateRow(CMatrixDouble & inva, const int n, const int updrow, double & v);
    static void RMatrixInvUpdateColumn(CMatrixDouble & inva, const int n, const int updcolumn, double & u);
    static void RMatrixInvUpdateUV(CMatrixDouble & inva, const int n, double & u, double & v);
    static bool RMatrixSchur(CMatrixDouble & a, const int n, CMatrixDouble & s);
    static void MinCGCreate(const int n, double & x, CMinCGStateShell & state);
    static void MinCGCreate(double & x, CMinCGStateShell & state);
    static void MinCGCreateF(const int n, double & x, double diffstep, CMinCGStateShell & state);
    static void MinCGCreateF(double & x, double diffstep, CMinCGStateShell & state);
    static void MinCGSetCond(CMinCGStateShell & state, double epsg, double epsf, double epsx, int maxits);
    static void MinCGSetScale(CMinCGStateShell & state, double & s);
    static void MinCGSetXRep(CMinCGStateShell & state, bool needxrep);
    static void MinCGSetCGType(CMinCGStateShell & state, int cgtype);
    static void MinCGSetStpMax(CMinCGStateShell & state, double stpmax);
    static void MinCGSuggestStep(CMinCGStateShell & state, double stp);
    static void MinCGSetPrecDefault(CMinCGStateShell & state);
    static void MinCGSetPrecDiag(CMinCGStateShell & state, double & d);
    static void MinCGSetPrecScale(CMinCGStateShell & state);
    static bool MinCGIteration(CMinCGStateShell & state);
    static void MinCGOptimize(CMinCGStateShell & state, CNDimensional_Func & func, CNDimensional_Rep & rep, bool rep_status, CObject & obj);
    static void MinCGOptimize(CMinCGStateShell & state, CNDimensional_Grad & grad, CNDimensional_Rep & rep, bool rep_status, CObject & obj);
    static void MinCGResults(CMinCGStateShell & state, double & x, CMinCGReportShell & rep);
    static void MinCGResultsBuf(CMinCGStateShell & state, double & x, CMinCGReportShell & rep);
    static void MinCGRestartFrom(CMinCGStateShell & state, double & x);
    static void MinLBFGSRequestTermination(CMinLBFGSStateShell & state);
    static void MinBLEICCreate(const int n, double & x, CMinBLEICStateShell & state);
    static void MinBLEICCreate(double & x, CMinBLEICStateShell & state);
    static void MinBLEICCreateF(const int n, double & x, double diffstep, CMinBLEICStateShell & state);
    static void MinBLEICCreateF(double & x, double diffstep, CMinBLEICStateShell & state);
    static void MinBLEICSetBC(CMinBLEICStateShell & state, double & bndl, double & bndu);
    static void MinBLEICSetLC(CMinBLEICStateShell & state, CMatrixDouble & c, int & ct, const int k);
    static void MinBLEICSetLC(CMinBLEICStateShell & state, CMatrixDouble & c, int & ct);
    static void MinBLEICSetInnerCond(CMinBLEICStateShell & state, const double epsg, const double epsf, const double epsx);
    static void MinBLEICSetOuterCond(CMinBLEICStateShell & state, const double epsx, const double epsi);
    static void MinBLEICSetScale(CMinBLEICStateShell & state, double & s);
    static void MinBLEICSetPrecDefault(CMinBLEICStateShell & state);
    static void MinBLEICSetPrecDiag(CMinBLEICStateShell & state, double & d);
    static void MinBLEICSetPrecScale(CMinBLEICStateShell & state);
    static void MinBLEICSetMaxIts(CMinBLEICStateShell & state, const int maxits);
    static void MinBLEICSetXRep(CMinBLEICStateShell & state, bool needxrep);
    static void MinBLEICSetStpMax(CMinBLEICStateShell & state, double stpmax);
    static bool MinBLEICIteration(CMinBLEICStateShell & state);
    static void MinBLEICOptimize(CMinBLEICStateShell & state, CNDimensional_Func & func, CNDimensional_Rep & rep, bool rep_status, CObject & obj);
    static void MinBLEICOptimize(CMinBLEICStateShell & state, CNDimensional_Grad & grad, CNDimensional_Rep & rep, bool rep_status, CObject & obj);
    static void MinBLEICOptGuardGradient(CMinBLEICStateShell & state, double teststep);
    static void MinBLEICOptGuardSmoothness(CMinBLEICStateShell & state, int level = 1);
    static void MinBLEICOptGuardResults(CMinBLEICStateShell & state, COptGuardReport & rep);
    static void MinBLEICOptGuardNonC1Test0Results(CMinBLEICStateShell & state, COptGuardNonC1Test0Report & strrep, COptGuardNonC1Test0Report & lngrep);
    static void MinBLEICOptGuardNonC1Test1Results(CMinBLEICStateShell & state, COptGuardNonC1Test1Report & strrep, COptGuardNonC1Test1Report & lngrep);
    static void MinBLEICResults(CMinBLEICStateShell & state, double & x, CMinBLEICReportShell & rep);
    static void MinBLEICResultsBuf(CMinBLEICStateShell & state, double & x, CMinBLEICReportShell & rep);
    static void MinBLEICRestartFrom(CMinBLEICStateShell & state, double & x);
    static void MinBLEICRequestTermination(CMinBLEICStateShell & state);
    static void MinLBFGSCreate(const int n, const int m, double & x, CMinLBFGSStateShell & state);
    static void MinLBFGSCreate(const int m, double & x, CMinLBFGSStateShell & state);
    static void MinLBFGSCreateF(const int n, const int m, double & x, const double diffstep, CMinLBFGSStateShell & state);
    static void MinLBFGSCreateF(const int m, double & x, const double diffstep, CMinLBFGSStateShell & state);
    static void MinLBFGSSetCond(CMinLBFGSStateShell & state, const double epsg, const double epsf, const double epsx, const int maxits);
    static void MinLBFGSSetXRep(CMinLBFGSStateShell & state, const bool needxrep);
    static void MinLBFGSSetStpMax(CMinLBFGSStateShell & state, const double stpmax);
    static void MinLBFGSSetScale(CMinLBFGSStateShell & state, double & s);
    static void MinLBFGSSetPrecDefault(CMinLBFGSStateShell & state);
    static void MinLBFGSSetPrecCholesky(CMinLBFGSStateShell & state, CMatrixDouble & p, const bool IsUpper);
    static void MinLBFGSSetPrecDiag(CMinLBFGSStateShell & state, double & d);
    static void MinLBFGSSetPrecScale(CMinLBFGSStateShell & state);
    static bool MinLBFGSIteration(CMinLBFGSStateShell & state);
    static void MinLBFGSOptimize(CMinLBFGSStateShell & state, CNDimensional_Func & func, CNDimensional_Rep & rep, bool rep_status, CObject & obj);
    static void MinLBFGSOptimize(CMinLBFGSStateShell & state, CNDimensional_Grad & grad, CNDimensional_Rep & rep, bool rep_status, CObject & obj);
    static void MinLBFGSResults(CMinLBFGSStateShell & state, double & x, CMinLBFGSReportShell & rep);
    static void MinLBFGSresultsbuf(CMinLBFGSStateShell & state, double & x, CMinLBFGSReportShell & rep);
    static void MinLBFGSRestartFrom(CMinLBFGSStateShell & state, double & x);
    static void MinQPCreate(const int n, CMinQPStateShell & state);
    static void MinQPSetLinearTerm(CMinQPStateShell & state, double & b);
    static void MinQPSetQuadraticTerm(CMinQPStateShell & state, CMatrixDouble & a, const bool IsUpper);
    static void MinQPSetQuadraticTerm(CMinQPStateShell & state, CMatrixDouble & a);
    static void MinQPSetQuadraticTermSparse(CMinQPStateShell & state, CSparseMatrix & a, bool IsUpper);
    static void MinQPSetStartingPoint(CMinQPStateShell & state, double & x);
    static void MinQPSetOrigin(CMinQPStateShell & state, double & xorigin);
    static void MinQPSetScale(CMinQPStateShell & state, CRowDouble & s);
    static void MinQPSetScaleAutoDiag(CMinQPStateShell & state);
    static void MinQPSetAlgoBLEIC(CMinQPStateShell & state, double epsg, double epsf, double epsx, int maxits);
    static void MinQPSetAlgoDenseAUL(CMinQPStateShell & state, double epsx, double rho, int itscnt);
    static void MinQPSetAlgoDenseIPM(CMinQPStateShell & state, double eps);
    static void MinQPSetAlgoSparseIPM(CMinQPStateShell & state, double eps);
    static void MinQPSetAlgoQuickQP(CMinQPStateShell & state, double epsg, double epsf, double epsx, int maxouterits, bool usenewton);
    static void MinQPSetBCAll(CMinQPStateShell & state, double bndl, double bndu);
    static void MinQPSetAlgoCholesky(CMinQPStateShell & state);
    static void MinQPSetBC(CMinQPStateShell & state, double & bndl, double & bndu);
    static void MinQPSetBCI(CMinQPStateShell & state, int i, double bndl, double bndu);
    static void MinQPSetLC(CMinQPStateShell & state, CMatrixDouble & c, CRowInt & ct, int k);
    static void MinQPSetLC(CMinQPStateShell & state, CMatrixDouble & c, CRowInt & ct);
    static void MinQPSetLCSparse(CMinQPStateShell & state, CSparseMatrix & c, CRowInt & ct, int k);
    static void MinQPSetLCMixed(CMinQPStateShell & state, CSparseMatrix & sparsec, CRowInt & sparsect, int sparsek, CMatrixDouble & densec, CRowInt & densect, int densek);
    static void MinQPSetLCMixedLegacy(CMinQPStateShell & state, CMatrixDouble & densec, CRowInt & densect, int densek, CSparseMatrix & sparsec, CRowInt & sparsect, int sparsek);
    static void MinQPSetLC2Dense(CMinQPStateShell & state, CMatrixDouble & a, CRowDouble & al, CRowDouble & au, int k);
    static void MinQPSetLC2Dense(CMinQPStateShell & state, CMatrixDouble & a, CRowDouble & al, CRowDouble & au);
    static void MinQPSetLC2(CMinQPStateShell & state, CSparseMatrix & a, CRowDouble & al, CRowDouble & au, int k);
    static void MinQPSetLC2Mixed(CMinQPStateShell & state, CSparseMatrix & sparsea, int ksparse, CMatrixDouble & densea, int kdense, CRowDouble & al, CRowDouble & au);
    static void MinQPAddLC2Dense(CMinQPStateShell & state, CRowDouble & a, double al, double au);
    static void MinQPAddLC2(CMinQPStateShell & state, CRowInt & idxa, CRowDouble & vala, int nnz, double al, double au);
    static void MinQPAddLC2SparseFromDense(CMinQPStateShell & state, CRowDouble & da, double al, double au);
    static void MinQPOptimize(CMinQPStateShell & state);
    static void MinQPResults(CMinQPStateShell & state, double & x, CMinQPReportShell & rep);
    static void MinQPResultsBuf(CMinQPStateShell & state, double & x, CMinQPReportShell & rep);
    static void MinLMCreateVJ(const int n, const int m, double & x, CMinLMStateShell & state);
    static void MinLMCreateVJ(const int m, double & x, CMinLMStateShell & state);
    static void MinLMCreateV(const int n, const int m, double & x, double diffstep, CMinLMStateShell & state);
    static void MinLMCreateV(const int m, double & x, const double diffstep, CMinLMStateShell & state);
    static void MinLMCreateFGH(const int n, double & x, CMinLMStateShell & state);
    static void MinLMCreateFGH(double & x, CMinLMStateShell & state);
    static void MinLMSetCond(CMinLMStateShell & state, const double epsx, const int maxits);
    static void MinLMSetXRep(CMinLMStateShell & state, const bool needxrep);
    static void MinLMSetStpMax(CMinLMStateShell & state, const double stpmax);
    static void MinLMSetScale(CMinLMStateShell & state, double & s);
    static void MinLMSetBC(CMinLMStateShell & state, double & bndl, double & bndu);
    static void MinLMSetAccType(CMinLMStateShell & state, const int acctype);
    static bool MinLMIteration(CMinLMStateShell & state);
    static void MinLMOptimize(CMinLMStateShell & state, CNDimensional_FVec & fvec, CNDimensional_Rep & rep, bool rep_status, CObject & obj);
    static void MinLMOptimize(CMinLMStateShell & state, CNDimensional_FVec & fvec, CNDimensional_Jac & jac, CNDimensional_Rep & rep, bool rep_status, CObject & obj);
    static void MinLMOptimize(CMinLMStateShell & state, CNDimensional_Func & func, CNDimensional_Grad & grad, CNDimensional_Hess & hess, CNDimensional_Rep & rep, bool rep_status, CObject & obj);
    static void MinLMOptimize(CMinLMStateShell & state, CNDimensional_Func & func, CNDimensional_Jac & jac, CNDimensional_Rep & rep, bool rep_status, CObject & obj);
    static void MinLMOptimize(CMinLMStateShell & state, CNDimensional_Func & func, CNDimensional_Grad & grad, CNDimensional_Jac & jac, CNDimensional_Rep & rep, bool rep_status, CObject & obj);
    static void MinLMResults(CMinLMStateShell & state, double & x, CMinLMReportShell & rep);
    static void MinLMResultsBuf(CMinLMStateShell & state, double & x, CMinLMReportShell & rep);
    static void MinLMRestartFrom(CMinLMStateShell & state, double & x);
    static void MinLMCreateVGJ(const int n, const int m, double & x, CMinLMStateShell & state);
    static void MinLMCreateVGJ(const int m, double & x, CMinLMStateShell & state);
    static void MinLMCreateFGJ(const int n, const int m, double & x, CMinLMStateShell & state);
    static void MinLMCreateFGJ(const int m, double & x, CMinLMStateShell & state);
    static void MinLMCreateFJ(const int n, const int m, double & x, CMinLMStateShell & state);
    static void MinLMCreateFJ(const int m, double & x, CMinLMStateShell & state);
    static void MinLPCreate(int n, CMinLPState & state);
    static void MinLPSetAlgoDSS(CMinLPState & state, double eps);
    static void MinLPSetAlgoIPM(CMinLPState & state, double eps = 0);
    static void MinLPSetCost(CMinLPState & state, CRowDouble & c);
    static void MinLPSetScale(CMinLPState & state, CRowDouble & s);
    static void MinLPSetBC(CMinLPState & state, CRowDouble & bndl, CRowDouble & bndu);
    static void MinLPSetBCAll(CMinLPState & state, double bndl, double bndu);
    static void MinLPSetBCi(CMinLPState & state, int i, double bndl, double bndu);
    static void MinLPSetLC(CMinLPState & state, CMatrixDouble & a, CRowInt & ct, int k);
    static void MinLPSetLC(CMinLPState & state, CMatrixDouble & a, CRowInt & ct);
    static void MinLPSetLC2Dense(CMinLPState & state, CMatrixDouble & a, CRowDouble & al, CRowDouble & au, int k);
    static void MinLPSetLC2Dense(CMinLPState & state, CMatrixDouble & a, CRowDouble & al, CRowDouble & au);
    static void MinLPSetLC2(CMinLPState & state, CSparseMatrix & a, CRowDouble & al, CRowDouble & au, int k);
    static void MinLPAddLC2Dense(CMinLPState & state, CRowDouble & a, double al, double au);
    static void MinLPAddLC2(CMinLPState & state, CRowInt & idxa, CRowDouble & vala, int nnz, double al, double au);
    static void MinLPOptimize(CMinLPState & state);
    static void MinLPResults(CMinLPState & state, CRowDouble & x, CMinLPReport & rep);
    static void MinLPResultsBuf(CMinLPState & state, CRowDouble & x, CMinLPReport & rep);
    static void MinNLCCreate(int n, CRowDouble & x, CMinNLCState & state);
    static void MinNLCCreate(CRowDouble & x, CMinNLCState & state);
    static void MinNLCCreateF(int n, CRowDouble & x, double diffstep, CMinNLCState & state);
    static void MinNLCCreateF(CRowDouble & x, double diffstep, CMinNLCState & state);
    static void MinNLCSetBC(CMinNLCState & state, CRowDouble & bndl, CRowDouble & bndu);
    static void MinNLCSetLC(CMinNLCState & state, CMatrixDouble & c, CRowInt & ct, int k);
    static void MinNLCSetLC(CMinNLCState & state, CMatrixDouble & c, CRowInt & ct);
    static void MinNLCSetNLC(CMinNLCState & state, int nlec, int nlic);
    static void MinNLCSetCond(CMinNLCState & state, double epsx, int maxits);
    static void MinNLCSetScale(CMinNLCState & state, CRowDouble & s);
    static void MinNLCSetPrecInexact(CMinNLCState & state);
    static void MinNLCSetPrecExactLowRank(CMinNLCState & state, int updatefreq);
    static void MinNLCSetPrecExactRobust(CMinNLCState & state, int updatefreq);
    static void MinNLCSetPrecNone(CMinNLCState & state);
    static void MinNLCSetSTPMax(CMinNLCState & state, double stpmax);
    static void MinNLCSetAlgoAUL(CMinNLCState & state, double rho, int itscnt);
    static void MinNLCSetAlgoSLP(CMinNLCState & state);
    static void MinNLCSetAlgoSQP(CMinNLCState & state);
    static void MinNLCSetXRep(CMinNLCState & state, bool needxrep);
    static bool MinNLCIteration(CMinNLCState & state);
    static void MinNLCOptimize(CMinNLCState & state, CNDimensional_FVec & fvec, CNDimensional_Rep & rep, CObject & obj);
    static void MinNLCOptimize(CMinNLCState & state, CNDimensional_Jac & jac, CNDimensional_Rep & rep, CObject & obj);
    static void MinNLCOptGuardGradient(CMinNLCState & state, double teststep);
    static void MinNLCOptGuardSmoothness(CMinNLCState & state, int level = 1);
    static void MinNLCOptGuardResults(CMinNLCState & state, COptGuardReport & rep);
    static void MinNLCOptGuardNonC1Test0Results(CMinNLCState & state, COptGuardNonC1Test0Report & strrep, COptGuardNonC1Test0Report & lngrep);
    static void MinNLCOptGuardNonC1Test1Results(CMinNLCState & state, COptGuardNonC1Test1Report & strrep, COptGuardNonC1Test1Report & lngrep);
    static void MinNLCResults(CMinNLCState & state, CRowDouble & x, CMinNLCReport & rep);
    static void MinNLCResultsBuf(CMinNLCState & state, CRowDouble & x, CMinNLCReport & rep);
    static void MinNLCRequestTermination(CMinNLCState & state);
    static void MinNLCRestartFrom(CMinNLCState & state, CRowDouble & x);
    static void MinNSCreate(int n, CRowDouble & x, CMinNSState & state);
    static void MinNSCreate(CRowDouble & x, CMinNSState & state);
    static void MinNSCreateF(int n, CRowDouble & x, double diffstep, CMinNSState & state);
    static void MinNSCreateF(CRowDouble & x, double diffstep, CMinNSState & state);
    static void MinNSSetBC(CMinNSState & state, CRowDouble & bndl, CRowDouble & bndu);
    static void MinNSSetLC(CMinNSState & state, CMatrixDouble & c, CRowInt & ct, int k);
    static void MinNSSetLC(CMinNSState & state, CMatrixDouble & c, CRowInt & ct);
    static void MinNSSetNLC(CMinNSState & state, int nlec, int nlic);
    static void MinNSSetCond(CMinNSState & state, double epsx, int maxits);
    static void MinNSSetScale(CMinNSState & state, CRowDouble & s);
    static void MinNSSetAlgoAGS(CMinNSState & state, double radius, double penalty);
    static void MinNSSetXRep(CMinNSState & state, bool needxrep);
    static void MinNSRequestTermination(CMinNSState & state);
    static bool MinNSIteration(CMinNSState & state);
    static void MinNSOptimize(CMinNSState & state, CNDimensional_FVec & fvec, CNDimensional_Rep & rep, CObject & obj);
    static void MinNSOptimize(CMinNSState & state, CNDimensional_Jac & jac, CNDimensional_Rep & rep, CObject & obj);
    static void MinNSResults(CMinNSState & state, CRowDouble & x, CMinNSReport & rep);
    static void MinNSResultsBuf(CMinNSState & state, CRowDouble & x, CMinNSReport & rep);
    static void MinNSRestartFrom(CMinNSState & state, CRowDouble & x);
    static void MinBCCreate(int n, CRowDouble & x, CMinBCState & state);
    static void MinBCCreate(CRowDouble & x, CMinBCState & state);
    static void MinBCCreateF(int n, CRowDouble & x, double diffstep, CMinBCState & state);
    static void MinBCCreateF(CRowDouble & x, double diffstep, CMinBCState & state);
    static void MinBCSetBC(CMinBCState & state, CRowDouble & bndl, CRowDouble & bndu);
    static void MinBCSetCond(CMinBCState & state, double epsg, double epsf, double epsx, int maxits);
    static void MinBCSetScale(CMinBCState & state, CRowDouble & s);
    static void MinBCSetPrecDefault(CMinBCState & state);
    static void MinBCSetPrecDiag(CMinBCState & state, CRowDouble & d);
    static void MinBCSetPrecScale(CMinBCState & state);
    static void MinBCSetXRep(CMinBCState & state, bool needxrep);
    static void MinBCSetStpMax(CMinBCState & state, double stpmax);
    static bool MinBCIteration(CMinBCState & state);
    static void MinBCOptimize(CMinBCState & state, CNDimensional_Func & func, CNDimensional_Rep & rep, CObject & obj);
    static void MinBCOptimize(CMinBCState & state, CNDimensional_Grad & grad, CNDimensional_Rep & rep, CObject & obj);
    static void MinBCOptGuardGradient(CMinBCState & state, double teststep);
    static void MinBCOptGuardSmoothness(CMinBCState & state, int level = 1);
    static void MinBCOptGuardResults(CMinBCState & state, COptGuardReport & rep);
    static void MinBCOptGuardNonC1Test0Results(CMinBCState & state, COptGuardNonC1Test0Report & strrep, COptGuardNonC1Test0Report & lngrep);
    static void MinBCOptGuardNonC1Test1Results(CMinBCState & state, COptGuardNonC1Test1Report & strrep, COptGuardNonC1Test1Report & lngrep);
    static void MinBCResults(CMinBCState & state, CRowDouble & x, CMinBCReport & rep);
    static void MinBCResultsBuf(CMinBCState & state, CRowDouble & x, CMinBCReport & rep);
    static void MinBCRestartFrom(CMinBCState & state, CRowDouble & x);
    static void MinBCRequestTermination(CMinBCState & state);
    static void MinLBFGSSetDefaultPreconditioner(CMinLBFGSStateShell & state);
    static void MinLBFGSSetCholeskyPreconditioner(CMinLBFGSStateShell & state, CMatrixDouble & p, bool IsUpper);
    static void MinBLEICSetBarrierWidth(CMinBLEICStateShell & state, const double mu);
    static void MinBLEICSetBarrierDecay(CMinBLEICStateShell & state, const double mudecay);
    static void MinASACreate(const int n, double & x, double & bndl, double & bndu, CMinASAStateShell & state);
    static void MinASACreate(double & x, double & bndl, double & bndu, CMinASAStateShell & state);
    static void MinASASetCond(CMinASAStateShell & state, const double epsg, const double epsf, const double epsx, const int maxits);
    static void MinASASetXRep(CMinASAStateShell & state, const bool needxrep);
    static void MinASASetAlgorithm(CMinASAStateShell & state, const int algotype);
    static void MinASASetStpMax(CMinASAStateShell & state, const double stpmax);
    static bool MinASAIteration(CMinASAStateShell & state);
    static void MinASAOptimize(CMinASAStateShell & state, CNDimensional_Grad & grad, CNDimensional_Rep & rep, bool rep_status, CObject & obj);
    static void MinASAResults(CMinASAStateShell & state, double & x, CMinASAReportShell & rep);
    static void MinASAResultsBuf(CMinASAStateShell & state, double & x, CMinASAReportShell & rep);
    static void MinASARestartFrom(CMinASAStateShell & state, double & x, double & bndl, double & bndu);
    static void PolynomialSolve(CRowDouble & a, int n, CRowComplex & x, CPolynomialSolverReport & rep);
    static void RMatrixSolve(CMatrixDouble & a, const int n, double & b, int & info, CDenseSolverReportShell & rep, double & x);
    static void RMatrixSolveM(CMatrixDouble & a, const int n, CMatrixDouble & b, const int m, const bool rfs, int & info, CDenseSolverReportShell & rep, CMatrixDouble & x);
    static void RMatrixLUSolve(CMatrixDouble & lua, int & p, const int n, double & b, int & info, CDenseSolverReportShell & rep, double & x);
    static void RMatrixLUSolveM(CMatrixDouble & lua, int & p, const int n, CMatrixDouble & b, const int m, int & info, CDenseSolverReportShell & rep, CMatrixDouble & x);
    static void RMatrixMixedSolve(CMatrixDouble & a, CMatrixDouble & lua, int & p, const int n, double & b, int & info, CDenseSolverReportShell & rep, double & x);
    static void RMatrixMixedSolveM(CMatrixDouble & a, CMatrixDouble & lua, int & p, const int n, CMatrixDouble & b, const int m, int & info, CDenseSolverReportShell & rep, CMatrixDouble & x);
    static void CMatrixSolveM(CMatrixComplex & a, const int n, CMatrixComplex & b, const int m, const bool rfs, int & info, CDenseSolverReportShell & rep, CMatrixComplex & x);
    static void CMatrixSolve(CMatrixComplex & a, const int n, complex & b, int & info, CDenseSolverReportShell & rep, complex & x);
    static void CMatrixLUSolveM(CMatrixComplex & lua, int & p, const int n, CMatrixComplex & b, const int m, int & info, CDenseSolverReportShell & rep, CMatrixComplex & x);
    static void CMatrixLUSolve(CMatrixComplex & lua, int & p, const int n, complex & b, int & info, CDenseSolverReportShell & rep, complex & x);
    static void CMatrixMixedSolveM(CMatrixComplex & a, CMatrixComplex & lua, int & p, const int n, CMatrixComplex & b, const int m, int & info, CDenseSolverReportShell & rep, CMatrixComplex & x);
    static void CMatrixMixedSolve(CMatrixComplex & a, CMatrixComplex & lua, int & p, const int n, complex & b, int & info, CDenseSolverReportShell & rep, complex & x);
    static void SPDMatrixSolveM(CMatrixDouble & a, const int n, const bool IsUpper, CMatrixDouble & b, const int m, int & info, CDenseSolverReportShell & rep, CMatrixDouble & x);
    static void SPDMatrixSolve(CMatrixDouble & a, const int n, const bool IsUpper, double & b, int & info, CDenseSolverReportShell & rep, double & x);
    static void SPDMatrixCholeskySolveM(CMatrixDouble & cha, const int n, const bool IsUpper, CMatrixDouble & b, const int m, int & info, CDenseSolverReportShell & rep, CMatrixDouble & x);
    static void SPDMatrixCholeskySolve(CMatrixDouble & cha, const int n, const bool IsUpper, double & b, int & info, CDenseSolverReportShell & rep, double & x);
    static void HPDMatrixSolveM(CMatrixComplex & a, const int n, const bool IsUpper, CMatrixComplex & b, const int m, int & info, CDenseSolverReportShell & rep, CMatrixComplex & x);
    static void HPDMatrixSolve(CMatrixComplex & a, const int n, const bool IsUpper, complex & b, int & info, CDenseSolverReportShell & rep, complex & x);
    static void HPDMatrixCholeskySolveM(CMatrixComplex & cha, const int n, const bool IsUpper, CMatrixComplex & b, const int m, int & info, CDenseSolverReportShell & rep, CMatrixComplex & x);
    static void HPDMatrixCholeskySolve(CMatrixComplex & cha, const int n, const bool IsUpper, complex & b, int & info, CDenseSolverReportShell & rep, complex & x);
    static void RMatrixSolveLS(CMatrixDouble & a, const int nrows, const int ncols, double & b, const double threshold, int & info, CDenseSolverLSReportShell & rep, double & x);
    static void SparseSPDSolveSKS(CSparseMatrix & a, bool IsUpper, CRowDouble & b, CRowDouble & x, CSparseSolverReport & rep);
    static void SparseSPDSolve(CSparseMatrix & a, bool IsUpper, CRowDouble & b, CRowDouble & x, CSparseSolverReport & rep);
    static void SparseSPDCholeskySolve(CSparseMatrix & a, bool IsUpper, CRowDouble & b, CRowDouble & x, CSparseSolverReport & rep);
    static void SparseSolve(CSparseMatrix & a, CRowDouble & b, CRowDouble & x, CSparseSolverReport & rep);
    static void SparseLUSolve(CSparseMatrix & a, CRowInt & p, CRowInt & q, CRowDouble & b, CRowDouble & x, CSparseSolverReport & rep);
    static void SparseSolveSymmetricGMRES(CSparseMatrix & a, bool IsUpper, CRowDouble & b, int k, double epsf, int maxits, CRowDouble & x, CSparseSolverReport & rep);
    static void SparseSolveGMRES(CSparseMatrix & a, CRowDouble & b, int k, double epsf, int maxits, CRowDouble & x, CSparseSolverReport & rep);
    static void SparseSolverCreate(int n, CSparseSolverState & state);
    static void SparseSolverSetAlgoGMRES(CSparseSolverState & state, int k);
    static void SparseSolverSetStartingPoint(CSparseSolverState & state, CRowDouble & x);
    static void SparseSolverSetCond(CSparseSolverState & state, double epsf, int maxits);
    static void SparseSolverSolveSymmetric(CSparseSolverState & state, CSparseMatrix & a, bool IsUpper, CRowDouble & b);
    static void SparseSolverSolve(CSparseSolverState & state, CSparseMatrix & a, CRowDouble & b);
    static void SparseSolverResults(CSparseSolverState & state, CRowDouble & x, CSparseSolverReport & rep);
    static void SparseSolverSetXRep(CSparseSolverState & state, bool needxrep);
    static void SparseSolverOOCStart(CSparseSolverState & state, CRowDouble & b);
    static bool SparseSolverOOCContinue(CSparseSolverState & state);
    static void SparseSolverOOCGetRequestInfo(CSparseSolverState & state, int & requesttype);
    static void SparseSolverOOCGetRequestData(CSparseSolverState & state, CRowDouble & x);
    static void SparseSolverOOCGetRequestData1(CSparseSolverState & state, double & v);
    static void SparseSolverOOCSendResult(CSparseSolverState & state, CRowDouble & ax);
    static void SparseSolverOOCStop(CSparseSolverState & state, CRowDouble & x, CSparseSolverReport & rep);
    static void SparseSolverRequestTermination(CSparseSolverState & state);
    static void LinCGCreate(int n, CLinCGState & state);
    static void LinCGSetStartingPoint(CLinCGState & state, CRowDouble & x);
    static void LinCGSetPrecUnit(CLinCGState & state);
    static void LinCGSetPrecDiag(CLinCGState & state);
    static void LinCGSetCond(CLinCGState & state, double epsf, int maxits);
    static void LinCGSolveSparse(CLinCGState & state, CSparseMatrix & a, bool IsUpper, CRowDouble & b);
    static void LinCGResult(CLinCGState & state, CRowDouble & x, CLinCGReport & rep);
    static void LinCGSetRestartFreq(CLinCGState & state, int srf);
    static void LinCGSetRUpdateFreq(CLinCGState & state, int freq);
    static void LinCGSetXRep(CLinCGState & state, bool needxrep);
    static void LinLSQRCreate(int m, int n, CLinLSQRState & state);
    static void LinLSQRCreateBuf(int m, int n, CLinLSQRState & state);
    static void LinLSQRSetPrecUnit(CLinLSQRState & state);
    static void LinLSQRSetPrecDiag(CLinLSQRState & state);
    static void LinLSQRSetLambdaI(CLinLSQRState & state, double lambdai);
    static void LinLSQRSolveSparse(CLinLSQRState & state, CSparseMatrix & a, CRowDouble & b);
    static void LinLSQRSetCond(CLinLSQRState & state, double epsa, double epsb, int maxits);
    static void LinLSQRResults(CLinLSQRState & state, CRowDouble & x, CLinLSQRReport & rep);
    static void LinLSQRSetXRep(CLinLSQRState & state, bool needxrep);
    static int LinLSQRPeekIterationsCount(CLinLSQRState & s);
    static void LinLSQRRequestTermination(CLinLSQRState & state);
    static void NlEqCreateLM(const int n, const int m, double & x, CNlEqStateShell & state);
    static void NlEqCreateLM(const int m, double & x, CNlEqStateShell & state);
    static void NlEqSetCond(CNlEqStateShell & state, const double epsf, const int maxits);
    static void NlEqSetXRep(CNlEqStateShell & state, const bool needxrep);
    static void NlEqSetStpMax(CNlEqStateShell & state, const double stpmax);
    static bool NlEqIteration(CNlEqStateShell & state);
    static void NlEqSolve(CNlEqStateShell & state, CNDimensional_Func & func, CNDimensional_Jac & jac, CNDimensional_Rep & rep, bool rep_status, CObject & obj);
    static void NlEqResults(CNlEqStateShell & state, double & x, CNlEqReportShell & rep);
    static void NlEqResultsBuf(CNlEqStateShell & state, double & x, CNlEqReportShell & rep);
    static void NlEqRestartFrom(CNlEqStateShell & state, double & x);
    static double GammaFunction(const double x);
    static double LnGamma(const double x, double & sgngam);
    static double ErrorFunction(const double x);
    static double ErrorFunctionC(const double x);
    static double NormalDistribution(const double x);
    static double NormalPDF(const double x);
    static double NormalCDF(const double x);
    static double InvErF(const double e);
    static double InvNormalDistribution(double y0);
    static double InvNormalCDF(const double y0);
    static double BivariateNormalPDF(const double x, const double y, const double rho);
    static double BivariateNormalCDF(double x, double y, const double rho);
    static double IncompleteGamma(const double a, const double x);
    static double IncompleteGammaC(const double a, const double x);
    static double InvIncompleteGammaC(const double a, const double y0);
    static void Airy(const double x, double & ai, double & aip, double & bi, double & bip);
    static double BesselJ0(const double x);
    static double BesselJ1(const double x);
    static double BesselJN(const int n, const double x);
    static double BesselY0(const double x);
    static double BesselY1(const double x);
    static double BesselYN(const int n, const double x);
    static double BesselI0(const double x);
    static double BesselI1(const double x);
    static double BesselK0(const double x);
    static double BesselK1(const double x);
    static double BesselKN(const int nn, const double x);
    static double Beta(const double a, const double b);
    static double IncompleteBeta(const double a, const double b, const double x);
    static double InvIncompleteBeta(const double a, const double b, double y);
    static double BinomialDistribution(const int k, const int n, const double p);
    static double BinomialComplDistribution(const int k, const int n, const double p);
    static double InvBinomialDistribution(const int k, const int n, const double y);
    static double ChebyshevCalculate(int r, const int n, const double x);
    static double ChebyshevSum(double & c, const int r, const int n, const double x);
    static void ChebyshevCoefficients(const int n, double & c);
    static void FromChebyshev(double & a, const int n, double & b);
    static double ChiSquareDistribution(const double v, const double x);
    static double ChiSquareComplDistribution(const double v, const double x);
    static double InvChiSquareDistribution(const double v, const double y);
    static double DawsonIntegral(const double x);
    static double EllipticIntegralK(const double m);
    static double EllipticIntegralKhighPrecision(const double m1);
    static double IncompleteEllipticIntegralK(const double phi, const double m);
    static double EllipticIntegralE(const double m);
    static double IncompleteEllipticIntegralE(const double phi, const double m);
    static double ExponentialIntegralEi(const double x);
    static double ExponentialIntegralEn(const double x, const int n);
    static double FDistribution(const int a, const int b, const double x);
    static double FComplDistribution(const int a, const int b, const double x);
    static double InvFDistribution(const int a, const int b, const double y);
    static void FresnelIntegral(const double x, double & c, double & s);
    static double HermiteCalculate(const int n, const double x);
    static double HermiteSum(double & c, const int n, const double x);
    static void HermiteCoefficients(const int n, double & c);
    static void JacobianEllipticFunctions(const double u, const double m, double & sn, double & cn, double & dn, double & ph);
    static double LaguerreCalculate(const int n, const double x);
    static double LaguerreSum(double & c, const int n, const double x);
    static void LaguerreCoefficients(const int n, double & c);
    static double LegendreCalculate(const int n, const double x);
    static double LegendreSum(double & c, const int n, const double x);
    static void LegendreCoefficients(const int n, double & c);
    static double PoissonDistribution(const int k, const double m);
    static double PoissonComplDistribution(const int k, const double m);
    static double InvPoissonDistribution(const int k, const double y);
    static double Psi(const double x);
    static double StudenttDistribution(const int k, const double t);
    static double InvStudenttDistribution(const int k, const double p);
    static void SineCosineIntegrals(const double x, double & si, double & ci);
    static void HyperbolicSineCosineIntegrals(const double x, double & shi, double & chi);
    static void SampleMoments(const double & x, const int n, double & mean, double & variance, double & skewness, double & kurtosis);
    static void SampleMoments(const double & x, double & mean, double & variance, double & skewness, double & kurtosis);
    static double SampleMean(CRowDouble & x, int n);
    static double SampleMean(CRowDouble & x);
    static double SampleVariance(CRowDouble & x, int n);
    static double SampleVariance(CRowDouble & x);
    static double SampleSkewness(CRowDouble & x, int n);
    static double SampleSkewness(CRowDouble & x);
    static double SampleKurtosis(CRowDouble & x, int n);
    static double SampleKurtosis(CRowDouble & x);
    static void SampleAdev(const double & x, const int n, double & adev);
    static void SampleAdev(const double & x, double & adev);
    static void SampleMedian(const double & x, const int n, double & median);
    static void SampleMedian(const double & x, double & median);
    static void SamplePercentile(const double & x, const int n, const double p, double & v);
    static void SamplePercentile(const double & x, const double p, double & v);
    static double Cov2(const double & x, const double & y, const int n);
    static double Cov2(const double & x, const double & y);
    static double PearsonCorr2(const double & x, const double & y, const int n);
    static double PearsonCorr2(const double & x, const double & y);
    static double SpearmanCorr2(const double & x, const double & y, const int n);
    static double SpearmanCorr2(const double & x, const double & y);
    static void CovM(const CMatrixDouble & x, const int n, const int m, CMatrixDouble & c);
    static void CovM(const CMatrixDouble & x, CMatrixDouble & c);
    static void PearsonCorrM(const CMatrixDouble & x, const int n, const int m, CMatrixDouble & c);
    static void PearsonCorrM(CMatrixDouble & x, CMatrixDouble & c);
    static void SpearmanCorrM(const CMatrixDouble & x, const int n, const int m, CMatrixDouble & c);
    static void SpearmanCorrM(const CMatrixDouble & x, CMatrixDouble & c);
    static void CovM2(const CMatrixDouble & x, const CMatrixDouble & y, const int n, const int m1, const int m2, CMatrixDouble & c);
    static void CovM2(const CMatrixDouble & x, const CMatrixDouble & y, CMatrixDouble & c);
    static void PearsonCorrM2(const CMatrixDouble & x, const CMatrixDouble & y, const int n, const int m1, const int m2, CMatrixDouble & c);
    static void PearsonCorrM2(const CMatrixDouble & x, const CMatrixDouble & y, CMatrixDouble & c);
    static void SpearmanCorrM2(const CMatrixDouble & x, const CMatrixDouble & y, const int n, const int m1, const int m2, CMatrixDouble & c);
    static void SpearmanCorrM2(const CMatrixDouble & x, const CMatrixDouble & y, CMatrixDouble & c);
    static void RankData(CMatrixDouble & xy, int npoints, int nfeatures);
    static void RankData(CMatrixDouble & xy);
    static void RankDataCentered(CMatrixDouble & xy, int npoints, int nfeatures);
    static void RankDataCentered(CMatrixDouble & xy);
    static void PearsonCorrelationSignificance(const double r, const int n, double & bothTails, double & leftTail, double & rightTail);
    static void SpearmanRankCorrelationSignificance(const double r, const int n, double & bothTails, double & leftTail, double & rightTail);
    static void JarqueBeraTest(const double & x, const int n, double & p);
    static void MannWhitneyUTest(const double & x, const int n, const double & y, const int m, double & bothTails, double & leftTail, double & rightTail);
    static void OneSampleSignTest(const double & x, const int n, const double median, double & bothTails, double & leftTail, double & rightTail);
    static void StudentTest1(const double & x, const int n, const double mean, double & bothTails, double & leftTail, double & rightTail);
    static void StudentTest2(const double & x, const int n, const double & y, const int m, double & bothTails, double & leftTail, double & rightTail);
    static void UnequalVarianceTest(const double & x, const int n, const double & y, const int m, double & bothTails, double & leftTail, double & rightTail);
    static void FTest(const double & x, const int n, const double & y, const int m, double & bothTails, double & leftTail, double & rightTail);
    static void OneSampleVarianceTest(double & x, int n, double variance, double & bothTails, double & leftTail, double & rightTail);
    static void WilcoxonSignedRankTest(const double & x, const int n, const double e, double & bothTails, double & leftTail, double & rightTail);
};

class CSCodes {
public:
    static int GetRDFSerializationCode(void);
    static int GetKDTreeSerializationCode(void);
    static int GetMLPSerializationCode(void);
    static int GetMLPESerializationCode(void);
    static int GetRBFSerializationCode(void);
    static int GetSpline2DSerializationCode(void);
    static int GetIDWSerializationCode(void);
    static int GetSparseMatrixSerializationCode(void);
    static int GetKNNSerializationCode(void);
    static int GetLpTestSerializationCode(void);
};

struct CApBuff {
public:
    bool m_ba;
    CRowInt m_ia0;
    CRowInt m_ia1;
    CRowInt m_ia2;
    CRowInt m_ia3;
    CRowDouble m_ra0;
    CRowDouble m_ra1;
    CRowDouble m_ra2;
    CRowDouble m_ra3;
    CMatrixDouble m_rm0;
    CMatrixDouble m_rm1;
    CApBuff(void);
    ~CApBuff();
    void Copy(const CApBuff & obj);
};

class CApServ {
public:
    static double SparseLevel2Density(void);
    static int MatrixTileSizeA(void);
    static int MatrixTileSizeB(void);
    static double SMPActivationLevel(void);
    static double SpawnLevel(void);
    static void TaskGenInt1D(const double a, const double b, const int n, double & x, double & y);
    static void TaskGenInt1D(const double a, const double b, const int n, CRowDouble & x, CRowDouble & y);
    static void TaskGenInt1DEquidist(const double a, const double b, const int n, double & x, double & y);
    static void TaskGenInt1DEquidist(const double a, const double b, const int n, CRowDouble & x, CRowDouble & y);
    static void TaskGenInt1DCheb1(const double a, const double b, const int n, double & x, double & y);
    static void TaskGenInt1DCheb1(const double a, const double b, const int n, CRowDouble & x, CRowDouble & y);
    static void TaskGenInt1DCheb2(const double a, const double b, const int n, double & x, double & y);
    static void TaskGenInt1DCheb2(const double a, const double b, const int n, CRowDouble & x, CRowDouble & y);
    static bool AreDistinct(double & x, const int n);
    static bool AreDistinct(CRowDouble & x, const int n);
    static void BVectorSetLengthAtLeast(bool & x, const int n);
    static void IVectorSetLengthAtLeast(int & x, const int n);
    static void IVectorSetLengthAtLeast(CRowInt & x, const int n);
    static bool RVectorSetLengthAtLeast(double & x, const int n);
    static bool RVectorSetLengthAtLeast(CRowDouble & x, const int n);
    static void VectorGrowTo(CRowInt & x, int n);
    static void VectorGrowTo(CRowDouble & x, int n);
    static void VectorAppend(CRowInt & x, int v);
    static void VectorAppend(CRowDouble & x, double v);
    static void VectorAppend(CRowComplex & x, complex v);
    static bool RMatrixSetLengthAtLeast(CMatrixDouble & x, const int m, const int n);
    static void RMatrixResize(CMatrixDouble & x, const int m, const int n);
    static void RMatrixGrowRowsTo(CMatrixDouble & a, int n, int mincols);
    static void RMatrixGrowColsTo(CMatrixDouble & a, int n, int minrows);
    static bool IsFiniteVector(const double & x, const int n);
    static bool IsFiniteVector(const CRowDouble & x, const int n);
    static bool IsFiniteComplexVector(CRowComplex & x, const int n);
    static bool IsFiniteComplexVector(complex & z, const int n);
    static bool IsFiniteMatrix(const CMatrixDouble & x, const int m, const int n);
    static bool IsFiniteComplexMatrix(CMatrixComplex & x, const int m, const int n);
    static bool IsFiniteRTrMatrix(CMatrixDouble & x, const int n, const bool IsUpper);
    static bool IsFiniteCTrMatrix(CMatrixComplex & x, const int n, const bool IsUpper);
    static bool IsFiniteOrNaNMatrix(CMatrixDouble & x, const int m, const int n);
    static double SafePythag2(const double x, const double y);
    static double SafePythag3(double x, double y, double z);
    static int SafeRDiv(double x, double y, double & r);
    static double SafeMinPosRV(const double x, const double y, const double v);
    static void ApPeriodicMap(double & x, const double a, const double b, double & k);
    static double RandomNormal(void);
    static void RandomUnit(int n, CRowDouble & x);
    static void CountDown(int & v);
    static double PosSign(double x);
    static void SwapRows(CMatrixDouble & a, int i0, int i1, int ncols);
    static void SwapCols(CMatrixDouble & a, int j0, int j1, int nrows);
    static void SwapEntries(CRowDouble & a, int i0, int i1, int entrywidth);
    static void SwapElements(CRowDouble & a, int i0, int i1);
    static void SwapElementsI(CRowInt & a, int i0, int i1);
    static int IDivUp(int a, int b);
    static void AllocComplex(CSerializer & s, complex & v);
    static void SerializeComplex(CSerializer & s, complex & v);
    static complex UnserializeComplex(CSerializer & s);
    static void AllocRealArray(CSerializer & s, double & v, int n = -1);
    static void AllocRealArray(CSerializer & s, CRowDouble & v, int n = -1);
    static void SerializeRealArray(CSerializer & s, double & v, int n = -1);
    static void SerializeRealArray(CSerializer & s, CRowDouble & v, int n = -1);
    static void UnserializeRealArray(CSerializer & s, double & v);
    static void UnserializeRealArray(CSerializer & s, CRowDouble & v);
    static void AllocIntegerArray(CSerializer & s, int & v, int n = -1);
    static void AllocIntegerArray(CSerializer & s, CRowInt & v, int n = -1);
    static void SerializeIntegerArray(CSerializer & s, int & v, int n = -1);
    static void SerializeIntegerArray(CSerializer & s, CRowInt & v, int n = -1);
    static void UnserializeIntegerArray(CSerializer & s, int & v);
    static void UnserializeIntegerArray(CSerializer & s, CRowInt & v);
    static void AllocBoolArray(CSerializer & s, bool & v, int n = -1);
    static void SerializeBoolArray(CSerializer & s, bool & v, int n = -1);
    static void AllocRealMatrix(CSerializer & s, CMatrixDouble & v, int n0, int n1);
    static void SerializeRealMatrix(CSerializer & s, CMatrixDouble & v, int n0, int n1);
    static void UnserializeRealMatrix(CSerializer & s, CMatrixDouble & v);
    static void CopyIntegerArray(int & src, int & dst);
    static void CopyIntegerArray(CRowInt & src, CRowInt & dst);
    static void CopyRealArray(double & src, double & dst);
    static void CopyRealArray(double & src, CRowDouble & dst);
    static void CopyRealArray(CRowDouble & src, CRowDouble & dst);
    static void CopyRealMatrix(CMatrixDouble & src, CMatrixDouble & dst);
    static void TiledSplit(int tasksize, int tilesize, int & task0, int & task1);
    static void SplitLengthEven(int tasksize, int & task0, int & task1);
    static void SplitLength(int tasksize, int m_ChunkSize, int & task0, int & task1);
    static int RecSearch(int & a, const int nrec, const int nheader, int i0, int i1, int & b);
    static int RecSearch(CRowInt & a, const int nrec, const int nheader, int i0, int i1, CRowInt & b);
    static int CountNZ1(CRowDouble & v, int n);
    static int CountNZ2(CMatrixDouble & v, int m, int n);
    static int ChunksCount(int tasksize, int m_ChunkSize);
    static double Coalesce(double a, double b);
    static int CoalesceI(int a, int b);
    static double LogBase2(double x);
    static bool ApproxEqual(double a, double b, double tol);
    static bool ApproxEqualRel(double a, double b, double tol);
    static void TraceVectorAutopRec(CRowDouble & a, int i0, int i1);
    static void TraceRowAutopRec(CMatrixDouble & a, int i, int j0, int j1);
    static void TraceVectoRunScaledUnshiftedAutopRec(CRowDouble & x, int n, CRowDouble & scl, bool applyscl, CRowDouble & sft, bool applysft);
    static void TraceVectorUnscaledUnshiftedAutopRec(CRowDouble & x, int n, CRowDouble & scl, bool applyscl, CRowDouble & sft, bool applysft);
    static void TraceRowNrm1AutopRec(CMatrixDouble & a, int i0, int i1, int j0, int j1);
    static void TraceVectorE3(CRowDouble & a, int i0, int i1);
    static void TraceVectorE6(CRowDouble & a, int i0, int i1);
    static void TraceVectorE615(CRowDouble & a, int i0, int i1, bool usee15);
    static void TraceRowNrm1E6(CMatrixDouble & a, int i0, int i1, int j0, int j1);
};

class CTSort {
public:
    static void TagSort(double & a, const int n, int & p1, int & p2);
    static void TagSort(CRowDouble & a, const int n, CRowInt & p1, CRowInt & p2);
    static void TagSortBuf(double & a, const int n, int & p1, int & p2, CApBuff & buf);
    static void TagSortBuf(CRowDouble & a, const int n, CRowInt & p1, CRowInt & p2, CApBuff & buf);
    static void TagSortFastI(double & a, int & b, double & bufa, int & bufb, const int n);
    static void TagSortFastI(double & a, int & b, CRowDouble & bufa, CRowInt & bufb, const int n);
    static void TagSortFastI(CRowDouble & a, CRowInt & b, CRowDouble & bufa, CRowInt & bufb, const int n);
    static void TagSortFastR(double & a, double & b, double & bufa, double & bufb, const int n);
    static void TagSortFastR(CRowDouble & a, CRowDouble & b, CRowDouble & bufa, CRowDouble & bufb, const int n);
    static void TagSortFast(double & a, double & bufa, const int n);
    static void TagSortFast(CRowDouble & a, CRowDouble & bufa, const int n);
    static void TagSortMiddleIR(CRowInt & a, CRowDouble & b, int offset, int n);
    static void TagSortMiddleII(CRowInt & a, CRowInt & b, int offset, int n);
    static void TagSortMiddleI(CRowInt & a, int offset, int n);
    static void SortMiddleI(CRowInt & a, int offset, int n);
    static void TagHeapPushI(double & a, int & b, int & n, const double va, const int vb);
    static void TagHeapPushI(CRowDouble & a, CRowInt & b, int & n, const double va, const int vb);
    static void TagHeapReplaceTopI(double & a, int & b, const int n, const double va, const int vb);
    static void TagHeapReplaceTopI(CRowDouble & a, CRowInt & b, const int n, const double va, const int vb);
    static void TagHeapPopI(double & a, int & b, int & n);
    static void TagHeapPopI(CRowDouble & a, CRowInt & b, int & n);
    static int LowerBound(CRowDouble & a, int n, double t);
    static int UpperBound(CRowDouble & a, int n, double t);
};

class CBasicStatOps {
public:
    static void RankX(CRowDouble & x, const int n, bool IsCentered, CApBuff & buf);
    static void RankXUntied(CRowDouble & x, int n, CApBuff & buf);
};

class CAblasF {
public:
    static void RAddVC(int n, double alpha, CRowDouble & y, CMatrixDouble & x, int colidx);
    static void RSetAllocV(int n, double v, CRowDouble & x);
    static void RSetAllocM(int m, int n, double v, CMatrixDouble & a);
    static void RAllocV(int n, CRowDouble & x);
    static void IAllocV(int n, CRowInt & x);
    static void BAllocV(int n, bool & x);
    static void RAllocM(int m, int n, CMatrixDouble & a);
    static void ISetAllocV(int n, int v, CRowInt & x);
    static void BSetAllocV(int n, bool v, bool & x);
    static void RSetC(int n, double v, CMatrixDouble & a, int j);
    static void RCopyAllocV(int n, CRowDouble & x, CRowDouble & y);
    static void RCopyM(int m, int n, CMatrixDouble & x, CMatrixDouble & y);
    static void RCopyAllocM(int m, int n, CMatrixDouble & x, CMatrixDouble & y);
    static void ICopyAllocV(int n, CRowInt & x, CRowInt & y);
    static void BCopyAllocV(int n, bool & x, bool & y);
    static void IGrowV(int newn, CRowInt & x);
    static void RGrowV(int newn, CRowDouble & x);
    static void RCopyMulVC(int n, double v, CRowDouble & x, CMatrixDouble & y, int cidx);
    static void RCopyVC(int n, CRowDouble & x, CMatrixDouble & a, int j);
    static void RCopyCV(int n, CMatrixDouble & a, int j, CRowDouble & x);
    static void CMatrixGemmK(int m, int n, int k, complex alpha, const CMatrixComplex & a, int ia, int ja, int optypea, const CMatrixComplex & b, int ib, int jb, int optypeb, complex beta, CMatrixComplex & c, int ic, int jc);
    static void RMatrixGemmK(int m, int n, int k, double alpha, const CMatrixDouble & a, int ia, int ja, int optypea, const CMatrixDouble & b, int ib, int jb, int optypeb, double beta, CMatrixDouble & c, int ic, int jc);
    static void RMatrixGemmK44v00(int m, int n, int k, double alpha, const CMatrixDouble & a, int ia, int ja, const CMatrixDouble & b, int ib, int jb, double beta, CMatrixDouble & c, int ic, int jc);
    static void RMatrixGemmK44v01(int m, int n, int k, double alpha, const CMatrixDouble & a, int ia, int ja, const CMatrixDouble & b, int ib, int jb, double beta, CMatrixDouble & c, int ic, int jc);
    static void RMatrixGemmK44v10(int m, int n, int k, double alpha, const CMatrixDouble & a, int ia, int ja, const CMatrixDouble & b, int ib, int jb, double beta, CMatrixDouble & c, int ic, int jc);
    static void RMatrixGemmK44v11(int m, int n, int k, double alpha, const CMatrixDouble & a, int ia, int ja, const CMatrixDouble & b, int ib, int jb, double beta, CMatrixDouble & c, int ic, int jc);
    static double RDotV(int n, CRowDouble & x, CRowDouble & y);
    static double RDotVR(int n, CRowDouble & x, CMatrixDouble & a, int i);
    static double RDotVC(int n, CRowDouble & x, CMatrixDouble & a, int i);
    static double RDotRR(int n, CMatrixDouble & a, int ia, CMatrixDouble & b, int ib);
    static double RDotV2(int n, CRowDouble & x);
    static void RAddV(int n, double alpha, CRowDouble & y, CRowDouble & x);
    static void RAddVX(int n, double alpha, CRowDouble & y, int offsy, CRowDouble & x, int offsx);
    static void RAddVR(int n, double alpha, CRowDouble & y, CMatrixDouble & x, int rowidx);
    static void RAddRV(int n, double alpha, CMatrixDouble & y, int ridx, CRowDouble & x);
    static void RAddRR(int n, double alpha, CMatrixDouble & y, int ridxsrc, CMatrixDouble & x, int ridxdst);
    static void RMulAddV(int n, CRowDouble & y, CRowDouble & z, CRowDouble & x);
    static void RMulV(int n, double v, CRowDouble & x);
    static void RMulR(int n, double v, CMatrixDouble & x, int rowidx);
    static void RMulVX(int n, double v, CRowDouble & x, int offsx);
    static void RNegMulAddV(int n, CRowDouble & y, CRowDouble & z, CRowDouble & x);
    static void RMergeMulV(int n, CRowDouble & y, CRowDouble & x);
    static void RMergeMulVR(int n, CRowDouble & y, CMatrixDouble & x, int rowidx);
    static void RMergeMulRV(int n, CMatrixDouble & y, int rowidy, CRowDouble & x);
    static void RMergeDivV(int n, CRowDouble & y, CRowDouble & x);
    static void RMergeDivVR(int n, CRowDouble & y, CMatrixDouble & x, int rowidx);
    static void RMergeDivRV(int n, CMatrixDouble & y, int rowidy, CRowDouble & x);
    static void RMergeMaxV(int n, CRowDouble & y, CRowDouble & x);
    static void RMergeMaxVR(int n, CRowDouble & y, CMatrixDouble & x, int rowidx);
    static void RMergeMaxRV(int n, CMatrixDouble & x, int rowidx, CRowDouble & y);
    static void RMergeMinV(int n, CRowDouble & y, CRowDouble & x);
    static void RMergeMinVR(int n, CRowDouble & y, CMatrixDouble & x, int rowidx);
    static void RMergeMinRV(int n, CMatrixDouble & x, int rowidx, CRowDouble & y);
    static void RSqrtV(int n, CRowDouble & x);
    static void RSqrtR(int n, CMatrixDouble & x, int rowidx);
    static double RMaxV(int n, CRowDouble & x);
    static double RMaxAbsV(int n, CRowDouble & x);
    static double RMaxR(int n, CMatrixDouble & x, int rowidx);
    static double RMaxAbsR(int n, CMatrixDouble & x, int rowidx);
    static void RSetV(int n, double v, CRowDouble & x);
    static void RSetVX(int n, double v, CRowDouble & x, int offsx);
    static void ISetV(int n, int v, CRowInt & x);
    static void BSetV(int n, bool v, bool & x);
    static void RSetM(int m, int n, double v, CMatrixDouble & a);
    static void RSetR(int n, double v, CMatrixDouble & a, int i);
    static void BCopyV(int n, bool & x, bool & y);
    static void RCopyV(int n, CRowDouble & x, CRowDouble & y);
    static void RCopyVX(int n, CRowDouble & x, int offsx, CRowDouble & y, int offsy);
    static void RCopyVR(int n, CRowDouble & x, CMatrixDouble & a, int i);
    static void RCopyRV(int n, CMatrixDouble & a, int i, CRowDouble & x);
    static void RCopyRR(int n, CMatrixDouble & a, int i, CMatrixDouble & b, int k);
    static void RCopyMulV(int n, double v, CRowDouble & x, CRowDouble & y);
    static void RCopyMulVR(int n, double v, CRowDouble & x, CMatrixDouble & y, int ridx);
    static void RCopyMulAddV(int n, CRowDouble & y, CRowDouble & z, CRowDouble & x, CRowDouble & r);
    static void RCopyNegMulAddV(int n, CRowDouble & y, CRowDouble & z, CRowDouble & x, CRowDouble & r);
    static void ICopyV(int n, CRowInt & x, CRowInt & y);
    static void ICopyVX(int n, CRowInt & x, int offsx, CRowInt & y, int offsy);
    static void RGemV(int m, int n, double alpha, CMatrixDouble & a, int opa, CRowDouble & x, double beta, CRowDouble & y);
    static void RGemVX(int m, int n, double alpha, CMatrixDouble & a, int ia, int ja, int opa, CRowDouble & x, int ix, double beta, CRowDouble & y, int iy);
    static void RGer(int m, int n, double alpha, CRowDouble & u, CRowDouble & v, CMatrixDouble & a);
    static void RTrsVX(int n, CMatrixDouble & a, int ia, int ja, bool IsUpper, bool IsUnit, int OpType, CRowDouble & x, int ix);
};

class CBlas {
public:
    static double VectorNorm2(double & x, const int i1, const int i2);
    static double VectorNorm2(CRowDouble & x, const int i1, const int i2);
    static int VectorIdxAbsMax(double & x, const int i1, const int i2);
    static int VectorIdxAbsMax(CRowDouble & x, const int i1, const int i2);
    static int ColumnIdxAbsMax(CMatrixDouble & x, const int i1, const int i2, const int j);
    static int RowIdxAbsMax(CMatrixDouble & x, const int j1, const int j2, const int i);
    static double UpperHessenberg1Norm(CMatrixDouble & a, const int i1, const int i2, const int j1, const int j2, double & work);
    static double UpperHessenberg1Norm(CMatrixDouble & a, const int i1, const int i2, const int j1, const int j2, CRowDouble & work);
    static void CopyMatrix(CMatrixDouble & a, const int is1, const int is2, const int js1, const int js2, CMatrixDouble & b, const int id1, const int id2, const int jd1, const int jd2);
    static void InplaceTranspose(CMatrixDouble & a, const int i1, const int i2, const int j1, const int j2, double & work);
    static void InplaceTranspose(CMatrixDouble & a, const int i1, const int i2, const int j1, const int j2, CRowDouble & work);
    static void CopyAndTranspose(CMatrixDouble & a, const int is1, const int is2, const int js1, const int js2, CMatrixDouble & b, const int id1, const int id2, const int jd1, const int jd2);
    static void MatrixVectorMultiply(CMatrixDouble & a, const int i1, const int i2, const int j1, const int j2, const bool trans, double & x, const int ix1, const int ix2, const double alpha, double & y, const int iy1, const int iy2, const double beta);
    static void MatrixVectorMultiply(CMatrixDouble & a, const int i1, const int i2, const int j1, const int j2, const bool trans, CRowDouble & x, const int ix1, const int ix2, const double alpha, CRowDouble & y, const int iy1, const int iy2, const double beta);
    static double PyThag2(double x, double y);
    static void MatrixMatrixMultiply(CMatrixDouble & a, const int ai1, const int ai2, const int aj1, const int aj2, const bool transa, CMatrixDouble & b, const int bi1, const int bi2, const int bj1, const int bj2, const bool transb, const double alpha, CMatrixDouble & c, const int ci1, const int ci2, const int cj1, const int cj2, const double beta, double & work);
    static void MatrixMatrixMultiply(CMatrixDouble & a, const int ai1, const int ai2, const int aj1, const int aj2, const bool transa, CMatrixDouble & b, const int bi1, const int bi2, const int bj1, const int bj2, const bool transb, const double alpha, CMatrixDouble & c, const int ci1, const int ci2, const int cj1, const int cj2, const double beta, CRowDouble & work);
};

class CHblas {
public:
    static void HermitianMatrixVectorMultiply(CMatrixComplex & a, const bool IsUpper, const int i1, const int i2, complex & x, complex & alpha, complex & y);
    static void HermitianMatrixVectorMultiply(CMatrixComplex & a, const bool IsUpper, const int i1, const int i2, CRowComplex & x, complex & alpha, CRowComplex & y);
    static void HermitianRank2Update(CMatrixComplex & a, const bool IsUpper, const int i1, const int i2, complex & x, complex & y, complex & t, complex & alpha);
    static void HermitianRank2Update(CMatrixComplex & a, const bool IsUpper, const int i1, const int i2, CRowComplex & x, CRowComplex & y, CRowComplex & t, complex & alpha);
};

class CReflections {
public:
    static void GenerateReflection(double & x, const int n, double & tau);
    static void GenerateReflection(CRowDouble & x, const int n, double & tau);
    static void ApplyReflectionFromTheLeft(CMatrixDouble & c, const double tau, const double & v, const int m1, const int m2, const int n1, const int n2, double & work);
    static void ApplyReflectionFromTheLeft(CMatrixDouble & c, const double tau, const CRowDouble & v, const int m1, const int m2, const int n1, const int n2, CRowDouble & work);
    static void ApplyReflectionFromTheRight(CMatrixDouble & c, const double tau, const double & v, const int m1, const int m2, const int n1, const int n2, double & work);
    static void ApplyReflectionFromTheRight(CMatrixDouble & c, const double tau, const CRowDouble & v, const int m1, const int m2, const int n1, const int n2, CRowDouble & work);
};

class CComplexReflections {
public:
    static void ComplexGenerateReflection(complex & x, const int n, complex & tau);
    static void ComplexGenerateReflection(CRowComplex & x, const int n, complex & tau);
    static void ComplexApplyReflectionFromTheLeft(CMatrixComplex & c, complex tau, complex & v, const int m1, const int m2, const int n1, const int n2, complex & work);
    static void ComplexApplyReflectionFromTheLeft(CMatrixComplex & c, complex tau, CRowComplex & v, const int m1, const int m2, const int n1, const int n2, CRowComplex & work);
    static void ComplexApplyReflectionFromTheRight(CMatrixComplex & c, complex tau, complex & v, const int m1, const int m2, const int n1, const int n2, complex & work);
    static void ComplexApplyReflectionFromTheRight(CMatrixComplex & c, complex tau, CRowComplex & v, const int m1, const int m2, const int n1, const int n2, CRowComplex & work);
};

class CSblas {
public:
    static void SymmetricMatrixVectorMultiply(const CMatrixDouble & a, const bool IsUpper, const int i1, const int i2, const double & x, const double alpha, double & y);
    static void SymmetricMatrixVectorMultiply(const CMatrixDouble & a, const bool IsUpper, const int i1, const int i2, const CRowDouble & x, const double alpha, CRowDouble & y);
    static void SymmetricRank2Update(CMatrixDouble & a, const bool IsUpper, const int i1, const int i2, const double & x, const double & y, double & t, const double alpha);
    static void SymmetricRank2Update(CMatrixDouble & a, const bool IsUpper, const int i1, const int i2, const CRowDouble & x, const CRowDouble  & y, CRowDouble & t, const double alpha);
};

class CRotations {
public:
    static void ApplyRotationsFromTheLeft(const bool isforward, const int m1, const int m2, const int n1, const int n2, double & c, double & s, CMatrixDouble & a, double & work);
    static void ApplyRotationsFromTheLeft(const bool isforward, const int m1, const int m2, const int n1, const int n2, CRowDouble & c, CRowDouble & s, CMatrixDouble & a, CRowDouble & work);
    static void ApplyRotationsFromTheRight(const bool isforward, const int m1, const int m2, const int n1, const int n2, double & c, double & s, CMatrixDouble & a, double & work);
    static void ApplyRotationsFromTheRight(const bool isforward, const int m1, const int m2, const int n1, const int n2, CRowDouble & c, CRowDouble & s, CMatrixDouble & a, CRowDouble & work);
    static void GenerateRotation(const double f, const double g, double & cs, double & sn, double & r);
};

class CTrLinSolve {
public:
    static void RMatrixTrSafeSolve(CMatrixDouble & a, const int n, double & x, double & s, const bool IsUpper, const bool IsTrans, const bool IsUnit);
    static void RMatrixTrSafeSolve(CMatrixDouble & a, const int n, CRowDouble & x, double & s, const bool IsUpper, const bool IsTrans, const bool IsUnit);
    static void SafeSolveTriangular(CMatrixDouble & a, const int n, double & x, double & s, const bool IsUpper, const bool IsTrans, const bool IsUnit, const bool normin, double & cnorm);
    static void SafeSolveTriangular(CMatrixDouble & a, const int n, CRowDouble & x, double & s, const bool IsUpper, const bool IsTrans, const bool IsUnit, const bool normin, CRowDouble & cnorm);
};

class CSafeSolve {
public:
    static bool RMatrixScaledTrSafeSolve(CMatrixDouble & a, const double sa, const int n, double & x, const bool IsUpper, const int trans, const bool IsUnit, const double maxgrowth);
    static bool RMatrixScaledTrSafeSolve(CMatrixDouble & a, const double sa, const int n, CRowDouble & x, const bool IsUpper, const int trans, const bool IsUnit, const double maxgrowth);
    static bool CMatrixScaledTrSafeSolve(CMatrixComplex & a, const double sa, const int n, complex & x, const bool IsUpper, const int trans, const bool IsUnit, const double maxgrowth);
    static bool CMatrixScaledTrSafeSolve(CMatrixComplex & a, const double sa, const int n, CRowComplex & x, const bool IsUpper, const int trans, const bool IsUnit, const double maxgrowth);
};

class CXblas {
public:
    static void XDot(double & a, double & b, const int n, double & temp, double & r, double & rerr);
    static void XDot(CRowDouble & a, CRowDouble & b, const int n, CRowDouble & temp, double & r, double & rerr);
    static void XCDot(complex & a, complex & b, const int n, double & temp, complex & r, double & rerr);
    static void XCDot(CRowComplex & a, CRowComplex & b, const int n, CRowDouble & temp, complex & r, double & rerr);
};

struct CLinMinState {
public:
    bool m_brackt;
    bool m_stage1;
    int m_infoc;
    double m_dg;
    double m_dgm;
    double m_dginit;
    double m_dgtest;
    double m_dgx;
    double m_dgxm;
    double m_dgy;
    double m_dgym;
    double m_finit;
    double m_ftest1;
    double m_fm;
    double m_fx;
    double m_fxm;
    double m_fy;
    double m_fym;
    double m_stx;
    double m_sty;
    double m_stmin;
    double m_stmax;
    double m_width;
    double m_width1;
    double m_xtrapf;
    CLinMinState(void);
    ~CLinMinState();
    void Copy(const CLinMinState & obj);
};

struct CArmijoState {
public:
    bool m_needf;
    CRowDouble m_x;
    double m_f;
    int m_n;
    CRowDouble m_xbase;
    CRowDouble m_s;
    double m_stplen;
    double m_fcur;
    double m_stpmax;
    int m_fmax;
    int m_nfev;
    int m_info;
    RCommState m_rstate;
    CArmijoState(void);
    ~CArmijoState();
    void Copy(CArmijoState & obj);
};

class CLinMin {
public:
    static const double m_ftol;
    static const double m_xtol;
    static const int m_maxfev;
    static const double m_stpmin;
    static const double m_defstpmax;
    static const double m_armijofactor;
    static void LinMinNormalized(double & d, double & stp, const int n);
    static void LinMinNormalized(CRowDouble & d, double & stp, const int n);
    static void MCSrch(const int n, double & x, double & f, double & g, double & s, double & stp, double stpmax, double gtol, int & info, int & nfev, double & wa, CLinMinState & state, int & stage);
    static void MCSrch(const int n, CRowDouble & x, double & f, CRowDouble & g, CRowDouble & s, double & stp, double stpmax, double gtol, int & info, int & nfev, CRowDouble & wa, CLinMinState & state, int & stage);
    static void ArmijoCreate(const int n, double & x, const double f, double & s, const double stp, const double stpmax, const int ffmax, CArmijoState & state);
    static void ArmijoCreate(const int n, CRowDouble & x, const double f, CRowDouble & s, const double stp, const double stpmax, const int ffmax, CArmijoState & state);
    static void ArmijoResults(CArmijoState & state, int & info, double & stp, double & f);
    static bool ArmijoIteration(CArmijoState & state);
};

struct CFtPlan {
public:
    CMatrixInt m_entries;
    CRowDouble m_buffer;
    CRowDouble m_precr;
    CRowDouble m_preci;
    CRowDouble m_bluesteinpool;
    CFtPlan(void);
    ~CFtPlan();
    void Copy(CFtPlan & obj);
};

class CFtBase {
public:
    static const int m_coltype;
    static const int m_coloperandscnt;
    static const int m_coloperandsize;
    static const int m_colmicrovectorsize;
    static const int m_colparam0;
    static const int m_colparam1;
    static const int m_colparam2;
    static const int m_colparam3;
    static const int m_colscnt;
    static const int m_opend;
    static const int m_opcomplexreffft;
    static const int m_opbluesteinsfft;
    static const int m_opcomplexcodeletfft;
    static const int m_opcomplexcodelettwfft;
    static const int m_opradersfft;
    static const int m_opcomplextranspose;
    static const int m_opcomplexfftfactors;
    static const int m_opstart;
    static const int m_opjmp;
    static const int m_opparallelcall;
    static const int m_MaxRadix;
    static const int m_updatetw;
    static const int m_recursivethreshold;
    static const int m_raderthreshold;
    static const int m_ftbasecodeletrecommended;
    static const double m_ftbaseinefficiencyfactor;
    static const int m_ftbasemaxsmoothfactor;
    static void FtComplexFFTPlan(int n, int k, CFtPlan & plan);
    static void FtApplyPlan(CFtPlan & plan, double & a, int offsa, int repcnt);
    static void FtApplyPlan(CFtPlan & plan, CRowDouble & a, int offsa, int repcnt);
    static void FtBaseFactorize(const int n, const int tasktype, int & n1, int & n2);
    static bool FtBaseIsSmooth(int n);
    static int FtBaseFindSmooth(const int n);
    static int FtBaseFindSmoothEven(const int n);
    static double FtBaseGetFlopEstimate(const int n);
};

class CNearUnitYUnit {
public:
    static double NULog1p(const double x);
    static double NUExp1m(const double x);
    static double NUCos1m(const double x);
};

class CNTheory {
public:
    static void FindPrimitiveRootAndInverse(int n, int & proot, int & invproot);
};

struct CMLPBuffers {
public:
    int m_ChunkSize;
    int m_NTotal;
    int m_NIn;
    int m_NOut;
    int m_WCount;
    CRowDouble m_Batch4Buf;
    CRowDouble m_HPCBuf;
    CMatrixDouble m_XY;
    CMatrixDouble m_XY2;
    CRowDouble m_XYRow;
    CRowDouble m_X;
    CRowDouble m_Y;
    CRowDouble m_Desiredy;
    double m_E;
    CRowDouble m_G;
    CRowDouble m_Tmp0;
    CMLPBuffers(void);
    ~CMLPBuffers();
    void Copy(CMLPBuffers & obj);
};

class CHPCCores {
public:
    static void HPCPrepareChunkedGradient(CRowDouble & weights, int wcount, int NTotal, int NIn, int NOut, CMLPBuffers & buf);
    static void HPCFinalizeChunkedGradient(CMLPBuffers & buf, CRowDouble & grad);
};

class CKDTreeRequestBuffer {
public:
    int m_kneeded;
    int m_kcur;
    bool m_selfmatch;
    double m_rneeded;
    double m_approxf;
    double m_curdist;
    CRowInt m_idx;
    CRowDouble m_x;
    CRowDouble m_boxmin;
    CRowDouble m_boxmax;
    CRowDouble m_r;
    CRowDouble m_buf;
    CRowDouble m_curboxmin;
    CRowDouble m_curboxmax;
    CKDTreeRequestBuffer(void);
    ~CKDTreeRequestBuffer();
    void Init(void);
    void Copy(const CKDTreeRequestBuffer & obj);
};

class CKDTreeRequestBufferShell {
public:
    CKDTreeRequestBufferShell(void);
    CKDTreeRequestBufferShell(CKDTreeRequestBuffer & obj);
    ~CKDTreeRequestBufferShell();
};

class CKDTree {
public:
    int m_n;
    int m_nx;
    int m_ny;
    int m_normtype;
    int m_debugcounter;
    CRowInt m_tags;
    CRowDouble m_boxmin;
    CRowDouble m_boxmax;
    CRowInt m_nodes;
    CRowDouble m_splits;
    CKDTreeRequestBuffer m_innerbuf;
    CMatrixDouble m_xy;
    CKDTree(void);
    ~CKDTree();
    void Copy(const CKDTree & obj);
};

class CKDTreeShell {
public:
    CKDTreeShell(void);
    CKDTreeShell(CKDTree & obj);
    ~CKDTreeShell();
};

class CNearestNeighbor {
public:
    static const int m_splitnodesize;
    static const int m_kdtreefirstversion;
    static void KDTreeBuild(CMatrixDouble & xy, const int n, const int nx, const int ny, const int normtype, CKDTree & kdt);
    static void KDTreeBuildTagged(CMatrixDouble & xy, int & tags, const int n, const int nx, const int ny, const int normtype, CKDTree & kdt);
    static void KDTreeBuildTagged(CMatrixDouble & xy, CRowInt & tags, const int n, const int nx, const int ny, const int normtype, CKDTree & kdt);
    static void KDTreeCreateRequestBuffer(CKDTree & kdt, CKDTreeRequestBuffer & buf);
    static int KDTreeQueryKNN(CKDTree & kdt, double & x, const int k, const bool selfmatch = true);
    static int KDTreeQueryKNN(CKDTree & kdt, CRowDouble & x, const int k, const bool selfmatch = true);
    static int KDTreeTsQueryKNN(CKDTree & kdt, CKDTreeRequestBuffer & buf, CRowDouble & x, int k, bool selfmatch = true);
    static int KDTreeQueryRNN(CKDTree & kdt, double & x, const double r, const bool selfmatch = true);
    static int KDTreeQueryRNN(CKDTree & kdt, CRowDouble & x, const double r, const bool selfmatch = true);
    static int KDTreeQueryRNNU(CKDTree & kdt, double & x, const double r, const bool selfmatch = true);
    static int KDTreeQueryRNNU(CKDTree & kdt, CRowDouble & x, const double r, const bool selfmatch = true);
    static int KDTreeTsQueryRNN(CKDTree & kdt, CKDTreeRequestBuffer & buf, CRowDouble & x, const double r, const bool selfmatch = true);
    static int KDTreeTsQueryRNNU(CKDTree & kdt, CKDTreeRequestBuffer & buf, CRowDouble & x, const double r, const bool selfmatch = true);
    static int KDTreeQueryAKNN(CKDTree & kdt, double & x, int k, const bool selfmatch = true, const double eps = 0);
    static int KDTreeQueryAKNN(CKDTree & kdt, CRowDouble & x, int k, const bool selfmatch = true, const double eps = 0);
    static int KDTreeTsQueryAKNN(CKDTree & kdt, CKDTreeRequestBuffer & buf, CRowDouble & x, int k, const bool selfmatch = true, const double eps = 0);
    static int KDTreeQueryBox(CKDTree & kdt, double & boxmin, double & boxmax);
    static int KDTreeQueryBox(CKDTree & kdt, CRowDouble & boxmin, CRowDouble & boxmax);
    static int KDTreeTsQueryBox(CKDTree & kdt, CKDTreeRequestBuffer & buf, double & boxmin, double & boxmax);
    static int KDTreeTsQueryBox(CKDTree & kdt, CKDTreeRequestBuffer & buf, CRowDouble & boxmin, CRowDouble & boxmax);
    static void KDTreeQueryResultsX(CKDTree & kdt, CMatrixDouble & x);
    static void KDTreeTsQueryResultsX(CKDTree & kdt, CKDTreeRequestBuffer & buf, CMatrixDouble & x);
    static void KDTreeQueryResultsXY(CKDTree & kdt, CMatrixDouble & xy);
    static void KDTreeTsQueryResultsXY(CKDTree & kdt, CKDTreeRequestBuffer & buf, CMatrixDouble & xy);
    static void KDTreeQueryResultsTags(CKDTree & kdt, int & tags);
    static void KDTreeQueryResultsTags(CKDTree & kdt, CRowInt & tags);
    static void KDTreeTsQueryResultsTags(CKDTree & kdt, CKDTreeRequestBuffer & buf, int & tags);
    static void KDTreeTsQueryResultsTags(CKDTree & kdt, CKDTreeRequestBuffer & buf, CRowInt & tags);
    static void KDTreeQueryResultsDistances(CKDTree & kdt, double & r);
    static void KDTreeQueryResultsDistances(CKDTree & kdt, CRowDouble & r);
    static void KDTreeTsQueryResultsDistances(CKDTree & kdt, CKDTreeRequestBuffer & buf, double & r);
    static void KDTreeTsQueryResultsDistances(CKDTree & kdt, CKDTreeRequestBuffer & buf, CRowDouble & r);
    static void KDTreeQueryResultsXI(CKDTree & kdt, CMatrixDouble & x);
    static void KDTreeQueryResultsXYI(CKDTree & kdt, CMatrixDouble & xy);
    static void KDTreeQueryResultsTagsI(CKDTree & kdt, int & tags);
    static void KDTreeQueryResultsTagsI(CKDTree & kdt, CRowInt & tags);
    static void KDTreeQueryResultsDistancesI(CKDTree & kdt, double & r);
    static void KDTreeQueryResultsDistancesI(CKDTree & kdt, CRowDouble & r);
    static void KDTreeExploreBox(CKDTree & kdt, CRowDouble & boxmin, CRowDouble & boxmax);
    static void KDTreeExploreNodeType(CKDTree & kdt, int node, int & nodetype);
    static void KDTreeExploreLeaf(CKDTree & kdt, int node, CMatrixDouble & xy, int & k);
    static void KDTreeExploreSplit(CKDTree & kdt, int node, int & d, double & s, int & nodele, int & nodege);
    static void KDTreeAlloc(CSerializer & s, CKDTree & tree);
    static void KDTreeSerialize(CSerializer & s, CKDTree & tree);
    static void KDTreeUnserialize(CSerializer & s, CKDTree & tree);
};

struct RCommState {
public:
    int stage;
    CRowInt ia;
    bool ba;
    CRowDouble ra;
    CRowComplex ca;
    RCommState(void);
    ~RCommState();
    void Copy(const RCommState & obj);
};

class CAp {
public:
    static bool exception_happened;
    static int Len(const CRowInt & a);
    static int Len(const CRowDouble & a);
    static int Len(const CRowComplex & a);
    static int Rows(const CMatrixInt & a);
    static int Rows(const CMatrixDouble & a);
    static int Rows(const CMatrixComplex & a);
    static int Cols(const CMatrixInt & a);
    static int Cols(const CMatrixDouble & a);
    static int Cols(const CMatrixComplex & a);
    static void Swap(vector<double>& a, vector<double>& b);
    static void Swap(vector<float>& a, vector<float>& b);
    static void Swap(vector<complex>& a, vector<complex>& b);
    static void Swap(CMatrixInt & a, CMatrixInt & b);
    static void Swap(CMatrixDouble & a, CMatrixDouble & b);
    static void Swap(CMatrixComplex & a, CMatrixComplex & b);
    static bool Assert(const bool cond);
    static bool Assert(const bool cond, const string s);
    static bool SetErrorFlag(bool & flag, bool cond, string xdesc);
    static void SetErrorFlagDiff(bool & flag, double val, double refval, double tol, double s);
    static int ThresHoldToDPS(const double threshold);
    static string StringJoin(const string sep, const string & a);
    static string Format(const complex & a, const int dps);
    static string Format(const bool & a);
    static string Format(const int & a);
    static string Format(const double & a, const int dps);
    static string Format(const vector<double>& a, const int dps);
    static string Format(const complex & a, const int dps);
    static string Format(const vector<complex>& a, const int dps);
    static string FormatB(CMatrixInt & a);
    static string Format(CMatrixInt & a);
    static string Format(CMatrixDouble & a, const int dps);
    static string Format(CMatrixComplex & a, const int dps);
    static bool IsSymmetric(const CMatrixDouble & a);
    static bool IsHermitian(const CMatrixComplex & a);
    static bool ForceSymmetric(CMatrixDouble & a);
    static bool ForceHermitian(CMatrixComplex & a);
    static void TraceFile(string tags, string filename);
    static void TraceDisable(void);
    static bool IsTraceEnabled(string tag);
    static void Trace(string s);
};

class CHighQualityRandState {
public:
    int m_s1;
    int m_s2;
    double m_v;
    int m_magicv;
    CHighQualityRandState(void);
    ~CHighQualityRandState();
    void Copy(const CHighQualityRandState & obj);
};

class CHighQualityRandStateShell {
public:
    CHighQualityRandStateShell(void);
    CHighQualityRandStateShell(CHighQualityRandState & obj);
    ~CHighQualityRandStateShell();
};

class CHighQualityRand {
public:
    static const int m_HQRndMax;
    static const int m_HQRndM1;
    static const int m_HQRndM2;
    static const int m_HQRndMagic;
    static void HQRndRandomize(CHighQualityRandState & state);
    static void HQRndSeed(const int s1, const int s2, CHighQualityRandState & state);
    static double HQRndUniformR(CHighQualityRandState & state);
    static int HQRndUniformI(CHighQualityRandState & state, const int n);
    static double HQRndNormal(CHighQualityRandState & state);
    static void HQRndNormalV(CHighQualityRandState & state, int n, CRowDouble & x);
    static void HQRndNormalM(CHighQualityRandState & state, int m, int n, CMatrixDouble & x);
    static void HQRndUnit2(CHighQualityRandState & state, double & x, double & y);
    static void HQRndNormal2(CHighQualityRandState & state, double & x1, double & x2);
    static double HQRndExponential(CHighQualityRandState & state, const double lambdav);
    static double HQRndDiscrete(CHighQualityRandState & state, int n, CRowDouble & x);
    static double HQRndContinuous(CHighQualityRandState & state, int n, CRowDouble & x);
};

class CMath {
public:
    static bool m_first_call;
    static double m_last;
    static CHighQualityRandState m_state;
    static const double m_machineepsilon;
    static const double m_maxrealnumber;
    static const double m_minrealnumber;
    static bool IsFinite(const double d);
    static double RandomReal(void);
    static int RandomInteger(const int n);
    static double Sqr(const double x);
    static double AbsComplex(const complex z);
    static double AbsComplex(const double r);
    static complex Conj(const complex z);
    static complex Csqr(const complex z);
};

class CSerializer {
public:
    CSerializer(void);
    ~CSerializer();
    void ClearBuffers(void);
    void Alloc_Start(void);
    void Alloc_Entry(void);
    void Alloc_Byte_Array(char & a);
    void SStart_Str(void);
    void UStart_Str(const string s);
    void Reset(void);
    void Stop(void);
    void Serialize_Bool(const bool v);
    void Serialize_Int(const int v);
    void Serialize_Double(const double v);
    bool Unserialize_Bool(void);
    int Unserialize_Int(void);
    double Unserialize_Double(void);
    string Get_String(void);
};

class BitConverter {
public:
    static void GetBytes(const int d, uchar & bytes);
    static void GetBytes(const double d, uchar & bytes);
    static int ToInt32(uchar & bytes);
    static double ToDouble(uchar & bytes);
    static bool IsLittleEndian(void);
};

class CInfOrNaN {
public:
    static bool IsPositiveInfinity(const double x);
    static bool IsNegativeInfinity(const double x);
    static bool IsInfinity(const double x);
    static bool IsNaN(const double x);
    static double PositiveInfinity(void);
    static double NegativeInfinity(void);
    static double NaN(void);
};

struct al_complex {
public:
    double re;
    double im;
    al_complex(void);
    al_complex(const double x);
    al_complex(const double x, const double y);
    ~al_complex();
    void Copy(const al_complex & rhs);
    bool Eq(const al_complex & lhs, const al_complex & rhs);
    bool NotEq(const al_complex & lhs, const al_complex & rhs);
    al_complex Add(const al_complex & lhs, const al_complex & rhs);
    al_complex Sub(const al_complex & lhs, const al_complex & rhs);
    al_complex Mul(const al_complex & lhs, const al_complex & rhs);
    al_complex Div(const al_complex & lhs, const al_complex & rhs);
    al_complex Conjugate(void);
};

struct CCVReport {
public:
    double m_RelCLSError;
    double m_AvgCE;
    double m_RMSError;
    double m_AvgError;
    double m_AvgRelError;
    CCVReport(void);
    ~CCVReport();
    void Copy(const CCVReport & obj);
};

class CBdSS {
public:
    static void DSErrAllocate(const int nclasses, double & buf);
    static void DSErrAllocate(const int nclasses, CRowDouble & buf);
    static void DSErrAccumulate(double & buf, double & y, double & desiredy);
    static void DSErrAccumulate(CRowDouble & buf, CRowDouble & y, CRowDouble & desiredy);
    static void DSErrFinish(double & buf);
    static void DSErrFinish(CRowDouble & buf);
    static void DSNormalize(CMatrixDouble & xy, const int npoints, const int nvars, int & info, double & means, double & sigmas);
    static void DSNormalize(CMatrixDouble & xy, const int npoints, const int nvars, int & info, CRowDouble & means, CRowDouble & sigmas);
    static void DSNormalizeC(CMatrixDouble & xy, const int npoints, const int nvars, int & info, double & means, double & sigmas);
    static void DSNormalizeC(CMatrixDouble & xy, const int npoints, const int nvars, int & info, CRowDouble & means, CRowDouble & sigmas);
    static double DSGetMeanMindIstance(CMatrixDouble & xy, const int npoints, const int nvars);
    static void DSTie(double & a, const int n, int & ties, int & tiecount, int & p1, int & p2);
    static void DSTie(CRowDouble & a, const int n, CRowInt & ties, int & tiecount, CRowInt & p1, CRowInt & p2);
    static void DSTieFastI(double & a, int & b, const int n, int & ties, int & tiecount, double & bufr, int & bufi);
    static void DSTieFastI(CRowDouble & a, CRowInt & b, const int n, CRowInt & ties, int & tiecount, CRowDouble & bufr, CRowInt & bufi);
    static void DSOptimalSplit2(double & ca, int & cc, const int n, int & info, double & threshold, double & pal, double & pbl, double & par, double & pbr, double & cve);
    static void DSOptimalSplit2(CRowDouble & ca, CRowInt & cc, const int n, int & info, double & threshold, double & pal, double & pbl, double & par, double & pbr, double & cve);
    static void DSOptimalSplit2Fast(double & a, int & c, int & tiesbuf, int & cntbuf, double & bufr, int & bufi, const int n, const int nc, double alpha, int & info, double & threshold, double & rms, double & cvrms);
    static void DSOptimalSplit2Fast(CRowDouble & a, CRowInt & c, CRowInt & tiesbuf, CRowInt & cntbuf, CRowDouble & bufr, CRowInt & bufi, const int n, const int nc, double alpha, int & info, double & threshold, double & rms, double & cvrms);
    static void DSSplitK(double & ca, int & cc, const int n, const int nc, int kmax, int & info, double & thresholds, int & ni, double & cve);
    static void DSSplitK(CRowDouble & ca, CRowInt & cc, const int n, const int nc, int kmax, int & info, CRowDouble & thresholds, int & ni, double & cve);
    static void DSOptimalSplitK(double & ca, int & cc, const int n, const int nc, int kmax, int & info, double & thresholds, int & ni, double & cve);
    static void DSOptimalSplitK(CRowDouble & ca, CRowInt & cc, const int n, const int nc, int kmax, int & info, CRowDouble & thresholds, int & ni, double & cve);
};

struct CDFWorkBuf {
public:
    CRowInt m_classpriors;
    CRowInt m_varpool;
    int m_varpoolsize;
    CRowInt m_trnset;
    int m_trnsize;
    CRowDouble m_trnlabelsr;
    CRowInt m_trnlabelsi;
    CRowInt m_oobset;
    int m_oobsize;
    CRowDouble m_ooblabelsr;
    CRowInt m_ooblabelsi;
    CRowDouble m_treebuf;
    CRowDouble m_curvals;
    CRowDouble m_bestvals;
    CRowInt m_tmp0i;
    CRowInt m_tmp1i;
    CRowDouble m_tmp0r;
    CRowDouble m_tmp1r;
    CRowDouble m_tmp2r;
    CRowDouble m_tmp3r;
    CRowInt m_tmpnrms2;
    CRowInt m_classtotals0;
    CRowInt m_classtotals1;
    CRowInt m_classtotals01;
    CDFWorkBuf(void);
    ~CDFWorkBuf();
    void Copy(const CDFWorkBuf & obj);
};

struct CDFVoteBuf {
public:
    CRowDouble m_trntotals;
    CRowDouble m_oobtotals;
    CRowInt m_trncounts;
    CRowInt m_oobcounts;
    CRowDouble m_giniimportances;
    CDFVoteBuf(void);
    ~CDFVoteBuf();
    void Copy(const CDFVoteBuf & obj);
};

struct CDFPermimpBuf {
public:
    CRowDouble m_losses;
    CRowDouble m_xraw;
    CRowDouble m_xdist;
    CRowDouble m_xcur;
    CRowDouble m_y;
    CRowDouble m_yv;
    CRowDouble m_targety;
    CRowInt m_startnodes;
    CDFPermimpBuf(void);
    ~CDFPermimpBuf();
    void Copy(const CDFPermimpBuf & obj);
};

struct CDFTreeBuf {
public:
    CRowDouble m_treebuf;
    int m_treeidx;
    CDFTreeBuf(void);
    ~CDFTreeBuf();
    void Copy(const CDFTreeBuf & obj);
};

struct CDecisionForestBuilder {
public:
    int m_DSType;
    int m_NPoints;
    int m_NVars;
    int m_NClasses;
    CRowDouble m_DSData;
    CRowDouble m_DSRVal;
    CRowInt m_DSIVal;
    int m_RDFAlgo;
    double m_RDFRatio;
    double m_RDFVars;
    int m_RDFGlobalSeed;
    int m_RDFSplitStrength;
    int m_RDFImportance;
    CRowDouble m_DSMin;
    CRowDouble m_DSMax;
    bool m_DSBinary;
    double m_DSRAvg;
    CRowInt m_DSCTotals;
    int m_RDFProgress;
    int m_RDFTotal;
    bool m_NeedIOBMatrix;
    CMatrixInt m_IOBMatrix;
    CRowInt m_VarImpShuffle2;
    CDFWorkBuf m_WorkBuf;
    CDFVoteBuf m_VoteBuf;
    CDFTreeBuf m_TreeBuf;
    CDecisionForestBuilder(void);
    ~CDecisionForestBuilder();
    void Copy(const CDecisionForestBuilder & obj);
};

struct CDecisionForestBuffer {
public:
    CRowDouble m_x;
    CRowDouble m_y;
    CDecisionForestBuffer(void);
    ~CDecisionForestBuffer();
    void Copy(const CDecisionForestBuffer & obj);
};

class CDecisionForest {
public:
    int m_ForestFormat;
    bool m_UseMantissa8;
    int m_NVars;
    int m_NClasses;
    int m_NTrees;
    int m_BufSize;
    CRowDouble m_Trees;
    CDecisionForestBuffer m_Buffer;
    CRowInt m_Trees8;
    CDecisionForest(void);
    ~CDecisionForest();
    void Copy(const CDecisionForest & obj);
};

class CDecisionForestShell {
public:
    CDecisionForestShell(void);
    CDecisionForestShell(CDecisionForest & obj);
    ~CDecisionForestShell();
};

class CDFReport {
public:
    double m_RelCLSError;
    double m_AvgCE;
    double m_RMSError;
    double m_AvgError;
    double m_AvgRelError;
    double m_oobrelclserror;
    double m_oobavgce;
    double m_oobrmserror;
    double m_oobavgerror;
    double m_oobavgrelerror;
    CRowInt m_topvars;
    CRowDouble m_varimportances;
    CDFReport(void);
    ~CDFReport();
    void Copy(const CDFReport & obj);
};

class CDFReportShell {
public:
    CDFReportShell(void);
    CDFReportShell(CDFReport & obj);
    ~CDFReportShell();
    double GetRelClsError(void);
    void SetRelClsError(const double d);
    double GetAvgCE(void);
    void SetAvgCE(const double d);
    double GetRMSError(void);
    void SetRMSError(const double d);
    double GetAvgError(void);
    void SetAvgError(const double d);
    double GetAvgRelError(void);
    void SetAvgRelError(const double d);
    double GetOOBRelClsError(void);
    void SetOOBRelClsError(const double d);
    double GetOOBAvgCE(void);
    void SetOOBAvgCE(const double d);
    double GetOOBRMSError(void);
    void SetOOBRMSError(const double d);
    double GetOOBAvgError(void);
    void SetOOBAvgError(const double d);
    double GetOOBAvgRelError(void);
    void SetOOBAvgRelError(const double d);
};

struct CDFInternalBuffers {
public:
    CRowDouble m_treebuf;
    CRowInt m_idxbuf;
    CRowDouble m_tmpbufr;
    CRowDouble m_tmpbufr2;
    CRowInt m_tmpbufi;
    CRowInt m_classibuf;
    CRowDouble m_sortrbuf;
    CRowDouble m_sortrbuf2;
    CRowInt m_sortibuf;
    CRowInt m_varpool;
    bool m_evsbin;
    CRowDouble m_evssplits;
    CDFInternalBuffers(void);
    ~CDFInternalBuffers();
    void Copy(const CDFInternalBuffers & obj);
};

class CDForest {
public:
    static const int m_InnerNodeWidth;
    static const int m_LeafNodeWdth;
    static const int m_DFUseStrongSplits;
    static const int m_DFUseEVS;
    static const int m_DFUncompressedV0;
    static const int m_DFCompressedV0;
    static const int m_NeedTrnGini;
    static const int m_NeedOOBGini;
    static const int m_NeedPermutation;
    static const int m_PermutationImportanceBatchSize;
    static void DFCreateBuffer(CDecisionForest & model, CDecisionForestBuffer & buf);
    static void DFBuilderCreate(CDecisionForestBuilder & s);
    static void DFBuilderSetDataset(CDecisionForestBuilder & s, CMatrixDouble & xy, int npoints, int nvars, int nclasses);
    static void DFBuilderSetRndVars(CDecisionForestBuilder & s, int rndvars);
    static void DFBuilderSetRndVarsRatio(CDecisionForestBuilder & s, double f);
    static void DFBuilderSetRndVarsAuto(CDecisionForestBuilder & s);
    static void DFBuilderSetSubsampleRatio(CDecisionForestBuilder & s, double f);
    static void DFBuilderSetSeed(CDecisionForestBuilder & s, int seedval);
    static void DFBuilderSetRDFAlgo(CDecisionForestBuilder & s, int algotype);
    static void DFBuilderSetRDFSplitStrength(CDecisionForestBuilder & s, int splitstrength);
    static void DFBuilderSetImportanceTrnGini(CDecisionForestBuilder & s);
    static void DFBuilderSetImportanceOOBGini(CDecisionForestBuilder & s);
    static void DFBuilderSetImportancePermutation(CDecisionForestBuilder & s);
    static void DFBuilderSetImportanceNone(CDecisionForestBuilder & s);
    static double DFBuilderGetProgress(CDecisionForestBuilder & s);
    static double DFBuilderPeekProgress(CDecisionForestBuilder & s);
    static void DFBuilderBuildRandomForest(CDecisionForestBuilder & s, int ntrees, CDecisionForest & df, CDFReport & rep);
    static double DFBinaryCompression(CDecisionForest & df);
    static double DFBinaryCompression8(CDecisionForest & df);
    static void DFProcess(CDecisionForest & df, double & x, double & y);
    static void DFProcess(CDecisionForest & df, CRowDouble & x, CRowDouble & y);
    static void DFProcessI(CDecisionForest & df, double & x, double & y);
    static void DFProcessI(CDecisionForest & df, CRowDouble & x, CRowDouble & y);
    static double DFProcess0(CDecisionForest & model, CRowDouble & x);
    static int DFClassify(CDecisionForest & model, CRowDouble & x);
    static double DFRelClsError(CDecisionForest & df, CMatrixDouble & xy, const int npoints);
    static double DFAvgCE(CDecisionForest & df, CMatrixDouble & xy, const int npoints);
    static double DFRMSError(CDecisionForest & df, CMatrixDouble & xy, const int npoints);
    static double DFAvgError(CDecisionForest & df, CMatrixDouble & xy, const int npoints);
    static double DFAvgRelError(CDecisionForest & df, CMatrixDouble & xy, const int npoints);
    static void DFCopy(CDecisionForest & df1, CDecisionForest & df2);
    static void DFAlloc(CSerializer & s, CDecisionForest & forest);
    static void DFSerialize(CSerializer & s, CDecisionForest & forest);
    static void DFUnserialize(CSerializer & s, CDecisionForest & forest);
    static void DFBuildRandomDecisionForest(CMatrixDouble & xy, int npoints, int nvars, int nclasses, int ntrees, double r, int & info, CDecisionForest & df, CDFReport & rep);
    static void DFBuildRandomDecisionForestX1(CMatrixDouble & xy, int npoints, int nvars, int nclasses, int ntrees, int nrndvars, double r, int & info, CDecisionForest & df, CDFReport & rep);
    static void DFBuildInternal(CMatrixDouble & xy, int npoints, int nvars, int nclasses, int ntrees, int samplesize, int nfeatures, int flags, int & info, CDecisionForest & df, CDFReport & rep);
};

class CKMeans {
public:
    static void KMeansGenerate(CMatrixDouble & xy, const int npoints, const int nvars, const int k, const int restarts, int & info, CMatrixDouble & c, int & xyc);
};

class CLDA {
public:
    static void FisherLDA(CMatrixDouble & xy, const int npoints, const int nvars, const int nclasses, int & info, double & w);
    static void FisherLDA(CMatrixDouble & xy, const int npoints, const int nvars, const int nclasses, int & info, CRowDouble & w);
    static void FisherLDAN(CMatrixDouble & xy, const int npoints, const int nvars, const int nclasses, int & info, CMatrixDouble & w);
};

class CLinearModel {
public:
    CRowDouble m_w;
    CLinearModel(void);
    ~CLinearModel();
    void Copy(const CLinearModel & obj);
};

class CLinearModelShell {
public:
    CLinearModelShell(void);
    CLinearModelShell(CLinearModel & obj);
    ~CLinearModelShell();
};

class CLRReport {
public:
    double m_RMSError;
    double m_AvgError;
    double m_AvgRelError;
    double m_cvrmserror;
    double m_cvavgerror;
    double m_cvavgrelerror;
    int m_ncvdefects;
    CRowInt m_cvdefects;
    CMatrixDouble m_c;
    CLRReport(void);
    ~CLRReport();
    void Copy(const CLRReport & obj);
};

class CLRReportShell {
public:
    CLRReportShell(void);
    CLRReportShell(CLRReport & obj);
    ~CLRReportShell();
    double GetRMSError(void);
    void SetRMSError(const double d);
    double GetAvgError(void);
    void SetAvgError(const double d);
    double GetAvgRelError(void);
    void SetAvgRelError(const double d);
    double GetCVRMSError(void);
    void SetCVRMSError(const double d);
    double GetCVAvgError(void);
    void SetCVAvgError(const double d);
    double GetCVAvgRelError(void);
    void SetCVAvgRelError(const double d);
    int GetNCVDEfects(void);
    void SetNCVDEfects(const int i);
};

class CLinReg {
public:
    static const int m_lrvnum;
    static void LRBuild(CMatrixDouble & xy, const int npoints, const int nvars, int & info, CLinearModel & lm, CLRReport & ar);
    static void LRBuildS(CMatrixDouble & xy, double & s, const int npoints, const int nvars, int & info, CLinearModel & lm, CLRReport & ar);
    static void LRBuildS(CMatrixDouble & xy, CRowDouble & s, const int npoints, const int nvars, int & info, CLinearModel & lm, CLRReport & ar);
    static void LRBuildZS(CMatrixDouble & xy, double & s, const int npoints, const int nvars, int & info, CLinearModel & lm, CLRReport & ar);
    static void LRBuildZS(CMatrixDouble & xy, CRowDouble & s, const int npoints, const int nvars, int & info, CLinearModel & lm, CLRReport & ar);
    static void LRBuildZ(CMatrixDouble & xy, const int npoints, const int nvars, int & info, CLinearModel & lm, CLRReport & ar);
    static void LRUnpack(CLinearModel & lm, double & v, int & nvars);
    static void LRUnpack(CLinearModel & lm, CRowDouble & v, int & nvars);
    static void LRPack(double & v, const int nvars, CLinearModel & lm);
    static void LRPack(CRowDouble & v, const int nvars, CLinearModel & lm);
    static double LRProcess(CLinearModel & lm, double & x);
    static double LRProcess(CLinearModel & lm, CRowDouble & x);
    static double LRRMSError(CLinearModel & lm, CMatrixDouble & xy, const int npoints);
    static double LRAvgError(CLinearModel & lm, CMatrixDouble & xy, const int npoints);
    static double LRAvgRelError(CLinearModel & lm, CMatrixDouble & xy, const int npoints);
    static void LRCopy(CLinearModel & lm1, CLinearModel & lm2);
    static void LRLines(CMatrixDouble & xy, double & s, const int n, int & info, double & a, double & b, double & vara, double & varb, double & covab, double & corrab, double & p);
    static void LRLines(CMatrixDouble & xy, CRowDouble & s, const int n, int & info, double & a, double & b, double & vara, double & varb, double & covab, double & corrab, double & p);
    static void LRLine(CMatrixDouble & xy, const int n, int & info, double & a, double & b);
};

struct CModelErrors {
public:
    double m_RelCLSError;
    double m_AvgCE;
    double m_RMSError;
    double m_AvgError;
    double m_AvgRelError;
    CModelErrors(void);
    ~CModelErrors();
    void Copy(const CModelErrors & obj);
};

struct CSMLPGrad {
public:
    double m_F;
    CRowDouble m_G;
    CSMLPGrad(void);
    ~CSMLPGrad();
    void Copy(const CSMLPGrad & obj);
};

class CMultilayerPerceptron {
public:
    int m_hlnetworktype;
    int m_hlnormtype;
    CModelErrors m_err;
    CSMLPGrad m_grad;
    CRowInt m_dummyidx;
    CRowInt m_hllayersizes;
    CRowInt m_hlconnections;
    CRowInt m_hlneurons;
    CRowInt m_integerbuf;
    CRowInt m_structinfo;
    CRowDouble m_weights;
    CRowDouble m_columnmeans;
    CRowDouble m_columnsigmas;
    CRowDouble m_neurons;
    CRowDouble m_dfdnet;
    CRowDouble m_derror;
    CRowDouble m_x;
    CRowDouble m_y;
    CRowDouble m_xyrow;
    CRowDouble m_nwbuf;
    CRowDouble m_rndbuf;
    CMatrixDouble m_xy;
    CMatrixDouble m_dummydxy;
    CSparseMatrix m_dummysxy;
    CMultilayerPerceptron(void);
    ~CMultilayerPerceptron();
    void Copy(const CMultilayerPerceptron & obj);
};

class CMultilayerPerceptronShell {
public:
    CMultilayerPerceptronShell(void);
    CMultilayerPerceptronShell(CMultilayerPerceptron & obj);
    ~CMultilayerPerceptronShell();
};

class CMLPBase {
public:
    static const int m_mlpvnum;
    static const int m_mlpfirstversion;
    static const int m_nfieldwidth;
    static const int m_hlconm_nfieldwidth;
    static const int m_hlm_nfieldwidth;
    static const int m_gradbasecasecost;
    static const int m_microbatchsize;
    static int MLPGradSplitCost(void);
    static int MLPGradSplitSize(void);
    static void MLPCreate0(const int nin, const int nout, CMultilayerPerceptron & network);
    static void MLPCreate1(const int nin, const int nhid, const int nout, CMultilayerPerceptron & network);
    static void MLPCreate2(const int nin, const int nhid1, const int nhid2, const int nout, CMultilayerPerceptron & network);
    static void MLPCreateB0(const int nin, const int nout, const double b, double d, CMultilayerPerceptron & network);
    static void MLPCreateB1(const int nin, const int nhid, const int nout, const double b, double d, CMultilayerPerceptron & network);
    static void MLPCreateB2(const int nin, const int nhid1, const int nhid2, const int nout, const double b, double d, CMultilayerPerceptron & network);
    static void MLPCreateR0(const int nin, const int nout, const double a, const double b, CMultilayerPerceptron & network);
    static void MLPCreateR1(const int nin, const int nhid, const int nout, const double a, const double b, CMultilayerPerceptron & network);
    static void MLPCreateR2(const int nin, const int nhid1, const int nhid2, const int nout, const double a, const double b, CMultilayerPerceptron & network);
    static void MLPCreateC0(const int nin, const int nout, CMultilayerPerceptron & network);
    static void MLPCreateC1(const int nin, const int nhid, const int nout, CMultilayerPerceptron & network);
    static void MLPCreateC2(const int nin, const int nhid1, const int nhid2, const int nout, CMultilayerPerceptron & network);
    static void MLPCopy(const CMultilayerPerceptron & network1, CMultilayerPerceptron & network2);
    static bool MLPSameArchitecture(CMultilayerPerceptron & network1, CMultilayerPerceptron & network2);
    static void MLPCopyTunableParameters(CMultilayerPerceptron & network1, CMultilayerPerceptron & network2);
    static void MLPExportTunableParameters(CMultilayerPerceptron & network, CRowDouble & p, int & pcount);
    static void MLPImportTunableParameters(CMultilayerPerceptron & network, CRowDouble & p);
    static void MLPSerializeOld(CMultilayerPerceptron & network, double & ra, int & rlen);
    static void MLPSerializeOld(CMultilayerPerceptron & network, CRowDouble & ra, int & rlen);
    static void MLPUnserializeOld(double & ra, CMultilayerPerceptron & network);
    static void MLPUnserializeOld(CRowDouble & ra, CMultilayerPerceptron & network);
    static void MLPRandomize(CMultilayerPerceptron & network);
    static void MLPRandomizeFull(CMultilayerPerceptron & network);
    static void MLPInitPreprocessor(CMultilayerPerceptron & network, CMatrixDouble & xy, const int ssize);
    static void MLPInitPreprocessorSparse(CMultilayerPerceptron & network, CSparseMatrix & xy, int ssize);
    static void MLPInitPreprocessorSubset(CMultilayerPerceptron & network, CMatrixDouble & xy, int setsize, CRowInt & idx, int subsetsize);
    static void MLPInitPreprocessorSparseSubset(CMultilayerPerceptron & network, CSparseMatrix & xy, int setsize, CRowInt & idx, int subsetsize);
    static void MLPProperties(CMultilayerPerceptron & network, int & nin, int & nout, int & wcount);
    static int MLPNTotal(CMultilayerPerceptron & network);
    static int MLPGetInputsCount(CMultilayerPerceptron & network);
    static int MLPGetOutputsCount(CMultilayerPerceptron & network);
    static int MLPGetWeightsCount(CMultilayerPerceptron & network);
    static bool MLPIsSoftMax(CMultilayerPerceptron & network);
    static int MLPGetLayersCount(CMultilayerPerceptron & network);
    static int MLPGetLayerSize(CMultilayerPerceptron & network, const int k);
    static void MLPGetInputScaling(CMultilayerPerceptron & network, const int i, double & mean, double & sigma);
    static void MLPGetOutputScaling(CMultilayerPerceptron & network, const int i, double & mean, double & sigma);
    static void MLPGetNeuronInfo(CMultilayerPerceptron & network, const int k, const int i, int & fkind, double & threshold);
    static double MLPGetWeight(CMultilayerPerceptron & network, const int k0, const int i0, const int k1, const int i1);
    static void MLPSetInputScaling(CMultilayerPerceptron & network, const int i, const double mean, double sigma);
    static void MLPSetOutputScaling(CMultilayerPerceptron & network, const int i, const double mean, double sigma);
    static void MLPSetNeuronInfo(CMultilayerPerceptron & network, const int k, const int i, const int fkind, const double threshold);
    static void MLPSetWeight(CMultilayerPerceptron & network, const int k0, const int i0, const int k1, const int i1, const double w);
    static void MLPActivationFunction(double net, const int k, double & f, double & df, double & d2f);
    static void MLPProcess(CMultilayerPerceptron & network, double & x, double & y);
    static void MLPProcess(CMultilayerPerceptron & network, CRowDouble & x, CRowDouble & y);
    static void MLPProcessI(CMultilayerPerceptron & network, double & x, double & y);
    static void MLPProcessI(CMultilayerPerceptron & network, CRowDouble & x, CRowDouble & y);
    static double MLPError(CMultilayerPerceptron & network, CMatrixDouble & xy, const int npoints);
    static double MLPErrorSparse(CMultilayerPerceptron & network, CSparseMatrix & xy, int npoints);
    static double MLPErrorN(CMultilayerPerceptron & network, CMatrixDouble & xy, const int ssize);
    static int MLPClsError(CMultilayerPerceptron & network, CMatrixDouble & xy, const int ssize);
    static double MLPRelClsError(CMultilayerPerceptron & network, CMatrixDouble & xy, const int npoints);
    static double MLPRelClsErrorSparse(CMultilayerPerceptron & network, CSparseMatrix & xy, int npoints);
    static double MLPAvgCE(CMultilayerPerceptron & network, CMatrixDouble & xy, const int npoints);
    static double MLPAvgCESparse(CMultilayerPerceptron & network, CSparseMatrix & xy, int npoints);
    static double MLPRMSError(CMultilayerPerceptron & network, CMatrixDouble & xy, const int npoints);
    static double MLPRMSErrorSparse(CMultilayerPerceptron & network, CSparseMatrix & xy, int npoints);
    static double MLPAvgError(CMultilayerPerceptron & network, CMatrixDouble & xy, const int npoints);
    static double MLPAvgErrorSparse(CMultilayerPerceptron & network, CSparseMatrix & xy, int npoints);
    static double MLPAvgRelError(CMultilayerPerceptron & network, CMatrixDouble & xy, const int npoints);
    static double MLPAvgRelErrorSparse(CMultilayerPerceptron & network, CSparseMatrix & xy, int npoints);
    static void MLPGrad(CMultilayerPerceptron & network, double & x, double & desiredy, double & e, double & grad);
    static void MLPGrad(CMultilayerPerceptron & network, CRowDouble & x, CRowDouble & desiredy, double & e, CRowDouble & grad);
    static void MLPGradN(CMultilayerPerceptron & network, double & x, double & desiredy, double & e, double & grad);
    static void MLPGradN(CMultilayerPerceptron & network, CRowDouble & x, CRowDouble & desiredy, double & e, CRowDouble & grad);
    static void MLPGradBatch(CMultilayerPerceptron & network, CMatrixDouble & xy, const int ssize, double & e, double & grad);
    static void MLPGradBatch(CMultilayerPerceptron & network, CMatrixDouble & xy, const int ssize, double & e, CRowDouble & grad);
    static void MLPGradBatchSparse(CMultilayerPerceptron & network, CSparseMatrix & xy, int ssize, double & e, CRowDouble & grad);
    static void MLPGradBatchSubset(CMultilayerPerceptron & network, CMatrixDouble & xy, int setsize, CRowInt & idx, int subsetsize, double & e, CRowDouble & grad);
    static void MLPGradBatchSparseSubset(CMultilayerPerceptron & network, CSparseMatrix & xy, int setsize, CRowInt & idx, int subsetsize, double & e, CRowDouble & grad);
    static void MLPGradBatchX(CMultilayerPerceptron & network, CMatrixDouble & densexy, CSparseMatrix & sparsexy, int datasetsize, int datasettype, CRowInt & idx, int subset0, int subset1, int subsettype, double & e, CRowDouble & grad);
    static void MLPGradNBatch(CMultilayerPerceptron & network, CMatrixDouble & xy, const int ssize, double & e, double & grad);
    static void MLPGradNBatch(CMultilayerPerceptron & network, CMatrixDouble & xy, const int ssize, double & e, CRowDouble & grad);
    static void MLPHessianNBatch(CMultilayerPerceptron & network, CMatrixDouble & xy, const int ssize, double & e, double & grad, CMatrixDouble & h);
    static void MLPHessianNBatch(CMultilayerPerceptron & network, CMatrixDouble & xy, const int ssize, double & e, CRowDouble & grad, CMatrixDouble & h);
    static void MLPHessianBatch(CMultilayerPerceptron & network, CMatrixDouble & xy, const int ssize, double & e, double & grad, CMatrixDouble & h);
    static void MLPHessianBatch(CMultilayerPerceptron & network, CMatrixDouble & xy, const int ssize, double & e, CRowDouble & grad, CMatrixDouble & h);
    static void MLPInternalProcessVector(int & structinfo, double & weights, double & columnmeans, double & columnsigmas, double & neurons, double & dfdnet, double & x, double & y);
    static void MLPInternalProcessVector(CRowInt & structinfo, CRowDouble & weights, CRowDouble & columnmeans, CRowDouble & columnsigmas, CRowDouble & neurons, CRowDouble & dfdnet, CRowDouble & x, CRowDouble & y);
    static void MLPAlloc(CSerializer & s, CMultilayerPerceptron & network);
    static void MLPSerialize(CSerializer & s, CMultilayerPerceptron & network);
    static void MLPUnserialize(CSerializer & s, CMultilayerPerceptron & network);
    static void MLPAllErrorsSubset(CMultilayerPerceptron & network, CMatrixDouble & xy, int setsize, CRowInt & subset, int subsetsize, CModelErrors & rep);
    static void MLPAllErrorsSparseSubset(CMultilayerPerceptron & network, CSparseMatrix & xy, int setsize, CRowInt & subset, int subsetsize, CModelErrors & rep);
    static double MLPErrorSubset(CMultilayerPerceptron & network, CMatrixDouble & xy, int setsize, CRowInt & subset, int subsetsize);
    static double MLPErrorSparseSubset(CMultilayerPerceptron & network, CSparseMatrix & xy, int setsize, CRowInt & subset, int subsetsize);
    static void MLPAllErrorsX(CMultilayerPerceptron & network, CMatrixDouble & densexy, CSparseMatrix & sparsexy, int datasetsize, int datasettype, CRowInt & idx, int subset0, int subset1, int subsettype, CModelErrors & rep);
};

class CLogitModel {
public:
    CRowDouble m_w;
    CLogitModel(void);
    ~CLogitModel();
    void Copy(const CLogitModel & obj);
};

class CLogitModelShell {
public:
    CLogitModelShell(void);
    CLogitModelShell(CLogitModel & obj);
    ~CLogitModelShell();
};

struct CLogitMCState {
public:
    bool m_brackt;
    bool m_stage1;
    int m_infoc;
    double m_dg;
    double m_dgm;
    double m_dginit;
    double m_dgtest;
    double m_dgx;
    double m_dgxm;
    double m_dgy;
    double m_dgym;
    double m_finit;
    double m_ftest1;
    double m_fm;
    double m_fx;
    double m_fxm;
    double m_fy;
    double m_fym;
    double m_stx;
    double m_sty;
    double m_stmin;
    double m_stmax;
    double m_width;
    double m_width1;
    double m_xtrapf;
    CLogitMCState(void);
    ~CLogitMCState();
    void Copy(const CLogitMCState & obj);
};

class CMNLReport {
public:
    int m_ngrad;
    int m_nhess;
    CMNLReport(void);
    ~CMNLReport();
    void Copy(CMNLReport & obj);
};

class CMNLReportShell {
public:
    CMNLReportShell(void);
    CMNLReportShell(CMNLReport & obj);
    ~CMNLReportShell();
    int GetNGrad(void);
    void SetNGrad(const int i);
    int GetNHess(void);
    void SetNHess(const int i);
};

class CLogit {
public:
    static const double m_xtol;
    static const double m_ftol;
    static const double m_gtol;
    static const int m_maxfev;
    static const double m_stpmin;
    static const double m_stpmax;
    static const int m_logitvnum;
    static void MNLTrainH(CMatrixDouble & xy, const int npoints, const int nvars, const int nclasses, int & info, CLogitModel & lm, CMNLReport & rep);
    static void MNLProcess(CLogitModel & lm, double & x, double & y);
    static void MNLProcess(CLogitModel & lm, CRowDouble & x, CRowDouble & y);
    static void MNLProcessI(CLogitModel & lm, double & x, double & y);
    static void MNLProcessI(CLogitModel & lm, CRowDouble & x, CRowDouble & y);
    static void MNLUnpack(CLogitModel & lm, CMatrixDouble & a, int & nvars, int & nclasses);
    static void MNLPack(CMatrixDouble & a, const int nvars, const int nclasses, CLogitModel & lm);
    static void MNLCopy(CLogitModel & lm1, CLogitModel & lm2);
    static double MNLAvgCE(CLogitModel & lm, CMatrixDouble & xy, const int npoints);
    static double MNLRelClsError(CLogitModel & lm, CMatrixDouble & xy, const int npoints);
    static double MNLRMSError(CLogitModel & lm, CMatrixDouble & xy, const int npoints);
    static double MNLAvgError(CLogitModel & lm, CMatrixDouble & xy, const int npoints);
    static double MNLAvgRelError(CLogitModel & lm, CMatrixDouble & xy, const int ssize);
    static int MNLClsError(CLogitModel & lm, CMatrixDouble & xy, const int npoints);
};

class CMCPDState {
public:
    int m_n;
    int m_npairs;
    int m_ccnt;
    double m_regterm;
    int m_repinneriterationscount;
    int m_repouteriterationscount;
    int m_repnfev;
    int m_repterminationtype;
    CMinBLEICState m_bs;
    CMinBLEICReport m_br;
    CRowInt m_states;
    CRowInt m_ct;
    CRowDouble m_pw;
    CRowDouble m_tmpp;
    CRowDouble m_effectivew;
    CRowDouble m_effectivebndl;
    CRowDouble m_effectivebndu;
    CRowInt m_effectivect;
    CRowDouble m_h;
    CMatrixDouble m_data;
    CMatrixDouble m_ec;
    CMatrixDouble m_bndl;
    CMatrixDouble m_bndu;
    CMatrixDouble m_c;
    CMatrixDouble m_priorp;
    CMatrixDouble m_effectivec;
    CMatrixDouble m_p;
    CMCPDState(void);
    ~CMCPDState();
    void Copy(const CMCPDState & obj);
};

class CMCPDStateShell {
public:
    CMCPDStateShell(void);
    CMCPDStateShell(CMCPDState & obj);
    ~CMCPDStateShell();
};

class CMCPDReport {
public:
    int m_inneriterationscount;
    int m_outeriterationscount;
    int m_nfev;
    int m_terminationtype;
    CMCPDReport(void);
    ~CMCPDReport();
    void Copy(const CMCPDReport & obj);
};

class CMCPDReportShell {
public:
    CMCPDReportShell(void);
    CMCPDReportShell(CMCPDReport & obj);
    ~CMCPDReportShell();
    int GetInnerIterationsCount(void);
    void SetInnerIterationsCount(const int i);
    int GetOuterIterationsCount(void);
    void SetOuterIterationsCount(const int i);
    int GetNFev(void);
    void SetNFev(const int i);
    int GetTerminationType(void);
    void SetTerminationType(const int i);
};

class CMarkovCPD {
public:
    static const double m_xtol;
    static void MCPDCreate(const int n, CMCPDState & s);
    static void MCPDCreateEntry(const int n, const int entrystate, CMCPDState & s);
    static void MCPDCreateExit(const int n, const int exitstate, CMCPDState & s);
    static void MCPDCreateEntryExit(const int n, const int entrystate, const int exitstate, CMCPDState & s);
    static void MCPDAddTrack(CMCPDState & s, CMatrixDouble & xy, const int k);
    static void MCPDSetEC(CMCPDState & s, CMatrixDouble & ec);
    static void MCPDAddEC(CMCPDState & s, const int i, const int j, const double c);
    static void MCPDSetBC(CMCPDState & s, CMatrixDouble & bndl, CMatrixDouble & bndu);
    static void MCPDAddBC(CMCPDState & s, const int i, const int j, double bndl, double bndu);
    static void MCPDSetLC(CMCPDState & s, CMatrixDouble & c, int & ct, const int k);
    static void MCPDSetLC(CMCPDState & s, CMatrixDouble & c, CRowInt & ct, const int k);
    static void MCPDSetTikhonovRegularizer(CMCPDState & s, const double v);
    static void MCPDSetPrior(CMCPDState & s, CMatrixDouble & cpp);
    static void MCPDSetPredictionWeights(CMCPDState & s, double & pw);
    static void MCPDSetPredictionWeights(CMCPDState & s, CRowDouble & pw);
    static void MCPDSolve(CMCPDState & s);
    static void MCPDResults(CMCPDState & s, CMatrixDouble & p, CMCPDReport & rep);
};

class CMLPReport {
public:
    double m_RelCLSError;
    double m_AvgCE;
    double m_RMSError;
    double m_AvgError;
    double m_AvgRelError;
    int m_ngrad;
    int m_nhess;
    int m_ncholesky;
    CMLPReport(void);
    ~CMLPReport();
    void Copy(const CMLPReport & obj);
};

class CMLPReportShell {
public:
    CMLPReportShell(void);
    CMLPReportShell(CMLPReport & obj);
    ~CMLPReportShell();
    int GetNGrad(void);
    void SetNGrad(const int i);
    int GetNHess(void);
    void SetNHess(const int i);
    int GetNCholesky(void);
    void SetNCholesky(const int i);
};

class CMLPCVReport {
public:
    double m_RelCLSError;
    double m_AvgCE;
    double m_RMSError;
    double m_AvgError;
    double m_AvgRelError;
    CMLPCVReport(void);
    ~CMLPCVReport();
    void Copy(const CMLPCVReport & obj);
};

class CMLPCVReportShell {
public:
    CMLPCVReportShell(void);
    CMLPCVReportShell(CMLPCVReport & obj);
    ~CMLPCVReportShell();
    double GetRelClsError(void);
    void SetRelClsError(const double d);
    double GetAvgCE(void);
    void SetAvgCE(const double d);
    double GetRMSError(void);
    void SetRMSError(const double d);
    double GetAvgError(void);
    void SetAvgError(const double d);
    double GetAvgRelError(void);
    void SetAvgRelError(const double d);
};

class CMLPEnsemble {
public:
    int m_ensemblesize;
    CMultilayerPerceptron m_network;
    CRowDouble m_weights;
    CRowDouble m_columnmeans;
    CRowDouble m_columnsigmas;
    CRowDouble m_y;
    CMLPEnsemble(void);
    ~CMLPEnsemble();
    void Copy(const CMLPEnsemble & obj);
};

class CMLPEnsembleShell {
public:
    CMLPEnsembleShell(void);
    CMLPEnsembleShell(CMLPEnsemble & obj);
    ~CMLPEnsembleShell();
};

struct CSMLPTrnSession {
public:
    CRowDouble m_bestparameters;
    double m_bestrmserror;
    bool m_randomizenetwork;
    CMultilayerPerceptron m_network;
    CMinLBFGSState m_optimizer;
    CMinLBFGSReport m_optimizerrep;
    CRowDouble m_wbuf0;
    CRowDouble m_wbuf1;
    CRowInt m_allminibatches;
    CRowInt m_currentminibatch;
    RCommState m_rstate;
    int m_algoused;
    int m_minibatchsize;
    CMLPReport m_mlprep;
    CRowInt m_trnsubset;
    CRowInt m_valsubset;
    CHighQualityRandState m_generator;
    CSMLPTrnSession(void);
    ~CSMLPTrnSession();
    void Copy(const CSMLPTrnSession & obj);
};

struct CMLPTrainer {
public:
    int m_nin;
    int m_nout;
    bool m_rcpar;
    int m_lbfgsfactor;
    double m_decay;
    double m_wstep;
    int m_maxits;
    int m_datatype;
    int m_npoints;
    CMatrixDouble m_densexy;
    CSparseMatrix m_sparsexy;
    CSMLPTrnSession m_session;
    int m_ngradbatch;
    CRowInt m_subset;
    int m_subsetsize;
    CRowInt m_valsubset;
    int m_valsubsetsize;
    int m_algokind;
    int m_minibatchsize;
    CMLPTrainer(void);
    ~CMLPTrainer();
    void Copy(const CMLPTrainer & obj);
};

class CMLPTrain {
public:
    static const double m_mindecay;
    static const int m_defaultlbfgsfactor;
    static void MLPTrainLM(CMultilayerPerceptron & network, CMatrixDouble & xy, const int npoints, double decay, const int restarts, int & info, CMLPReport & rep);
    static void MLPTrainLBFGS(CMultilayerPerceptron & network, CMatrixDouble & xy, const int npoints, double decay, const int restarts, const double wstep, int maxits, int & info, CMLPReport & rep);
    static void MLPTrainES(CMultilayerPerceptron & network, CMatrixDouble & trnxy, const int trnsize, CMatrixDouble & valxy, const int valsize, const double decay, int restarts, int & info, CMLPReport & rep);
    static void MLPKFoldCVLBFGS(CMultilayerPerceptron & network, CMatrixDouble & xy, const int npoints, const double decay, const int restarts, const double wstep, const int maxits, const int foldscount, int & info, CMLPReport & rep, CMLPCVReport & cvrep);
    static void MLPKFoldCVLM(CMultilayerPerceptron & network, CMatrixDouble & xy, const int npoints, const double decay, const int restarts, int foldscount, int & info, CMLPReport & rep, CMLPCVReport & cvrep);
    static void MLPCreateTrainer(int nin, int nout, CMLPTrainer & s);
    static void MLPCreateTrainerCls(int nin, int nclasses, CMLPTrainer & s);
    static void MLPSetDataset(CMLPTrainer & s, CMatrixDouble & xy, int npoints);
    static void MLPSetSparseDataset(CMLPTrainer & s, CSparseMatrix & xy, int npoints);
    static void MLPSetDecay(CMLPTrainer & s, double decay);
    static void MLPSetCond(CMLPTrainer & s, double wstep, int maxits);
    static void MLPSetAlgoBatch(CMLPTrainer & s);
    static void MLPTrainNetwork(CMLPTrainer & s, CMultilayerPerceptron & network, int nrestarts, CMLPReport & rep);
    static void MLPStartTraining(CMLPTrainer & s, CMultilayerPerceptron & network, bool randomstart);
    static bool MLPContinueTraining(CMLPTrainer & s, CMultilayerPerceptron & network);
    static void MLPEBaggingLM(CMLPEnsemble & ensemble, CMatrixDouble & xy, const int npoints, const double decay, const int restarts, int & info, CMLPReport & rep, CMLPCVReport & ooberrors);
    static void MLPEBaggingLBFGS(CMLPEnsemble & ensemble, CMatrixDouble & xy, const int npoints, const double decay, const int restarts, const double wstep, const int maxits, int & info, CMLPReport & rep, CMLPCVReport & ooberrors);
    static void MLPETrainES(CMLPEnsemble & ensemble, CMatrixDouble & xy, const int npoints, const double decay, const int restarts, int & info, CMLPReport & rep);
    static void MLPTrainEnsembleES(CMLPTrainer & s, CMLPEnsemble & ensemble, int nrestarts, CMLPReport & rep);
};

class CMLPE {
public:
    static const int m_mlpefirstversion;
    static void MLPECreate0(const int nin, const int nout, const int ensemblesize, CMLPEnsemble & ensemble);
    static void MLPECreate1(const int nin, const int nhid, const int nout, const int ensemblesize, CMLPEnsemble & ensemble);
    static void MLPECreate2(const int nin, const int nhid1, const int nhid2, const int nout, const int ensemblesize, CMLPEnsemble & ensemble);
    static void MLPECreateB0(const int nin, const int nout, const double b, const double d, const int ensemblesize, CMLPEnsemble & ensemble);
    static void MLPECreateB1(const int nin, const int nhid, const int nout, const double b, const double d, const int ensemblesize, CMLPEnsemble & ensemble);
    static void MLPECreateB2(const int nin, const int nhid1, const int nhid2, const int nout, const double b, const double d, const int ensemblesize, CMLPEnsemble & ensemble);
    static void MLPECreateR0(const int nin, const int nout, const double a, const double b, const int ensemblesize, CMLPEnsemble & ensemble);
    static void MLPECreateR1(const int nin, const int nhid, const int nout, const double a, const double b, const int ensemblesize, CMLPEnsemble & ensemble);
    static void MLPECreateR2(const int nin, const int nhid1, const int nhid2, const int nout, const double a, const double b, const int ensemblesize, CMLPEnsemble & ensemble);
    static void MLPECreateC0(const int nin, const int nout, const int ensemblesize, CMLPEnsemble & ensemble);
    static void MLPECreateC1(const int nin, const int nhid, const int nout, const int ensemblesize, CMLPEnsemble & ensemble);
    static void MLPECreateC2(const int nin, const int nhid1, const int nhid2, const int nout, const int ensemblesize, CMLPEnsemble & ensemble);
    static void MLPECreateFromNetwork(CMultilayerPerceptron & network, const int ensemblesize, CMLPEnsemble & ensemble);
    static void MLPECopy(CMLPEnsemble & ensemble1, CMLPEnsemble & ensemble2);
    static void MLPEAlloc(CSerializer & s, CMLPEnsemble & ensemble);
    static void MLPESerialize(CSerializer & s, CMLPEnsemble & ensemble);
    static void MLPEUnserialize(CSerializer & s, CMLPEnsemble & ensemble);
    static void MLPERandomize(CMLPEnsemble & ensemble);
    static void MLPEProperties(CMLPEnsemble & ensemble, int & nin, int & nout);
    static bool MLPEIsSoftMax(CMLPEnsemble & ensemble);
    static void MLPEProcess(CMLPEnsemble & ensemble, double & x, double & y);
    static void MLPEProcess(CMLPEnsemble & ensemble, CRowDouble & x, CRowDouble & y);
    static void MLPEProcessI(CMLPEnsemble & ensemble, double & x, double & y);
    static void MLPEProcessI(CMLPEnsemble & ensemble, CRowDouble & x, CRowDouble & y);
    static void MLPEAllErrorsX(CMLPEnsemble & ensemble, CMatrixDouble & densexy, CSparseMatrix & sparsexy, int datasetsize, int datasettype, CRowInt & idx, int subset0, int subset1, int subsettype, CModelErrors & rep);
    static void MLPEAllerrorsSparse(CMLPEnsemble & ensemble, CSparseMatrix & xy, int npoints, double & relcls, double & avgce, double & rms, double & avg, double & avgrel);
    static double MLPERelClsError(CMLPEnsemble & ensemble, CMatrixDouble & xy, const int npoints);
    static double MLPEAvgCE(CMLPEnsemble & ensemble, CMatrixDouble & xy, const int npoints);
    static double MLPERMSError(CMLPEnsemble & ensemble, CMatrixDouble & xy, const int npoints);
    static double MLPEAvgError(CMLPEnsemble & ensemble, CMatrixDouble & xy, const int npoints);
    static double MLPEAvgRelError(CMLPEnsemble & ensemble, CMatrixDouble & xy, const int npoints);
};

class CPCAnalysis {
public:
    static void PCABuildBasis(CMatrixDouble & x, const int npoints, const int nvars, int & info, double & s2, CMatrixDouble & v);
    static void PCABuildBasis(CMatrixDouble & x, const int npoints, const int nvars, int & info, CRowDouble & s2, CMatrixDouble & v);
    static void PCATruncatedSubSpace(CMatrixDouble & x, int npoints, int nvars, int nneeded, double eps, int maxits, CRowDouble & s2, CMatrixDouble & v);
    static void PCATruncatedSubSpaceSparse(CSparseMatrix & x, int npoints, int nvars, int nneeded, double eps, int maxits, CRowDouble & s2, CMatrixDouble & v);
};

struct CKmeansBuffers {
public:
    CMatrixDouble m_ct;
    CMatrixDouble m_ctbest;
    CRowInt m_xycbest;
    CRowInt m_xycprev;
    CRowDouble m_d2;
    CRowInt m_csizes;
    CApBuff m_initbuf;
    CKmeansBuffers(void);
    ~CKmeansBuffers();
    void Copy(const CKmeansBuffers & obj);
};

struct CClusterizerState {
public:
    int m_NPoints;
    int m_nfeatures;
    int m_disttype;
    CMatrixDouble m_xy;
    CMatrixDouble m_d;
    int m_ahcalgo;
    int m_kmeansrestarts;
    int m_kmeansmaxits;
    int m_kmeansinitalgo;
    bool m_kmeansdbgnoits;
    int m_seed;
    CMatrixDouble m_tmpd;
    CApBuff m_distbuf;
    CKmeansBuffers m_kmeanstmp;
    CClusterizerState(void);
    ~CClusterizerState();
    void Copy(const CClusterizerState & obj);
};

struct CAHCReport {
public:
    int m_terminationtype;
    int m_NPoints;
    CRowInt m_p;
    CMatrixInt m_z;
    CMatrixInt m_pz;
    CMatrixInt m_pm;
    CRowDouble m_mergedist;
    CAHCReport(void);
    ~CAHCReport();
    void Copy(const CAHCReport & obj);
};

struct CKmeansReport {
public:
    int m_NPoints;
    int m_nfeatures;
    int m_terminationtype;
    int m_iterationscount;
    double m_energy;
    int m_k;
    CMatrixDouble m_c;
    CRowInt m_cidx;
    CKmeansReport(void);
    ~CKmeansReport();
    void Copy(const CKmeansReport & obj);
};

class CClustering {
public:
    static const int m_kmeansblocksize;
    static const int m_kmeansparalleldim;
    static const int m_kmeansparallelk;
    static const double m_complexitymultiplier;
    static void ClusterizerCreate(CClusterizerState & s);
    static void ClusterizerSetPoints(CClusterizerState & s, CMatrixDouble & xy, int npoints, int nfeatures, int disttype);
    static void ClusterizerSetDistances(CClusterizerState & s, CMatrixDouble & d, int npoints, bool IsUpper);
    static void ClusterizerSetAHCAlgo(CClusterizerState & s, int algo);
    static void ClusterizerSetKMeansLimits(CClusterizerState & s, int restarts, int maxits);
    static void ClusterizerSetKMeansInit(CClusterizerState & s, int initalgo);
    static void ClusterizerSetSeed(CClusterizerState & s, int seed);
    static void ClusterizerRunAHC(CClusterizerState & s, CAHCReport & rep);
    static void ClusterizerRunKMeans(CClusterizerState & s, int k, CKmeansReport & rep);
    static void ClusterizerGetDistances(CMatrixDouble & xy, int npoints, int nfeatures, int disttype, CMatrixDouble & d);
    static void ClusterizerGetDistancesBuf(CApBuff & buf, CMatrixDouble & xy, int npoints, int nfeatures, int disttype, CMatrixDouble & d);
    static void ClusterizerGetKClusters(CAHCReport & rep, int k, CRowInt & cidx, CRowInt & cz);
    static void ClusterizerSeparatedByDist(CAHCReport & rep, double r, int & k, CRowInt & cidx, CRowInt & cz);
    static void ClusterizerSeparatedByCorr(CAHCReport & rep, double r, int & k, CRowInt & cidx, CRowInt & cz);
    static void KMeansGenerateInternal(CMatrixDouble & xy, int npoints, int nvars, int k, int initalgo, int seed, int maxits, int restarts, bool kmeansdbgnoits, int & info, int & iterationscount, CMatrixDouble & ccol, bool needccol, CMatrixDouble & crow, bool needcrow, CRowInt & xyc, double & energy, CKmeansBuffers & buf);
    static void KMeansUpdateDistances(CMatrixDouble & xy, int idx0, int idx1, int nvars, CMatrixDouble & ct, int cidx0, int cidx1, CRowInt & xyc, CRowDouble & xydist2);
};

class CFilters {
public:
    static void FilterSMA(CRowDouble & x, int n, int k);
    static void FilterEMA(CRowDouble & x, int n, double alpha);
    static void FilterLRMA(CRowDouble & x, int n, int k);
};

struct CSSAModel {
public:
    int m_NSequences;
    CRowInt m_SequenceIdx;
    CRowDouble m_SequenceData;
    int m_AlgoType;
    int m_WindowWidth;
    int m_RtPowerUp;
    int m_TopK;
    int m_PrecomputedWidth;
    int m_PrecomputedNBasis;
    CMatrixDouble m_PrecomputedBasis;
    int m_DefaultSubspaceits;
    int m_MemoryLimit;
    bool m_AreBasisAndSolverValid;
    CMatrixDouble m_Basis;
    CMatrixDouble m_BasisT;
    CRowDouble m_SV;
    CRowDouble m_ForecastA;
    int m_NBasis;
    CEigSubSpaceState m_Solver;
    CMatrixDouble m_XXT;
    CHighQualityRandState m_RS;
    int m_RngSeed;
    CRowInt m_Rtqueue;
    int m_RtqueueCnt;
    int m_RtqueueChunk;
    int m_DbgCntEVD;
    CRowDouble m_Tmp0;
    CRowDouble m_Tmp1;
    CEigSubSpaceReport m_SolverRep;
    CRowDouble m_AlongTrend;
    CRowDouble m_AlongNoise;
    CMatrixDouble m_AseqTrajectory;
    CMatrixDouble m_AseqTbProduct;
    CRowInt m_AseqCounts;
    CRowDouble m_FcTrend;
    CRowDouble m_FcNoise;
    CMatrixDouble m_FcTrendM;
    CMatrixDouble m_UxBatch;
    int m_UxBatchWidth;
    int m_UxBatchSize;
    int m_UxBatchLimit;
    CSSAModel(void);
    ~CSSAModel();
    void Copy(const CSSAModel & obj);
};

class CSSA {
public:
    static void SSACreate(CSSAModel & s);
    static void SSASetWindow(CSSAModel & s, int windowwidth);
    static void SSASetSeed(CSSAModel & s, int seed);
    static void SSASetPowerUpLength(CSSAModel & s, int pwlen);
    static void SSASetMemoryLimit(CSSAModel & s, int memlimit);
    static void SSAAddSequence(CSSAModel & s, CRowDouble & x, int n);
    static void SSAAppendPointAndUpdate(CSSAModel & s, double x, double updateits);
    static void SSAAppendSequenceAndUpdate(CSSAModel & s, CRowDouble & x, int nticks, double updateits);
    static void SSASetAlgoPrecomputed(CSSAModel & s, CMatrixDouble & a, int windowwidth, int nbasis);
    static void SSASetAlgoTopKDirect(CSSAModel & s, int topk);
    static void SSASetAlgoTopKRealtime(CSSAModel & s, int topk);
    static void SSAClearData(CSSAModel & s);
    static void SSAGetBasis(CSSAModel & s, CMatrixDouble & a, CRowDouble & sv, int & windowwidth, int & nbasis);
    static void SSAGetLRR(CSSAModel & s, CRowDouble & a, int & windowwidth);
    static void SSAAnalyzeLastWindow(CSSAModel & s, CRowDouble & trend, CRowDouble & noise, int & nticks);
    static void SSAAnalyzeLast(CSSAModel & s, int nticks, CRowDouble & trend, CRowDouble & noise);
    static void SSAAnalyzeSequence(CSSAModel & s, CRowDouble & data, int nticks, CRowDouble & trend, CRowDouble & noise);
    static void SSAForecastLast(CSSAModel & s, int nticks, CRowDouble & trend);
    static void SSAForecastSequence(CSSAModel & s, CRowDouble & data, int datalen, int forecastlen, bool applysmoothing, CRowDouble & trend);
    static void SSAForecastAvgLast(CSSAModel & s, int m, int nticks, CRowDouble & trend);
    static void SSAForecastAvgSequence(CSSAModel & s, CRowDouble & data, int datalen, int m, int forecastlen, bool applysmoothing, CRowDouble & trend);
};

struct CKNNBuffer {
public:
    CKDTreeRequestBuffer m_treebuf;
    CRowDouble m_x;
    CRowDouble m_y;
    CRowInt m_tags;
    CMatrixDouble m_xy;
    CKNNBuffer(void);
    ~CKNNBuffer();
    void Copy(const CKNNBuffer & obj);
};

struct CKNNBuilder {
public:
    int m_dstype;
    int m_npoints;
    int m_nvars;
    bool m_iscls;
    int m_nout;
    CMatrixDouble m_dsdata;
    CRowDouble m_dsrval;
    CRowInt m_dsival;
    int m_knnnrm;
    CKNNBuilder(void);
    ~CKNNBuilder();
    void Copy(const CKNNBuilder & obj);
};

struct CKNNModel {
public:
    int m_nvars;
    int m_nout;
    int m_k;
    double m_eps;
    bool m_iscls;
    bool m_isdummy;
    CKDTree m_tree;
    CKNNBuffer m_buffer;
    CKNNModel(void);
    ~CKNNModel();
    void Copy(const CKNNModel & obj);
};

struct CKNNReport {
public:
    double m_RelCLSError;
    double m_AvgCE;
    double m_RMSError;
    double m_AvgError;
    double m_AvgRelError;
    CKNNReport(void);
    ~CKNNReport();
    void Copy(const CKNNReport & obj);
};

class CKNN {
public:
    static const int m_knnfirstversion;
    static void KNNCreateBuffer(CKNNModel & model, CKNNBuffer & buf);
    static void KNNBuilderCreate(CKNNBuilder & s);
    static void KNNBuilderSetDatasetReg(CKNNBuilder & s, CMatrixDouble & xy, int npoints, int nvars, int nout);
    static void KNNBuilderSetDatasetCLS(CKNNBuilder & s, CMatrixDouble & xy, int npoints, int nvars, int nclasses);
    static void KNNBuilderSetNorm(CKNNBuilder & s, int nrmtype);
    static void KNNBuilderBuildKNNModel(CKNNBuilder & s, int k, double eps, CKNNModel & model, CKNNReport & rep);
    static void KNNRewriteKEps(CKNNModel & model, int k, double eps);
    static void KNNProcess(CKNNModel & model, CRowDouble & x, CRowDouble & y);
    static double KNNProcess0(CKNNModel & model, CRowDouble & x);
    static int KNNClassify(CKNNModel & model, CRowDouble & x);
    static void KNNProcessI(CKNNModel & model, CRowDouble & x, CRowDouble & y);
    static void KNNTsProcess(CKNNModel & model, CKNNBuffer & buf, CRowDouble & x, CRowDouble & y);
    static double KNNRelClsError(CKNNModel & model, CMatrixDouble & xy, int npoints);
    static double KNNAvgCE(CKNNModel & model, CMatrixDouble & xy, int npoints);
    static double KNNRMSError(CKNNModel & model, CMatrixDouble & xy, int npoints);
    static double KNNAvgError(CKNNModel & model, CMatrixDouble & xy, int npoints);
    static void KNNAllErrors(CKNNModel & model, CMatrixDouble & xy, int npoints, CKNNReport & rep);
    static void KNNSerialize(CSerializer & s, CKNNModel & model);
    static void KNNUnserialize(CSerializer & s, CKNNModel & model);
};

class CNDimensional_Func {
public:
    CNDimensional_Func(void);
    ~CNDimensional_Func();
    virtual void Func(double & x, double & func, CObject & obj);
    virtual void Func(CRowDouble & x, double & func, CObject & obj);
};

class CNDimensional_Grad {
public:
    CNDimensional_Grad(void);
    ~CNDimensional_Grad();
    virtual void Grad(double & x, double & func, double & grad, CObject & obj);
    virtual void Grad(CRowDouble & x, double & func, CRowDouble & grad, CObject & obj);
};

class CNDimensional_Hess {
public:
    CNDimensional_Hess(void);
    ~CNDimensional_Hess();
    virtual void Hess(double & x, double & func, double & grad, CMatrixDouble & hess, CObject & obj);
    virtual void Hess(CRowDouble & x, double & func, CRowDouble & grad, CMatrixDouble & hess, CObject & obj);
};

class CNDimensional_FVec {
public:
    CNDimensional_FVec(void);
    ~CNDimensional_FVec();
    virtual void FVec(double & x, double & fi, CObject & obj);
    virtual void FVec(CRowDouble & x, CRowDouble & fi, CObject & obj);
};

class CNDimensional_Jac {
public:
    CNDimensional_Jac(void);
    ~CNDimensional_Jac();
    virtual void Jac(double & x, double & fi, CMatrixDouble & jac, CObject & obj);
    virtual void Jac(CRowDouble & x, CRowDouble & fi, CMatrixDouble & jac, CObject & obj);
};

class CNDimensional_PFunc {
public:
    CNDimensional_PFunc(void);
    ~CNDimensional_PFunc();
    virtual void PFunc(double & c, double & x, double & func, CObject & obj);
    virtual void PFunc(CRowDouble & c, CRowDouble & x, double & func, CObject & obj);
};

class CNDimensional_PGrad {
public:
    CNDimensional_PGrad(void);
    ~CNDimensional_PGrad();
    virtual void PGrad(double & c, double & x, double & func, double & grad, CObject & obj);
    virtual void PGrad(CRowDouble & c, CRowDouble & x, double & func, CRowDouble & grad, CObject & obj);
};

class CNDimensional_PHess {
public:
    CNDimensional_PHess(void);
    ~CNDimensional_PHess();
    virtual void PHess(double & c, double & x, double & func, double & grad, CMatrixDouble & hess, CObject & obj);
    virtual void PHess(CRowDouble & c, CRowDouble & x, double & func, CRowDouble & grad, CMatrixDouble & hess, CObject & obj);
};

class CNDimensional_ODE_RP {
public:
    CNDimensional_ODE_RP(void);
    ~CNDimensional_ODE_RP();
    virtual void ODE_RP(double & y, double x, double & dy, CObject & obj);
};

class CIntegrator1_Func {
public:
    CIntegrator1_Func(void);
    ~CIntegrator1_Func();
    virtual void Int_Func(double x, double xminusa, double bminusx, double & y, CObject & obj);
};

class CNDimensional_Rep {
public:
    CNDimensional_Rep(void);
    ~CNDimensional_Rep();
    virtual void Rep(double & arg, double func, CObject & obj);
    virtual void Rep(CRowDouble & arg, double func, CObject & obj);
};

class CODESolverState {
public:
    int m_n;
    int m_m;
    double m_xscale;
    double m_h;
    double m_eps;
    bool m_fraceps;
    int m_repterminationtype;
    int m_repnfev;
    int m_solvertype;
    bool m_needdy;
    double m_x;
    RCommState m_rstate;
    double m_yc;
    double m_escale;
    double m_xg;
    double m_y;
    double m_dy;
    double m_yn;
    double m_yns;
    double m_rka;
    double m_rkc;
    double m_rkcs;
    CMatrixDouble m_ytbl;
    CMatrixDouble m_rkb;
    CMatrixDouble m_rkk;
    CODESolverState(void);
    ~CODESolverState();
    void Copy(CODESolverState & obj);
};

class CODESolverStateShell {
public:
    CODESolverStateShell(void);
    CODESolverStateShell(CODESolverState & obj);
    ~CODESolverStateShell();
    bool GetNeedDY(void);
    void SetNeedDY(const bool b);
    double GetX(void);
    void SetX(const double d);
};

class CODESolverReport {
public:
    int m_nfev;
    int m_terminationtype;
    CODESolverReport(void);
    ~CODESolverReport();
    void Copy(CODESolverReport & obj);
};

class CODESolverReportShell {
public:
    CODESolverReportShell(void);
    CODESolverReportShell(CODESolverReport & obj);
    ~CODESolverReportShell();
    int GetNFev(void);
    void SetNFev(const int i);
    int GetTerminationType(void);
    void SetTerminationType(const int i);
};

class CODESolver {
public:
    static const double m_odesolvermaxgrow;
    static const double m_odesolvermaxshrink;
    static void ODESolverRKCK(double & y, const int n, double & x, const int m, const double eps, const double h, CODESolverState & state);
    static void ODESolverResults(CODESolverState & state, int & m, double & xtbl, CMatrixDouble & ytbl, CODESolverReport & rep);
    static bool ODESolverIteration(CODESolverState & state);
};

class CFastFourierTransform {
public:
    static void FFTC1D(complex & a, const int n);
    static void FFTC1DInv(complex & a, const int n);
    static void FFTR1D(double & a, const int n, complex & f);
    static void FFTR1DInv(complex & f, const int n, double & a);
    static void FFTR1DInternalEven(double & a, const int n, double & buf, CFtPlan & plan);
    static void FFTR1DInvInternalEven(double & a, const int n, double & buf, CFtPlan & plan);
    static void FFTC1D(CRowComplex & a, const int n);
    static void FFTC1DInv(CRowComplex & a, const int n);
    static void FFTR1D(CRowDouble & a, const int n, CRowComplex & f);
    static void FFTR1DInv(CRowComplex & f, const int n, CRowDouble & a);
    static void FFTR1DInternalEven(CRowDouble & a, const int n, CRowDouble & buf, CFtPlan & plan);
    static void FFTR1DInvInternalEven(CRowDouble & a, const int n, CRowDouble & buf, CFtPlan & plan);
};

class CConv {
public:
    static void ConvC1D(complex & a, const int m, complex & b, const int n, complex & r);
    static void ConvC1DInv(complex & a, const int m, complex & b, const int n, complex & r);
    static void ConvC1DCircular(complex & s, const int m, complex & r, const int n, complex & c);
    static void ConvC1DCircularInv(complex & a, const int m, complex & b, const int n, complex & r);
    static void ConvR1D(double & a, const int m, double & b, const int n, double & r);
    static void ConvR1DInv(double & a, const int m, double & b, const int n, double & r);
    static void ConvR1DCircular(double & s, const int m, double & r, const int n, double & c);
    static void ConvR1DCircularInv(double & a, const int m, double & b, const int n, double & r);
    static void ConvC1DX(complex & a, const int m, complex & b, const int n, const bool circular, int alg, int q, complex & r);
    static void ConvR1DX(double & a, const int m, double & b, const int n, const bool circular, int alg, int q, double & r);
};

class CCorr {
public:
    static void CorrC1D(complex & signal, const int n, complex & pattern, const int m, complex & r);
    static void CorrC1DCircular(complex & signal, const int m, complex & pattern, const int n, complex & c);
    static void CorrR1D(double & signal, const int n, double & pattern, const int m, double & r);
    static void CorrR1DCircular(double & signal, const int m, double & pattern, const int n, double & c);
};

class CFastHartleyTransform {
public:
    static void FHTR1D(double & a, const int n);
    static void FHTR1DInv(double & a, const int n);
};

class CGaussQ {
public:
    static void GQGenerateRec(double & alpha, double & beta, const double mu0, const int n, int & info, double & x, double & w);
    static void GQGenerateGaussLobattoRec(double & calpha, double & cbeta, const double mu0, const double a, const double b, int n, int & info, double & x, double & w);
    static void GQGenerateGaussRadauRec(double & calpha, double & cbeta, const double mu0, const double a, int n, int & info, double & x, double & w);
    static void GQGenerateGaussLegendre(const int n, int & info, double & x, double & w);
    static void GQGenerateGaussJacobi(const int n, const double alpha, const double beta, int & info, double & x, double & w);
    static void GQGenerateGaussLaguerre(const int n, const double alpha, int & info, double & x, double & w);
    static void GQGenerateGaussHermite(const int n, int & info, double & x, double & w);
};

class CGaussKronrodQ {
public:
    static void GKQGenerateRec(double & calpha, double & cbeta, const double mu0, int n, int & info, double & x, double & wkronrod, double & wgauss);
    static void GKQGenerateGaussLegendre(const int n, int & info, double & x, double & wkronrod, double & wgauss);
    static void GKQGenerateGaussJacobi(const int n, const double alpha, const double beta, int & info, double & x, double & wkronrod, double & wgauss);
    static void GKQLegendreCalc(const int n, int & info, double & x, double & wkronrod, double & wgauss);
    static void GKQLegendreTbl(const int n, double & x, double & wkronrod, double & wgauss, double & eps);
};

class CAutoGKReport {
public:
    int m_terminationtype;
    int m_nfev;
    int m_nintervals;
    CAutoGKReport(void);
    ~CAutoGKReport();
    void Copy(CAutoGKReport & obj);
};

class CAutoGKReportShell {
public:
    CAutoGKReportShell(void);
    CAutoGKReportShell(CAutoGKReport & obj);
    ~CAutoGKReportShell();
    int GetTerminationType(void);
    void SetTerminationType(const int i);
    int GetNFev(void);
    void SetNFev(const int i);
    int GetNIntervals(void);
    void SetNIntervals(const int i);
};

struct CAutoGKInternalState {
public:
    double m_a;
    double m_b;
    double m_eps;
    double m_xwidth;
    double m_x;
    double m_f;
    int m_info;
    double m_r;
    int m_heapsize;
    int m_heapwidth;
    int m_heapused;
    double m_sumerr;
    double m_sumabs;
    int m_n;
    RCommState m_rstate;
    double m_qn;
    double m_wg;
    double m_wk;
    double m_wr;
    CMatrixDouble m_heap;
    CAutoGKInternalState(void);
    ~CAutoGKInternalState();
    void Copy(CAutoGKInternalState & obj);
};

class CAutoGKState {
public:
    double m_a;
    double m_b;
    double m_alpha;
    double m_beta;
    double m_xwidth;
    double m_x;
    double m_xminusa;
    double m_bminusx;
    bool m_needf;
    double m_f;
    int m_wrappermode;
    double m_v;
    int m_terminationtype;
    int m_nfev;
    int m_nintervals;
    CAutoGKInternalState m_internalstate;
    RCommState m_rstate;
    CAutoGKState(void);
    ~CAutoGKState();
    void Copy(CAutoGKState & obj);
};

class CAutoGKStateShell {
public:
    CAutoGKStateShell(void);
    CAutoGKStateShell(CAutoGKState & obj);
    ~CAutoGKStateShell();
    bool GetNeedF(void);
    void SetNeedF(const bool b);
    double GetX(void);
    void SetX(const double d);
    double GetXMinusA(void);
    void SetXMinusA(const double d);
    double GetBMinusX(void);
    void SetBMinusX(const double d);
    double GetF(void);
    void SetF(const double d);
};

class CAutoGK {
public:
    static const int m_maxsubintervals;
    static void AutoGKSmooth(const double a, const double b, CAutoGKState & state);
    static void AutoGKSmoothW(const double a, const double b, const double xwidth, CAutoGKState & state);
    static void AutoGKSingular(const double a, const double b, const double alpha, const double beta, CAutoGKState & state);
    static void AutoGKResults(CAutoGKState & state, double & v, CAutoGKReport & rep);
    static bool AutoGKIteration(CAutoGKState & state);
};

class CIDWCalcBuffer {
public:
    CRowDouble m_tsdist;
    CRowDouble m_tsw;
    CRowDouble m_tsyw;
    CRowDouble m_x;
    CRowDouble m_y;
    CMatrixDouble m_tsxy;
    CKDTreeRequestBuffer m_requestbuffer;
    CIDWCalcBuffer(void);
    ~CIDWCalcBuffer();
    void Copy(const CIDWCalcBuffer & obj);
};

class CIDWModel {
public:
    int m_algotype;
    int m_nlayers;
    int m_npoints;
    int m_nx;
    int m_ny;
    double m_lambda0;
    double m_lambdadecay;
    double m_lambdalast;
    double m_r0;
    double m_rdecay;
    double m_shepardp;
    CKDTree m_tree;
    CIDWCalcBuffer m_buffer;
    CRowDouble m_globalprior;
    CRowDouble m_shepardxy;
    CIDWModel(void);
    ~CIDWModel();
    void Copy(const CIDWModel & obj);
};

class CIDWModelShell {
public:
    CIDWModelShell(void);
    CIDWModelShell(CIDWModel & obj);
    ~CIDWModelShell();
};

struct CIDWBuilder {
public:
    int m_algotype;
    int m_nlayers;
    int m_npoints;
    int m_nx;
    int m_ny;
    int m_priortermtype;
    double m_lambda0;
    double m_lambdadecay;
    double m_lambdalast;
    double m_r0;
    double m_rdecay;
    double m_shepardp;
    CRowInt m_tmptags;
    CRowDouble m_priortermval;
    CRowDouble m_tmpdist;
    CRowDouble m_tmpmean;
    CRowDouble m_tmpw;
    CRowDouble m_tmpwy;
    CRowDouble m_tmpx;
    CRowDouble m_xy;
    CMatrixDouble m_tmplayers;
    CMatrixDouble m_tmpxy;
    CKDTree m_tmptree;
    CIDWBuilder(void);
    ~CIDWBuilder();
    void Copy(const CIDWBuilder & obj);
};

struct CIDWReport {
public:
    double m_avgerror;
    double m_maxerror;
    double m_r2;
    double m_rmserror;
    CIDWReport(void);
    ~CIDWReport();
    void Copy(const CIDWReport & obj);
};

class CIDWInt {
public:
    static const double m_w0;
    static const double m_meps;
    static const int m_defaultnlayers;
    static const double m_defaultlambda0;
    static void IDWCreateCalcBuffer(CIDWModel & s, CIDWCalcBuffer & buf);
    static void IDWBuilderCreate(int nx, int ny, CIDWBuilder & State);
    static void IDWBuilderSetNLayers(CIDWBuilder & State, int nlayers);
    static void IDWBuilderSetPoints(CIDWBuilder & State, CMatrixDouble & xy, int n);
    static void IDWBuilderSetAlgoMSTAB(CIDWBuilder & State, double srad);
    static void IDWBuilderSetAlgoTextBookShepard(CIDWBuilder & State, double p);
    static void IDWBuilderSetAlgoTextBookModShepard(CIDWBuilder & State, double r);
    static void IDWBuilderSetUserTerm(CIDWBuilder & State, double v);
    static void IDWBuilderSetConstTerm(CIDWBuilder & State);
    static void IDWBuilderSetZeroTerm(CIDWBuilder & State);
    static double IDWCalc1(CIDWModel & s, double x0);
    static double IDWCalc2(CIDWModel & s, double x0, double x1);
    static double IDWCalc3(CIDWModel & s, double x0, double x1, double x2);
    static void IDWCalc(CIDWModel & s, CRowDouble & x, CRowDouble & y);
    static void IDWCalcBuf(CIDWModel & s, CRowDouble & x, CRowDouble & y);
    static void IDWTsCalcBuf(CIDWModel & s, CIDWCalcBuffer & buf, CRowDouble & x, CRowDouble & y);
    static void IDWFit(CIDWBuilder & State, CIDWModel & model, CIDWReport & rep);
    static void IDWAlloc(CSerializer & s, CIDWModel & model);
    static void IDWSerialize(CSerializer & s, CIDWModel & model);
};

class CBarycentricInterpolant {
public:
    int m_n;
    double m_sy;
    double m_x;
    double m_y;
    double m_w;
    CBarycentricInterpolant(void);
    ~CBarycentricInterpolant();
    void Copy(CBarycentricInterpolant & obj);
};

class CBarycentricInterpolantShell {
public:
    CBarycentricInterpolantShell(void);
    CBarycentricInterpolantShell(CBarycentricInterpolant & obj);
    ~CBarycentricInterpolantShell();
};

class CRatInt {
public:
    static double BarycentricCalc(CBarycentricInterpolant & b, const double t);
    static void BarycentricDiff1(CBarycentricInterpolant & b, double t, double & f, double & df);
    static void BarycentricDiff2(CBarycentricInterpolant & b, const double t, double & f, double & df, double & d2f);
    static void BarycentricLinTransX(CBarycentricInterpolant & b, const double ca, const double cb);
    static void BarycentricLinTransY(CBarycentricInterpolant & b, const double ca, const double cb);
    static void BarycentricUnpack(CBarycentricInterpolant & b, int & n, double & x, double & y, double & w);
    static void BarycentricBuildXYW(double & x, double & y, double & w, const int n, CBarycentricInterpolant & b);
    static void BarycentricBuildFloaterHormann(double & x, double & y, const int n, int d, CBarycentricInterpolant & b);
    static void BarycentricCopy(CBarycentricInterpolant & b, CBarycentricInterpolant & b2);
};

class CPolInt {
public:
    static void PolynomialBar2Cheb(CBarycentricInterpolant & p, const double a, const double b, double & t);
    static void PolynomialCheb2Bar(double & t, const int n, const double a, const double b, CBarycentricInterpolant & p);
    static void PolynomialBar2Pow(CBarycentricInterpolant & p, const double c, const double s, double & a);
    static void PolynomialPow2Bar(double & a, const int n, const double c, const double s, CBarycentricInterpolant & p);
    static void PolynomialBuild(double & cx, double & cy, const int n, CBarycentricInterpolant & p);
    static void PolynomialBuildEqDist(const double a, const double b, double & y, const int n, CBarycentricInterpolant & p);
    static void PolynomialBuildCheb1(const double a, const double b, double & y, const int n, CBarycentricInterpolant & p);
    static void PolynomialBuildCheb2(const double a, const double b, double & y, const int n, CBarycentricInterpolant & p);
    static double PolynomialCalcEqDist(const double a, const double b, double & f, const int n, const double t);
    static double PolynomialCalcCheb1(const double a, const double b, double & f, const int n, double t);
    static double PolynomialCalcCheb2(const double a, const double b, double & f, const int n, double t);
};

class CSpline1DInterpolant {
public:
    bool m_periodic;
    int m_n;
    int m_k;
    int m_continuity;
    double m_x;
    double m_c;
    CSpline1DInterpolant(void);
    ~CSpline1DInterpolant();
    void Copy(CSpline1DInterpolant & obj);
};

class CSpline1DInterpolantShell {
public:
    CSpline1DInterpolantShell(void);
    CSpline1DInterpolantShell(CSpline1DInterpolant & obj);
    ~CSpline1DInterpolantShell();
};

class CSpline1DFitReport {
public:
    double m_taskrcond;
    double m_rmserror;
    double m_avgerror;
    double m_avgrelerror;
    double m_maxerror;
    CSpline1DFitReport(void);
    ~CSpline1DFitReport();
    void Copy(const CSpline1DFitReport & obj);
};

class CSpline1DFitReportShell {
public:
    CSpline1DFitReportShell(void);
    CSpline1DFitReportShell(CSpline1DFitReport & obj);
    ~CSpline1DFitReportShell();
    double GetTaskRCond(void);
    void SetTaskRCond(const double d);
    double GetRMSError(void);
    void SetRMSError(const double d);
    double GetAvgError(void);
    void SetAvgError(const double d);
    double GetAvgRelError(void);
    void SetAvgRelError(const double d);
    double GetMaxError(void);
    void SetMaxError(const double d);
};

class CSpline1D {
public:
    static const double m_lambdareg;
    static const double m_cholreg;
    static void Spline1DBuildLinear(double & cx, double & cy, const int n, CSpline1DInterpolant & c);
    static void Spline1DBuildCubic(double & cx, double & cy, const int n, const int boundltype, const double boundl, const int boundrtype, const double boundr, CSpline1DInterpolant & c);
    static void Spline1DGridDiffCubic(double & cx, double & cy, const int n, const int boundltype, const double boundl, const int boundrtype, const double boundr, double & d);
    static void Spline1DGridDiff2Cubic(double & cx, double & cy, const int n, const int boundltype, const double boundl, const int boundrtype, const double boundr, double & d1, double & d2);
    static void Spline1DConvCubic(double & cx, double & cy, const int n, const int boundltype, const double boundl, const int boundrtype, const double boundr, double & cx2, const int n2, double & y2);
    static void Spline1DConvDiffCubic(double & cx, double & cy, const int n, const int boundltype, const double boundl, const int boundrtype, const double boundr, double & cx2, const int n2, double & y2, double & d2);
    static void Spline1DConvDiff2Cubic(double & cx, double & cy, const int n, const int boundltype, const double boundl, const int boundrtype, const double boundr, double & cx2, const int n2, double & y2, double & d2, double & dd2);
    static void Spline1DBuildCatmullRom(double & cx, double & cy, const int n, const int boundtype, const double tension, CSpline1DInterpolant & c);
    static void Spline1DBuildHermite(double & cx, double & cy, double & cd, const int n, CSpline1DInterpolant & c);
    static void Spline1DBuildAkima(double & cx, double & cy, const int n, CSpline1DInterpolant & c);
    static double Spline1DCalc(CSpline1DInterpolant & c, double x);
    static void Spline1DDiff(CSpline1DInterpolant & c, double x, double & s, double & ds, double & d2s);
    static void Spline1DCopy(CSpline1DInterpolant & c, CSpline1DInterpolant & cc);
    static void Spline1DUnpack(CSpline1DInterpolant & c, int & n, CMatrixDouble & tbl);
    static void Spline1DLinTransX(CSpline1DInterpolant & c, const double a, const double b);
    static void Spline1DLinTransY(CSpline1DInterpolant & c, const double a, const double b);
    static double Spline1DIntegrate(CSpline1DInterpolant & c, double x);
    static void Spline1DFit(double & x, double & y, int n, int m, double lambdans, CSpline1DInterpolant & s, CSpline1DFitReport & rep);
    static void Spline1DBuildMonotone(double & X, double & Y, int n, CSpline1DInterpolant & c);
    static void Spline1DConvDiffInternal(double & xold, double & yold, double & dold, const int n, double & x2, const int n2, double & y, const bool needy, double & d1, const bool needd1, double & d2, const bool needd2);
    static void HeapSortDPoints(double & x, double & y, double & d, const int n);
    static void HeapSortDPoints(CRowDouble & x, CRowDouble & y, CRowDouble & d, const int n);
};

class CPolynomialFitReport {
public:
    double m_taskrcond;
    double m_rmserror;
    double m_avgerror;
    double m_avgrelerror;
    double m_maxerror;
    CPolynomialFitReport(void);
    ~CPolynomialFitReport();
    void Copy(CPolynomialFitReport & obj);
};

class CPolynomialFitReportShell {
public:
    CPolynomialFitReportShell(void);
    CPolynomialFitReportShell(CPolynomialFitReport & obj);
    ~CPolynomialFitReportShell();
    double GetTaskRCond(void);
    void SetTaskRCond(const double d);
    double GetRMSError(void);
    void SetRMSError(const double d);
    double GetAvgError(void);
    void SetAvgError(const double d);
    double GetAvgRelError(void);
    void SetAvgRelError(const double d);
    double GetMaxError(void);
    void SetMaxError(const double d);
};

class CBarycentricFitReport {
public:
    double m_taskrcond;
    int m_dbest;
    double m_rmserror;
    double m_avgerror;
    double m_avgrelerror;
    double m_maxerror;
    CBarycentricFitReport(void);
    ~CBarycentricFitReport();
    void Copy(CBarycentricFitReport & obj);
};

class CBarycentricFitReportShell {
public:
    CBarycentricFitReportShell(void);
    CBarycentricFitReportShell(CBarycentricFitReport & obj);
    ~CBarycentricFitReportShell();
    double GetTaskRCond(void);
    void SetTaskRCond(const double d);
    int GetDBest(void);
    void SetDBest(const int i);
    double GetRMSError(void);
    void SetRMSError(const double d);
    double GetAvgError(void);
    void SetAvgError(const double d);
    double GetAvgRelError(void);
    void SetAvgRelError(const double d);
    double GetMaxError(void);
    void SetMaxError(const double d);
};

class CLSFitReport {
public:
    int m_iterationscount;
    int m_varidx;
    double m_avgerror;
    double m_avgrelerror;
    double m_maxerror;
    double m_r2;
    double m_rmserror;
    double m_taskrcond;
    double m_wrmserror;
    CRowDouble m_errcurve;
    CRowDouble m_errpar;
    CRowDouble m_noise;
    CMatrixDouble m_covpar;
    CLSFitReport(void);
    ~CLSFitReport();
    void Copy(CLSFitReport & obj);
};

class CLSFitReportShell {
public:
    CLSFitReportShell(void);
    CLSFitReportShell(CLSFitReport & obj);
    ~CLSFitReportShell();
    double GetTaskRCond(void);
    void SetTaskRCond(const double d);
    int GetIterationsCount(void);
    void SetIterationsCount(const int i);
    double GetRMSError(void);
    void SetRMSError(const double d);
    double GetAvgError(void);
    void SetAvgError(const double d);
    double GetAvgRelError(void);
    void SetAvgRelError(const double d);
    double GetMaxError(void);
    void SetMaxError(const double d);
    double GetWRMSError(void);
    void SetWRMSError(const double d);
};

class CLSFitState {
public:
    int m_k;
    int m_m;
    int m_maxits;
    int m_nec;
    int m_nic;
    int m_npoints;
    int m_nweights;
    int m_optalgo;
    int m_pointindex;
    int m_prevalgo;
    int m_prevnpt;
    int m_repiterationscount;
    int m_repterminationtype;
    int m_repvaridx;
    int m_wits;
    int m_wkind;
    double m_diffstep;
    double m_epsx;
    double m_f;
    double m_repavgerror;
    double m_repavgrelerror;
    double m_repmaxerror;
    double m_reprmserror;
    double m_repwrmserror;
    double m_stpmax;
    double m_teststep;
    double m_tmpnoise;
    bool m_needf;
    bool m_needfg;
    bool m_needfgh;
    bool m_xrep;
    bool m_xupdated;
    RCommState m_rstate;
    CRowInt m_tmpct;
    CRowDouble m_bndl;
    CRowDouble m_bndu;
    CRowDouble m_c0;
    CRowDouble m_c1;
    CRowDouble m_c;
    CRowDouble m_g;
    CRowDouble m_s;
    CRowDouble m_taskw;
    CRowDouble m_tasky;
    CRowDouble m_tmp;
    CRowDouble m_tmpf;
    CRowDouble m_wcur;
    CRowDouble m_x;
    CMinLMState m_optstate;
    CMinLMReport m_optrep;
    CMatrixDouble m_cleic;
    CMatrixDouble m_h;
    CMatrixDouble m_taskx;
    CMatrixDouble m_tmpjac;
    CMatrixDouble m_tmpjacw;
    CMatInvReport m_invrep;
    CLSFitReport m_rep;
    CLSFitState(void);
    ~CLSFitState();
    void Copy(const CLSFitState & obj);
};

class CLSFitStateShell {
public:
    CLSFitStateShell(void);
    CLSFitStateShell(CLSFitState & obj);
    ~CLSFitStateShell();
    bool GetNeedF(void);
    void SetNeedF(const bool b);
    bool GetNeedFG(void);
    void SetNeedFG(const bool b);
    bool GetNeedFGH(void);
    void SetNeedFGH(const bool b);
    bool GetXUpdated(void);
    void SetXUpdated(const bool b);
    double GetF(void);
    void SetF(const double d);
};

class CLSFit {
public:
    static const int m_rfsmax;
    static void PolynomialFit(double & x, double & y, const int n, const int m, int & info, CBarycentricInterpolant & p, CPolynomialFitReport & rep);
    static void PolynomialFitWC(double & cx, double & cy, double & cw, const int n, double & cxc, double & cyc, int & dc, const int k, const int m, int & info, CBarycentricInterpolant & p, CPolynomialFitReport & rep);
    static void BarycentricFitFloaterHormannWC(double & x, double & y, double & w, const int n, double & xc, double & yc, int & dc, const int k, const int m, int & info, CBarycentricInterpolant & b, CBarycentricFitReport & rep);
    static void BarycentricFitFloaterHormann(double & x, double & y, const int n, const int m, int & info, CBarycentricInterpolant & b, CBarycentricFitReport & rep);
    static void Spline1DFitCubicWC(double & x, double & y, double & w, const int n, double & xc, double & yc, int & dc, const int k, const int m, int & info, CSpline1DInterpolant & s, CSpline1DFitReport & rep);
    static void Spline1DFitHermiteWC(double & x, double & y, double & w, const int n, double & xc, double & yc, int & dc, const int k, const int m, int & info, CSpline1DInterpolant & s, CSpline1DFitReport & rep);
    static void Spline1DFitCubic(double & x, double & y, const int n, const int m, int & info, CSpline1DInterpolant & s, CSpline1DFitReport & rep);
    static void Spline1DFitHermite(double & x, double & y, const int n, const int m, int & info, CSpline1DInterpolant & s, CSpline1DFitReport & rep);
    static void LSFitLinearW(double & y, double & w, CMatrixDouble & fmatrix, const int n, const int m, int & info, double & c, CLSFitReport & rep);
    static void LSFitLinearWC(double & cy, double & w, CMatrixDouble & fmatrix, CMatrixDouble & ccmatrix, const int n, const int m, const int k, int & info, double & c, CLSFitReport & rep);
    static void LSFitLinear(double & y, CMatrixDouble & fmatrix, const int n, const int m, int & info, double & c, CLSFitReport & rep);
    static void LSFitLinear(CRowDouble & y, CMatrixDouble & fmatrix, const int n, const int m, int & info, CRowDouble & c, CLSFitReport & rep);
    static void LSFitLinearC(double & cy, CMatrixDouble & fmatrix, CMatrixDouble & cmatrix, const int n, const int m, const int k, int & info, double & c, CLSFitReport & rep);
    static void LSFitCreateWF(CMatrixDouble & x, double & y, double & w, double & c, const int n, const int m, const int k, const double diffstep, CLSFitState & State);
    static void LSFitCreateF(CMatrixDouble & x, double & y, double & c, const int n, const int m, const int k, const double diffstep, CLSFitState & State);
    static void LSFitCreateWFG(CMatrixDouble & x, double & y, double & w, double & c, const int n, const int m, const int k, bool cheapfg, CLSFitState & State);
    static void LSFitCreateFG(CMatrixDouble & x, double & y, double & c, const int n, const int m, const int k, const bool cheapfg, CLSFitState & State);
    static void LSFitCreateWFGH(CMatrixDouble & x, double & y, double & w, double & c, const int n, const int m, const int k, CLSFitState & State);
    static void LSFitCreateFGH(CMatrixDouble & x, double & y, double & c, const int n, const int m, const int k, CLSFitState & State);
    static void LSFitSetCond(CLSFitState & State, const double epsx, const int maxits);
    static void LSFitSetStpMax(CLSFitState & State, const double stpmax);
    static void LSFitSetXRep(CLSFitState & State, const bool needxrep);
    static void LSFitSetScale(CLSFitState & State, double & s);
    static void LSFitSetBC(CLSFitState & State, double & bndl, double & bndu);
    static void LSFitResults(CLSFitState & State, int & info, double & c, CLSFitReport & rep);
    static void LSFitScaleXY(double & x, double & y, double & w, const int n, double & xc, double & yc, int & dc, const int k, double & xa, double & xb, double & sa, double & sb, double & xoriginal, double & yoriginal);
    static bool LSFitIteration(CLSFitState & State);
    static double LogisticCalc4(double x, double a, double b, double c, double d);
    static double LogisticCalc5(double x, double a, double b, double c, double d, double g);
    static void LogisticFit4(CRowDouble & X, CRowDouble & Y, int n, double & a, double & b, double & c, double & d, CLSFitReport & rep);
    static void LogisticFit4ec(CRowDouble & X, CRowDouble & Y, int n, double cnstrleft, double cnstrright, double & a, double & b, double & c, double & d, CLSFitReport & rep);
    static void LogisticFit5(CRowDouble & x, CRowDouble & Y, int n, double & a, double & b, double & c, double & d, double & g, CLSFitReport & rep);
    static void LogisticFit5ec(CRowDouble & X, CRowDouble & Y, int n, double cnstrleft, double cnstrright, double & a, double & b, double & c, double & d, double & g, CLSFitReport & rep);
    static void LogisticFit45x(CRowDouble & x, CRowDouble & y, int n, double cnstrleft, double cnstrright, bool is4pl, double lambdav, double epsx, int rscnt, double & a, double & b, double & c, double & d, double & g, CLSFitReport & rep);
};

class CPSpline2Interpolant {
public:
    int m_n;
    bool m_periodic;
    CSpline1DInterpolant m_x;
    CSpline1DInterpolant m_y;
    double m_p;
    CPSpline2Interpolant(void);
    ~CPSpline2Interpolant();
    void Copy(CPSpline2Interpolant& obj);
};

class CPSpline2InterpolantShell {
public:
    CPSpline2InterpolantShell(void);
    CPSpline2InterpolantShell(CPSpline2Interpolant& obj);
    ~CPSpline2InterpolantShell();
};

class CPSpline3Interpolant {
public:
    int m_n;
    bool m_periodic;
    CSpline1DInterpolant m_x;
    CSpline1DInterpolant m_y;
    CSpline1DInterpolant m_z;
    double m_p;
    CPSpline3Interpolant(void);
    ~CPSpline3Interpolant();
    void Copy(CPSpline3Interpolant& obj);
};

class CPSpline3InterpolantShell {
public:
    CPSpline3InterpolantShell(void);
    CPSpline3InterpolantShell(CPSpline3Interpolant& obj);
    ~CPSpline3InterpolantShell();
};

class CPSpline {
public:
    static void PSpline2Build(CMatrixDouble& cxy, const int n, const int st, const int pt, CPSpline2Interpolant& p);
    static void PSpline3Build(CMatrixDouble& cxy, const int n, const int st, const int pt, CPSpline3Interpolant& p);
    static void PSpline2BuildPeriodic(CMatrixDouble& cxy, const int n, const int st, const int pt, CPSpline2Interpolant& p);
    static void PSpline3BuildPeriodic(CMatrixDouble& cxy, const int n, const int st, const int pt, CPSpline3Interpolant& p);
    static void PSpline2ParameterValues(CPSpline2Interpolant& p, int & n, double & t);
    static void PSpline3ParameterValues(CPSpline3Interpolant& p, int & n, double & t);
    static void PSpline2Calc(CPSpline2Interpolant& p, double t, double& x, double& y);
    static void PSpline3Calc(CPSpline3Interpolant& p, double t, double& x, double& y, double& z);
    static void PSpline2Tangent(CPSpline2Interpolant& p, double t, double& x, double& y);
    static void PSpline3Tangent(CPSpline3Interpolant& p, double t, double& x, double& y, double& z);
    static void PSpline2Diff(CPSpline2Interpolant& p, double t, double& x, double& dx, double& y, double& dy);
    static void PSpline3Diff(CPSpline3Interpolant& p, double t, double& x, double& dx, double& y, double& dy, double& z, double& dz);
    static void PSpline2Diff2(CPSpline2Interpolant& p, double t, double& x, double& dx, double& d2x, double& y, double& dy, double& d2y);
    static void PSpline3Diff2(CPSpline3Interpolant& p, double t, double& x, double& dx, double& d2x, double& y, double& dy, double& d2y, double& z, double& dz, double& d2z);
    static double PSpline2ArcLength(CPSpline2Interpolant& p, const double a, const double b);
    static double PSpline3ArcLength(CPSpline3Interpolant& p, const double a, const double b);
    static void ParametricRDPFixed(CMatrixDouble& x, int n, int d, int stopm, double stopeps, CMatrixDouble& x2, int & idx2, int & nsections);
};

class CSpline2DInterpolant {
public:
    int m_d;
    int m_m;
    int m_n;
    int m_stype;
    CRowDouble m_f;
    CRowDouble m_x;
    CRowDouble m_y;
    CSpline2DInterpolant(void);
    ~CSpline2DInterpolant();
    void Copy(const CSpline2DInterpolant& obj);
};

class CSpline2DInterpolantShell {
public:
    CSpline2DInterpolantShell(void);
    CSpline2DInterpolantShell(CSpline2DInterpolant& obj);
    ~CSpline2DInterpolantShell();
};

class CSpline2DBuilder {
public:
    int m_areatype;
    int m_d;
    int m_gridtype;
    int m_interfacesize;
    int m_kx;
    int m_ky;
    int m_lsqrcnt;
    int m_maxcoresize;
    int m_nlayers;
    int m_npoints;
    int m_priorterm;
    int m_solvertype;
    double m_lambdabase;
    double m_priortermval;
    double m_smoothing;
    double m_sx;
    double m_sy;
    double m_xa;
    double m_xb;
    double m_ya;
    double m_yb;
    bool m_adddegreeoffreedom;
    CRowDouble m_xy;
    CSpline2DBuilder(void);
    ~CSpline2DBuilder();
    void Copy(const CSpline2DBuilder& obj);
};

struct CSpline2DFitReport {
public:
    double m_avgerror;
    double m_maxerror;
    double m_r2;
    double m_rmserror;
    CSpline2DFitReport(void);
    ~CSpline2DFitReport();
    void Copy(const CSpline2DFitReport& obj);
};

struct CSpline2DXDesignMatrix {
public:
    int m_blockwidth;
    int m_d;
    int m_kx;
    int m_ky;
    int m_maxbatch;
    int m_ndensebatches;
    int m_ndenserows;
    int m_npoints;
    int m_nrows;
    double m_lambdareg;
    CRowInt m_batchbases;
    CRowInt m_batches;
    CRowDouble m_tmp0;
    CRowDouble m_tmp1;
    CMatrixDouble m_tmp2;
    CMatrixDouble m_vals;
    CSpline2DXDesignMatrix(void);
    ~CSpline2DXDesignMatrix();
    void Copy(const CSpline2DXDesignMatrix& obj);
};

struct CSpline2DBlockLLSBuf {
public:
    CRowDouble m_cholbuf1;
    CRowDouble m_tmp0;
    CRowDouble m_tmp1;
    CMatrixDouble m_blockata;
    CMatrixDouble m_cholbuf2;
    CMatrixDouble m_trsmbuf2;
    CLinLSQRState m_solver;
    CLinLSQRReport m_solverrep;
    CSpline2DBlockLLSBuf(void);
    ~CSpline2DBlockLLSBuf();
    void Copy(const CSpline2DBlockLLSBuf& obj);
};

struct CSpline2DFastDDMBuf {
public:
    CSpline2DXDesignMatrix m_xdesignmatrix;
    CSpline2DInterpolant m_localmodel;
    CSpline2DFitReport m_dummyrep;
    CSpline2DBlockLLSBuf m_blockllsbuf;
    CRowDouble m_tmp0;
    CRowDouble m_tmpz;
    CSpline2DFastDDMBuf(void);
    ~CSpline2DFastDDMBuf();
    void Copy(const CSpline2DFastDDMBuf& obj);
};

class CSpline2D {
public:
    static const double m_cholreg;
    static const double m_lambdaregblocklls;
    static const double m_lambdaregfastddm;
    static const double m_lambdadecay;
    static void Spline2DBuildBilinear(double & cx, double & cy, CMatrixDouble& cf, const int m, const int n, CSpline2DInterpolant& c);
    static void Spline2DBuildBicubic(double & cx, double & cy, CMatrixDouble& cf, const int m, const int n, CSpline2DInterpolant& c);
    static double Spline2DCalc(CSpline2DInterpolant& c, const double x, const double y);
    static void Spline2DDiff(CSpline2DInterpolant& c, const double x, const double y, double& f, double& fx, double& fy, double& fxy);
    static void Spline2DCalcVBuf(CSpline2DInterpolant& c, double x, double y, CRowDouble& f);
    static double Spline2DCalcVi(CSpline2DInterpolant& c, double x, double y, int i);
    static void Spline2DCalcV(CSpline2DInterpolant& c, double x, double y, CRowDouble& f);
    static void Spline2DDiffVi(CSpline2DInterpolant& c, double x, double y, int i, double& f, double& fx, double& fy, double& fxy);
    static void Spline2DUnpack(CSpline2DInterpolant& c, int & m, int & n, CMatrixDouble& tbl);
    static void Spline2DLinTransXY(CSpline2DInterpolant& c, double ax, double bx, double ay, double by);
    static void Spline2DLinTransF(CSpline2DInterpolant& c, const double a, const double b);
    static void Spline2DCopy(CSpline2DInterpolant& c, CSpline2DInterpolant& cc);
    static void Spline2DResampleBicubic(CMatrixDouble& a, const int oldheight, const int oldwidth, CMatrixDouble& b, const int newheight, const int newwidth);
    static void Spline2DResampleBilinear(CMatrixDouble& a, const int oldheight, const int oldwidth, CMatrixDouble& b, const int newheight, const int newwidth);
    static void Spline2DBuildBilinearV(CRowDouble& x, int n, CRowDouble& y, int m, CRowDouble& f, int d, CSpline2DInterpolant& c);
    static void Spline2DBuildBicubicV(CRowDouble& x, int n, CRowDouble& y, int m, CRowDouble& f, int d, CSpline2DInterpolant& c);
    static void Spline2DUnpackV(CSpline2DInterpolant& c, int & m, int & n, int & d, CMatrixDouble& tbl);
    static void Spline2DBuilderCreate(int d, CSpline2DBuilder& State);
    static void Spline2DBuilderSetUserTerm(CSpline2DBuilder& State, double v);
    static void Spline2DBuilderSetLinTerm(CSpline2DBuilder& State);
    static void Spline2DBuilderSetConstTerm(CSpline2DBuilder& State);
    static void Spline2DBuilderSetZeroTerm(CSpline2DBuilder& State);
    static void Spline2DBuilderSetPoints(CSpline2DBuilder& State, CMatrixDouble& xy, int n);
    static void Spline2DBuilderSetAreaAuto(CSpline2DBuilder& State);
    static void Spline2DBuilderSetArea(CSpline2DBuilder& State, double xa, double xb, double ya, double yb);
    static void Spline2DBuilderSetGrid(CSpline2DBuilder& State, int kx, int ky);
    static void Spline2DBuilderSetAlgoFastDDM(CSpline2DBuilder& State, int nlayers, double lambdav);
    static void Spline2DBuilderSetAlgoBlockLLS(CSpline2DBuilder& State, double lambdans);
    static void Spline2DBuilderSetAlgoNaiveLLS(CSpline2DBuilder& State, double lambdans);
    static void Spline2DFit(CSpline2DBuilder& State, CSpline2DInterpolant& s, CSpline2DFitReport& rep);
    static void Spline2DAlloc(CSerializer& s, CSpline2DInterpolant& spline);
    static void Spline2DSerialize(CSerializer& s, CSpline2DInterpolant& spline);
    static void Spline2DUnserialize(CSerializer& s, CSpline2DInterpolant& spline);
};

class CIntFitServ {
public:
    static void LSFitScaleXY(CRowDouble& x, CRowDouble& y, CRowDouble& w, int n, CRowDouble& xc, CRowDouble& yc, CRowInt& dc, int k, double& xa, double& xb, double& sa, double& sb, CRowDouble& xoriginal, CRowDouble& yoriginal);
    static void BuildPriorTerm(CMatrixDouble& xy, int n, int nx, int ny, int modeltype, double priorval, CMatrixDouble& v);
    static void BuildPriorTerm1(CRowDouble& xy1, int n, int nx, int ny, int modeltype, double priorval, CMatrixDouble& v);
    static void BuildPriorTerm1(double & xy1, int n, int nx, int ny, int modeltype, double priorval, CMatrixDouble& v);
};

struct CFitSphereInternalReport {
public:
    int m_nfev;
    int m_iterationscount;
    CFitSphereInternalReport(void);
    ~CFitSphereInternalReport();
    void Copy(const CFitSphereInternalReport& obj);
};

class CFitSphere {
public:
    static void FitSphereLS(CMatrixDouble& xy, int npoints, int nx, CRowDouble& cx, double& r);
    static void FitSphereMC(CMatrixDouble& xy, int npoints, int nx, CRowDouble& cx, double& rhi);
    static void FitSphereMI(CMatrixDouble& xy, int npoints, int nx, CRowDouble& cx, double& rlo);
    static void FitSphereMZ(CMatrixDouble& xy, int npoints, int nx, CRowDouble& cx, double& rlo, double& rhi);
    static void FitSphereX(CMatrixDouble& xy, int npoints, int nx, int problemtype, double epsx, int aulits, double penalty, CRowDouble& cx, double& rlo, double& rhi);
    static void FitSphereInternal(CMatrixDouble& xy, int npoints, int nx, int problemtype, int solvertype, double epsx, int aulits, double penalty, CRowDouble& cx, double& rlo, double& rhi, CFitSphereInternalReport& rep);
};

struct CRBFV1CalcBuffer {
public:
    CRowInt m_calcbuftags;
    CRowDouble m_calcbufxcx;
    CMatrixDouble m_calcbufx;
    CKDTreeRequestBuffer m_requestbuffer;
    CRBFV1CalcBuffer(void);
    ~CRBFV1CalcBuffer();
    void Copy(const CRBFV1CalcBuffer& obj);
};

struct CRBFV1Model {
public:
    int m_nc;
    int m_nl;
    int m_nx;
    int m_ny;
    double m_rmax;
    CRowInt m_calcbuftags;
    CRowDouble m_calcbufxcx;
    CMatrixDouble m_calcbufx;
    CMatrixDouble m_v;
    CMatrixDouble m_wr;
    CMatrixDouble m_xc;
    CKDTree m_tree;
    CRBFV1Model(void);
    ~CRBFV1Model();
    void Copy(const CRBFV1Model& obj);
};

struct CGridCalc3v1Buf {
public:
    bool m_flag0;
    bool m_flag12;
    bool m_flag1;
    bool m_flag2;
    CRowInt m_calcbuftags;
    CRowDouble m_cx;
    CRowDouble m_expbuf0;
    CRowDouble m_expbuf1;
    CRowDouble m_expbuf2;
    CRowDouble m_tx;
    CRowDouble m_ty;
    CMatrixDouble m_calcbufx;
    CKDTreeRequestBuffer m_requestbuf;
    CGridCalc3v1Buf(void);
    ~CGridCalc3v1Buf();
    void Copy(const CGridCalc3v1Buf& obj);
};

class CRBFV1Report {
public:
    int m_acols;
    int m_annz;
    int m_arows;
    int m_iterationscount;
    int m_nmv;
    int m_terminationtype;
    CRBFV1Report(void);
    ~CRBFV1Report();
    void Copy(const CRBFV1Report& obj);
};

class CRBFV1 {
public:
    static const int m_mxnx;
    static const double m_rbffarradius;
    static const double m_rbfnearradius;
    static const double m_rbfmlradius;
    static const double m_minbasecasecost;
    static void RBFV1Create(int nx, int ny, CRBFV1Model& s);
    static void RBFV1CreateCalcBuffer(CRBFV1Model& s, CRBFV1CalcBuffer& buf);
    static void RBFV1BuildModel(CMatrixDouble& x, CMatrixDouble& y, int n, int aterm, int algorithmtype, int nlayers, double radvalue, double radzvalue, double lambdav, double epsort, double epserr, int maxits, CRBFV1Model& s, CRBFV1Report& rep);
    static void RBFV1Alloc(CSerializer& s, CRBFV1Model& model);
    static void RBFV1Serialize(CSerializer& s, CRBFV1Model& model);
    static void RBFV1Unserialize(CSerializer& s, CRBFV1Model& model);
    static double RBFV1Calc2(CRBFV1Model& s, double x0, double x1);
    static double RBFV1Calc3(CRBFV1Model& s, double x0, double x1, double x2);
    static void RBFV1CalcBuf(CRBFV1Model& s, CRowDouble& x, CRowDouble& y);
    static void RBFV1TSCalcBuf(CRBFV1Model& s, CRBFV1CalcBuffer& buf, CRowDouble& x, CRowDouble& y);
    static void RBFV1TSDiffBuf(CRBFV1Model& s, CRBFV1CalcBuffer& buf, CRowDouble& x, CRowDouble& y, CRowDouble& dy);
    static void RBFV1TSHessBuf(CRBFV1Model& s, CRBFV1CalcBuffer& buf, CRowDouble& x, CRowDouble& y, CRowDouble& dy, CRowDouble& d2y);
    static void RBFV1GridCalc2(CRBFV1Model& s, CRowDouble& x0, int n0, CRowDouble& x1, int n1, CMatrixDouble& y);
    static void RBFV1GridCalc3VRec(CRBFV1Model& s, CRowDouble& x0, int n0, CRowDouble& x1, int n1, CRowDouble& x2, int n2, CRowInt& blocks0, int block0a, int block0b, CRowInt& blocks1, int block1a, int block1b, CRowInt& blocks2, int block2a, int block2b, bool & flagy, bool sparsey, double searchradius, double avgfuncpernode, CGridCalc3v1Buf& bufpool, CRowDouble& y);
    static void RBFV1Unpack(CRBFV1Model& s, int & nx, int & ny, CMatrixDouble& xwr, int & nc, CMatrixDouble& v);
};

struct CRBFV2CalcBuffer {
public:
    double m_curdist2;
    CRowDouble m_curboxmax;
    CRowDouble m_curboxmin;
    CRowDouble m_x123;
    CRowDouble m_x;
    CRowDouble m_y123;
    CRBFV2CalcBuffer(void);
    ~CRBFV2CalcBuffer();
    void Copy(const CRBFV2CalcBuffer& obj);
};

struct CRBFV2Model {
public:
    int m_basisfunction;
    int m_bf;
    int m_maxits;
    int m_nh;
    int m_nx;
    int m_ny;
    double m_lambdareg;
    double m_supportr;
    CRowInt m_kdnodes;
    CRowInt m_kdroots;
    CRowDouble m_cw;
    CRowDouble m_kdboxmax;
    CRowDouble m_kdboxmin;
    CRowDouble m_kdsplits;
    CRowDouble m_ri;
    CRowDouble m_s;
    CRBFV2CalcBuffer m_calcbuf;
    CMatrixDouble m_v;
    CRBFV2Model(void);
    ~CRBFV2Model();
    void Copy(const CRBFV2Model& obj);
};

struct CRBFV2GridCalcBuffer {
public:
    bool m_rf;
    CRowDouble m_cx;
    CRowDouble m_rx;
    CRowDouble m_ry;
    CRowDouble m_tx;
    CRowDouble m_ty;
    CRBFV2CalcBuffer m_calcbuf;
    CRBFV2GridCalcBuffer(void);
    ~CRBFV2GridCalcBuffer();
    void Copy(const CRBFV2GridCalcBuffer& obj);
};

struct CRBFV2Report {
public:
    int m_terminationtype;
    double m_maxerror;
    double m_rmserror;
    CRBFV2Report(void);
    ~CRBFV2Report();
    void Copy(const CRBFV2Report& obj);
};

class CRBFV2 {
public:
    static const double m_defaultlambdareg;
    static const double m_defaultsupportr;
    static const int m_defaultmaxits;
    static const int m_defaultbf;
    static const int m_maxnodesize;
    static const double m_complexitymultiplier;
    static void RBFV2Create(int nx, int ny, CRBFV2Model& s);
    static void RBFV2CreateCalcBuffer(CRBFV2Model& s, CRBFV2CalcBuffer& buf);
    static void RBFV2BuildHierarchical(CMatrixDouble& x, CMatrixDouble& y, int n, CRowDouble& scalevec, int aterm, int nh, double rbase, double lambdans, CRBFV2Model& s, int & progress10000, bool& terminationrequest, CRBFV2Report& rep);
    static void RBFV2Alloc(CSerializer& s, CRBFV2Model& model);
    static void RBFV2Serialize(CSerializer& s, CRBFV2Model& model);
    static void RBFV2Unserialize(CSerializer& s, CRBFV2Model& model);
    static double RBFV2FarRadius(int bf);
    static double RBFV2NearRadius(int bf);
    static double RBFV2BasisFunc(int bf, double d2);
    static void RBFV2BasisFuncDiff2(int bf, double d2, double& f, double& df, double& d2f);
    static double RBFV2Calc1(CRBFV2Model& s, double x0);
    static double RBFV2Calc2(CRBFV2Model& s, double x0, double x1);
    static double RBFV2Calc3(CRBFV2Model& s, double x0, double x1, double x2);
    static void RBFV2CalcBuf(CRBFV2Model& s, CRowDouble& x, CRowDouble& y);
    static void RBFV2TsCalcBuf(CRBFV2Model& s, CRBFV2CalcBuffer& buf, CRowDouble& x, CRowDouble& y);
    static void RBFV2TsDiffBuf(CRBFV2Model& s, CRBFV2CalcBuffer& buf, CRowDouble& x, CRowDouble& y, CRowDouble& dy);
    static void RBFV2TSHessBuf(CRBFV2Model& s, CRBFV2CalcBuffer& buf, CRowDouble& x, CRowDouble& y, CRowDouble& dy, CRowDouble& d2y);
    static void RBFV2GridCalc2(CRBFV2Model& s, CRowDouble& x0, int n0, CRowDouble& x1, int n1, CMatrixDouble& y);
    static void RBFV2GridCalcVX(CRBFV2Model& s, CRowDouble& x0, int n0, CRowDouble& x1, int n1, CRowDouble& x2, int n2, CRowDouble& x3, int n3, bool & flagy, bool sparsey, CRowDouble& y);
    static void RBFV2PartialGridCalcRec(CRBFV2Model& s, CRowDouble& x0, int n0, CRowDouble& x1, int n1, CRowDouble& x2, int n2, CRowDouble& x3, int n3, CRowInt& blocks0, int block0a, int block0b, CRowInt& blocks1, int block1a, int block1b, CRowInt& blocks2, int block2a, int block2b, CRowInt& blocks3, int block3a, int block3b, bool & flagy, bool sparsey, int levelidx, double avgfuncpernode, CRBFV2GridCalcBuffer & bufpool, CRowDouble& y);
    static void RBFV2Unpack(CRBFV2Model& s, int & nx, int & ny, CMatrixDouble& xwr, int & nc, CMatrixDouble& v);
};

struct CRBF3EvaluatorBuffer {
public:
    CRowDouble m_coeffbuf;
    CRowDouble m_df1;
    CRowDouble m_df2;
    CRowDouble m_funcbuf;
    CRowDouble m_mindist2;
    CRowDouble m_wrkbuf;
    CRowDouble m_x;
    CMatrixDouble m_deltabuf;
    CRBF3EvaluatorBuffer(void);
    ~CRBF3EvaluatorBuffer();
    void Copy(const CRBF3EvaluatorBuffer& obj);
};

struct CRBF3Evaluator {
public:
    int m_chunksize;
    int m_functype;
    int m_n;
    int m_nx;
    int m_storagetype;
    double m_funcparam;
    CRowInt m_entireset;
    CRowDouble m_chunk1;
    CRBF3EvaluatorBuffer m_bufferpool;
    CMatrixDouble m_f;
    CMatrixDouble m_x;
    CMatrixDouble m_xtchunked;
    CRBF3Evaluator(void);
    ~CRBF3Evaluator();
    void Copy(const CRBF3Evaluator& obj);
};

struct CRBFV3CalcBuffer {
public:
    CRowDouble m_x123;
    CRowDouble m_x;
    CRowDouble m_xg;
    CRowDouble m_y123;
    CRowDouble m_yg;
    CRBF3EvaluatorBuffer m_evalbuf;
    CRBFV3CalcBuffer(void);
    ~CRBFV3CalcBuffer();
    void Copy(const CRBFV3CalcBuffer& obj);
};

struct CACBFBuffer {
public:
    bool m_bflags;
    CRowInt m_chosenneighbors;
    CRowInt m_currentnodes;
    CRowInt m_neighbors;
    CRowInt m_perm;
    CRowDouble m_choltmp;
    CRowDouble m_d;
    CRowDouble m_tau;
    CRowDouble m_tmpboxmax;
    CRowDouble m_tmpboxmin;
    CRowDouble m_y;
    CRowDouble m_z;
    CMatrixDouble m_atwrk;
    CMatrixDouble m_b;
    CMatrixDouble m_c;
    CMatrixDouble m_q1;
    CMatrixDouble m_q;
    CMatrixDouble m_r;
    CMatrixDouble m_wrkq;
    CMatrixDouble m_xq;
    CKDTreeRequestBuffer m_kdt1buf;
    CKDTreeRequestBuffer m_kdt2buf;
    CKDTreeRequestBuffer m_kdtbuf;
    CACBFBuffer(void);
    ~CACBFBuffer();
    void Copy(const CACBFBuffer& obj);
};

struct CACBFChunk {
public:
    int m_ntargetcols;
    int m_ntargetrows;
    CRowInt m_targetcols;
    CRowInt m_targetrows;
    CMatrixDouble m_s;
    CACBFChunk(void);
    ~CACBFChunk();
    void Copy(const CACBFChunk& obj);
};

struct CACBFBuilder {
public:
    int m_aterm;
    int m_batchsize;
    int m_functype;
    int m_ncorrection;
    int m_nglobal;
    int m_nlocal;
    int m_ntotal;
    int m_nx;
    double m_correctorgrowth;
    double m_funcparam;
    double m_globalgridseparation;
    double m_lambdav;
    double m_roughdatasetdiameter;
    bool m_dodetailedtrace;
    CRowInt m_globalgrid;
    CRowInt m_wrkidx;
    CMatrixDouble m_xx;
    CKDTree m_kdt1;
    CKDTree m_kdt2;
    CKDTree m_kdt;
    CACBFChunk m_chunkspool;
    CACBFChunk m_chunksproducer;
    CACBFBuffer m_bufferpool;
    CACBFBuilder(void);
    ~CACBFBuilder();
    void Copy(const CACBFBuilder& obj);
};

struct CRBF3DDMBuffer {
public:
    bool m_bflags;
    CKDTreeRequestBuffer m_kdtbuf;
    CRowInt m_idx2preccol;
    CRowDouble m_tmpboxmax;
    CRowDouble m_tmpboxmin;
    CRBF3DDMBuffer(void);
    ~CRBF3DDMBuffer();
    void Copy(const CRBF3DDMBuffer& obj);
};

struct CRBF3DDMSubproblem {
public:
    int m_decomposition;
    int m_ntarget;
    int m_nwork;
    bool m_isvalid;
    CRowInt m_targetnodes;
    CRowInt m_workingnodes;
    CRowInt m_wrkp;
    CMatrixDouble m_pred;
    CMatrixDouble m_qtrhs;
    CMatrixDouble m_regsystem;
    CMatrixDouble m_rhs;
    CMatrixDouble m_sol;
    CMatrixDouble m_wrklu;
    CMatrixDouble m_wrkq;
    CMatrixDouble m_wrkr;
    CRBF3DDMSubproblem(void);
    ~CRBF3DDMSubproblem();
    void Copy(const CRBF3DDMSubproblem& obj);
};

struct CRBF3DDMSolver {
public:
    int m_cntlu;
    int m_cntregqr;
    int m_ncorrector;
    int m_subproblemscnt;
    double m_lambdav;
    CRowInt m_corrnodes;
    CRBF3DDMSubproblem m_subproblemsbuffer;
    CRBF3DDMSubproblem m_subproblemspool;
    CRBF3DDMBuffer m_bufferpool;
    CMatrixDouble m_corrq;
    CMatrixDouble m_corrr;
    CMatrixDouble m_corrx;
    CMatrixDouble m_tmpres1;
    CMatrixDouble m_tmpupd1;
    CKDTree m_kdt;
    CRBF3DDMSolver(void);
    ~CRBF3DDMSolver();
    void Copy(const CRBF3DDMSolver& obj);
};

struct CRBFV3Model {
public:
    int m_bftype;
    int m_nc;
    int m_nx;
    int m_ny;
    double m_bfparam;
    bool m_dbgregqrusedforddm;
    CRowInt m_pointindexes;
    CRowDouble m_cw;
    CRowDouble m_s;
    CRBFV3CalcBuffer m_calcbuf;
    CRBF3Evaluator m_evaluator;
    CMatrixDouble m_v;
    CMatrixDouble m_wchunked;
    CRBFV3Model(void);
    ~CRBFV3Model();
    void Copy(const CRBFV3Model& obj);
};

struct CRBFV3Report {
public:
    int m_iterationscount;
    int m_terminationtype;
    double m_maxerror;
    double m_rmserror;
    CRBFV3Report(void);
    ~CRBFV3Report();
    void Copy(const CRBFV3Report& obj);
};

class CRBFV3 {
public:
    static const double m_epsred;
    static const int m_maxddmits;
    static const double m_polyharmonic2scale;
    static const int m_acbfparallelthreshold;
    static const int m_ddmparallelthreshold;
    static const int m_bfparallelthreshold;
    static void RBFV3Create(int nx, int ny, int bf, double bfp, CRBFV3Model& s);
    static void RBFV3CreateCalcBuffer(CRBFV3Model& s, CRBFV3CalcBuffer& buf);
    static void RBFV3Build(CMatrixDouble& xraw, CMatrixDouble& yraw, int nraw, CRowDouble& scaleraw, int bftype, double bfparamraw, double lambdavraw, int aterm, CRBFV3Model& s, int & progress10000, bool& terminationrequest, CRBFV3Report& rep);
    static void RBFV3Alloc(CSerializer& s, CRBFV3Model& model);
    static void RBFV3Serialize(CSerializer& s, CRBFV3Model& model);
    static void RBFV3Unserialize(CSerializer& s, CRBFV3Model& model);
    static double RBFV3Calc1(CRBFV3Model& s, double x0);
    static double RBFV3Calc2(CRBFV3Model& s, double x0, double x1);
    static double RBFV3Calc3(CRBFV3Model& s, double x0, double x1, double x2);
    static void RBFV3CalcBuf(CRBFV3Model& s, CRowDouble& x, CRowDouble& y);
    static void RBFV3TsCalcBuf(CRBFV3Model& s, CRBFV3CalcBuffer& buf, CRowDouble& x, CRowDouble& y);
    static void RBFV3TsDiffBuf(CRBFV3Model& s, CRBFV3CalcBuffer& buf, CRowDouble& x, CRowDouble& y, CRowDouble& dy);
    static void RBFV3TSHessBuf(CRBFV3Model& s, CRBFV3CalcBuffer& buf, CRowDouble& x, CRowDouble& y, CRowDouble& dy, CRowDouble& d2y);
    static void RBFV3GridCalcVX(CRBFV3Model& s, CRowDouble& x0, int n0, CRowDouble& x1, int n1, CRowDouble& x2, int n2, CRowDouble& x3, int n3, bool & flagy, bool sparsey, CRowDouble& y);
    static void RBFV3Unpack(CRBFV3Model& s, int & nx, int & ny, CMatrixDouble& xwr, int & nc, CMatrixDouble& v);
};

struct CRBFCalcBuffer {
public:
    int m_modelversion;
    CRowDouble m_dy;
    CRowDouble m_x;
    CRowDouble m_y;
    CRBFV3CalcBuffer m_bufv3;
    CRBFV2CalcBuffer m_bufv2;
    CRBFV1CalcBuffer m_bufv1;
    CRBFCalcBuffer(void);
    ~CRBFCalcBuffer();
    void Copy(const CRBFCalcBuffer& obj);
};

struct CRBFModel {
public:
    int m_algorithmtype;
    int m_aterm;
    int m_bftype;
    int m_maxits;
    int m_modelversion;
    int m_n;
    int m_nlayers;
    int m_nnmaxits;
    int m_nx;
    int m_ny;
    int m_progress10000;
    double m_bfparam;
    double m_epserr;
    double m_epsort;
    double m_lambdav;
    double m_radvalue;
    double m_radzvalue;
    bool m_hasscale;
    bool m_terminationrequest;
    CRBFV1Model m_model1;
    CRowDouble m_s;
    CRBFV3Model m_model3;
    CRBFV2Model m_model2;
    CRBFCalcBuffer m_calcbuf;
    CMatrixDouble m_x;
    CMatrixDouble m_y;
    CRBFModel(void);
    ~CRBFModel();
    void Copy(const CRBFModel& obj);
};

struct CRBFReport {
public:
    int m_acols;
    int m_annz;
    int m_arows;
    int m_iterationscount;
    int m_nmv;
    int m_terminationtype;
    double m_maxerror;
    double m_rmserror;
    CRBFReport(void);
    ~CRBFReport();
    void Copy(const CRBFReport& obj);
};

class CRBF {
public:
    static const double m_eps;
    static const double m_rbffarradius;
    static const int m_rbffirstversion;
    static const int m_rbfversion2;
    static const int m_rbfversion3;
    static void RBFCreate(int nx, int ny, CRBFModel& s);
    static void RBFCreateCalcBuffer(CRBFModel& s, CRBFCalcBuffer& buf);
    static void RBFSetPoints(CRBFModel& s, CMatrixDouble& xy, int n);
    static void RBFSetPointsAndScales(CRBFModel& r, CMatrixDouble& xy, int n, CRowDouble& s);
    static void RBFSetAlgoQNN(CRBFModel& s, double q, double z);
    static void RBFSetAlgoMultilayer(CRBFModel& s, double rbase, int nlayers, double lambdav);
    static void RBFSetAlgoHierarchical(CRBFModel& s, double rbase, int nlayers, double lambdans);
    static void RBFSetAlgoThinPlateSpline(CRBFModel& s, double lambdav);
    static void RBFSetAlgoMultiQuadricManual(CRBFModel& s, double alpha, double lambdav);
    static void RBFSetAlgoMultiQuadricAuto(CRBFModel& s, double lambdav);
    static void RBFSetAlgoBiharmonic(CRBFModel& s, double lambdav);
    static void RBFSetLinTerm(CRBFModel& s);
    static void RBFSetConstTerm(CRBFModel& s);
    static void RBFSetZeroTerm(CRBFModel& s);
    static void RBFSetV2BF(CRBFModel& s, int bf);
    static void RBFSetV2Its(CRBFModel& s, int maxits);
    static void RBFSetV2SupportR(CRBFModel& s, double r);
    static void RBFSetCond(CRBFModel& s, double epsort, double epserr, int maxits);
    static void RBFBuildModel(CRBFModel& s, CRBFReport& rep);
    static double RBFCalc1(CRBFModel& s, double x0);
    static double RBFCalc2(CRBFModel& s, double x0, double x1);
    static double RBFCalc3(CRBFModel& s, double x0, double x1, double x2);
    static void RBFDiff1(CRBFModel& s, double x0, double& y, double& dy0);
    static void RBFDiff2(CRBFModel& s, double x0, double x1, double& y, double& dy0, double& dy1);
    static void RBFDiff3(CRBFModel& s, double x0, double x1, double x2, double& y, double& dy0, double& dy1, double& dy2);
    static void RBFCalc(CRBFModel& s, CRowDouble& x, CRowDouble& y);
    static void RBFDiff(CRBFModel& s, CRowDouble& x, CRowDouble& y, CRowDouble& dy);
    static void RBFHess(CRBFModel& s, CRowDouble& x, CRowDouble& y, CRowDouble& dy, CRowDouble& d2y);
    static void RBFCalcBuf(CRBFModel& s, CRowDouble& x, CRowDouble& y);
    static void RBFDiffBuf(CRBFModel& s, CRowDouble& x, CRowDouble& y, CRowDouble& dy);
    static void RBFHessBuf(CRBFModel& s, CRowDouble& x, CRowDouble& y, CRowDouble& dy, CRowDouble& d2y);
    static void RBFTSCalcBuf(CRBFModel& s, CRBFCalcBuffer& buf, CRowDouble& x, CRowDouble& y);
    static void RBFTSDiffBuf(CRBFModel& s, CRBFCalcBuffer& buf, CRowDouble& x, CRowDouble& y, CRowDouble& dy);
    static void RBFTSHessBuf(CRBFModel& s, CRBFCalcBuffer& buf, CRowDouble& x, CRowDouble& y, CRowDouble& dy, CRowDouble& d2y);
    static void RBFGridCalc2(CRBFModel& s, CRowDouble& x0, int n0, CRowDouble& x1, int n1, CMatrixDouble& y);
    static void RBFGridCalc2V(CRBFModel& s, CRowDouble& x0, int n0, CRowDouble& x1, int n1, CRowDouble& y);
    static void RBFGridCalc2VSubset(CRBFModel& s, CRowDouble& x0, int n0, CRowDouble& x1, int n1, bool & flagy, CRowDouble& y);
    static void RBFGridCalc3V(CRBFModel& s, CRowDouble& x0, int n0, CRowDouble& x1, int n1, CRowDouble& x2, int n2, CRowDouble& y);
    static void RBFGridCalc3VSubset(CRBFModel& s, CRowDouble& x0, int n0, CRowDouble& x1, int n1, CRowDouble& x2, int n2, bool & flagy, CRowDouble& y);
    static void RBFGridCalc2VX(CRBFModel& s, CRowDouble& x0, int n0, CRowDouble& x1, int n1, bool & flagy, bool sparsey, CRowDouble& y);
    static void RBFGridCalc3VX(CRBFModel& s, CRowDouble& x0, int n0, CRowDouble& x1, int n1, CRowDouble& x2, int n2, bool & flagy, bool sparsey, CRowDouble& y);
    static void RBFUnpack(CRBFModel& s, int & nx, int & ny, CMatrixDouble& xwr, int & nc, CMatrixDouble& v, int & modelversion);
    static int RBFGetModelVersion(CRBFModel& s);
    static double RBFPeekProgress(CRBFModel& s);
    static void RBFRequestTermination(CRBFModel& s);
    static void RBFAlloc(CSerializer& s, CRBFModel& model);
    static void RBFSerialize(CSerializer& s, CRBFModel& model);
    static void RBFUnserialize(CSerializer& s, CRBFModel& model);
};

struct CSpline3DInterpolant {
public:
    int m_d;
    int m_k;
    int m_l;
    int m_m;
    int m_n;
    int m_stype;
    CRowDouble m_f;
    CRowDouble m_x;
    CRowDouble m_y;
    CRowDouble m_z;
    CSpline3DInterpolant(void);
    ~CSpline3DInterpolant();
    void Copy(const CSpline3DInterpolant& obj);
};

class CSpline3D {
public:
    static double Spline3DCalc(CSpline3DInterpolant& c, double x, double y, double z);
    static void Spline3DLinTransXYZ(CSpline3DInterpolant& c, double ax, double bx, double ay, double by, double az, double bz);
    static void Spline3DLinTransF(CSpline3DInterpolant& c, double a, double b);
    static void Spline3DCopy(CSpline3DInterpolant& c, CSpline3DInterpolant& cc);
    static void Spline3DResampleTrilinear(CRowDouble& a, int oldzcount, int oldycount, int oldxcount, int newzcount, int newycount, int newxcount, CRowDouble& b);
    static void Spline3DBuildTrilinearV(CRowDouble& x, int n, CRowDouble& y, int m, CRowDouble& z, int l, CRowDouble& f, int d, CSpline3DInterpolant& c);
    static void Spline3DCalcVBuf(CSpline3DInterpolant& c, double x, double y, double z, CRowDouble& f);
    static void Spline3DCalcV(CSpline3DInterpolant& c, double x, double y, double z, CRowDouble& f);
    static void Spline3DUnpackV(CSpline3DInterpolant& c, int & n, int & m, int & l, int & d, int & stype, CMatrixDouble& tbl);
};

class CIntComp {
public:
    static void NSFitSphereMCC(CMatrixDouble& xy, int npoints, int nx, CRowDouble& cx, double& rhi);
    static void NSFitSphereMIC(CMatrixDouble& xy, int npoints, int nx, CRowDouble& cx, double& rlo);
    static void NSFitSphereMZC(CMatrixDouble& xy, int npoints, int nx, CRowDouble& cx, double& rlo, double& rhi);
    static void NSFitSphereX(CMatrixDouble& xy, int npoints, int nx, int problemtype, double epsx, int aulits, double penalty, CRowDouble& cx, double& rlo, double& rhi);
    static void Spline1DFitPenalized(double & cx, double & cy, const int n, const int m, const double rho, int & info, CSpline1DInterpolant& s, CSpline1DFitReport& rep);
    static void Spline1DFitPenalizedW(double & cx, double & cy, double & cw, const int n, const int m, double rho, int & info, CSpline1DInterpolant& s, CSpline1DFitReport& rep);
};

class CAblas {
public:
    static const int m_blas2minvendorkernelsize;
    static int AblasBlockSize(void);
    static int AblasMicroBlockSize(void);
    static int AblasComplexBlockSize(void);
    static void AblasSplitLength(const CMatrixDouble & a, const int n, int & n1, int & n2);
    static void AblasComplexSplitLength(const CMatrixComplex & a, const int n, int & n1, int & n2);
    static void RMatrixSyrk(const int n, const int k, const double alpha, const CMatrixDouble & a, const int ia, const int ja, const int OpTypea, const double beta, CMatrixDouble & c, const int ic, const int jc, const bool IsUpper);
    static void RMatrixGemm(const int m, const int n, const int k, const double alpha, const CMatrixDouble & a, const int ia, const int ja, const int OpTypea, const CMatrixDouble & b, const int ib, const int jb, const int OpTypeb, const double beta, CMatrixDouble & c, const int ic, const int jc);
    static void RMatrixTranspose(const int m, const int n, const CMatrixDouble & a, const int ia, const int ja, CMatrixDouble & b, const int ib, const int jb);
    static void RMatrixEnforceSymmetricity(CMatrixDouble & a, int n, bool IsUpper = true);
    static void RMatrixCopy(const int m, const int n, const CMatrixDouble & a, const int ia, const int ja, CMatrixDouble & b, const int ib, const int jb);
    static void RVectorCopy(int n, CRowDouble & a, int ia, CRowDouble & b, int ib);
    static void RMatrixGenCopy(int m, int n, double alpha, CMatrixDouble & a, int ia, int ja, double beta, CMatrixDouble & b, int ib, int jb);
    static void RMatrixGer(int m, int n, CMatrixDouble & a, int ia, int ja, double alpha, CRowDouble & u, int iu, CRowDouble & v, int iv);
    static void RMatrixRank1(const int m, const int n, CMatrixDouble & a, const int ia, const int ja, const double & u, const int iu, const double & v, const int iv);
    static void RMatrixRank1(const int m, const int n, CMatrixDouble & a, const int ia, const int ja, const CRowDouble & u, const int iu, const CRowDouble & v, const int iv);
    static void RMatrixGemVect(int m, int n, double alpha, CMatrixDouble & a, int ia, int ja, int opa, CRowDouble & x, int ix, double beta, CRowDouble & y, int iy);
    static void RMatrixMVect(const int m, const int n, const CMatrixDouble & a, const int ia, const int ja, const int opa, const double & x, const int ix, double & y, const int iy);
    static void RMatrixMVect(const int m, const int n, const CMatrixDouble & a, const int ia, const int ja, const int opa, const CRowDouble & x, const int ix, CRowDouble & y, const int iy);
    static void RMatrixSymVect(int n, double alpha, CMatrixDouble & a, int ia, int ja, bool IsUpper, CRowDouble & x, int ix, double beta, CRowDouble & y, int iy);
    static double RMatrixSyvMVect(int n, CMatrixDouble & a, int ia, int ja, bool IsUpper, CRowDouble & x, int ix, CRowDouble & tmp);
    static void RMatrixTrsVect(int n, CMatrixDouble & a, int ia, int ja, bool IsUpper, bool IsUnit, int OpType, CRowDouble & x, int ix);
    static void RMatrixRightTrsM(const int m, const int n, CMatrixDouble & a, const int i1, const int j1, const bool IsUpper, const bool IsUnit, const int OpType, CMatrixDouble & x, const int i2, const int j2);
    static void RMatrixLeftTrsM(const int m, const int n, CMatrixDouble & a, const int i1, const int j1, const bool IsUpper, const bool IsUnit, const int OpType, CMatrixDouble & x, const int i2, const int j2);
    static void CMatrixHerk(int n, int k, complex alpha, CMatrixComplex & a, int ia, int ja, int OpTypea, complex beta, CMatrixComplex & c, int ic, int jc, bool IsUpper);
    static void CMatrixSyrk(const int n, const int k, const double alpha, CMatrixComplex & a, const int ia, const int ja, const int OpTypea, const double beta, CMatrixComplex & c, const int ic, const int jc, const bool IsUpper);
    static void CMatrixGemm(const int m, const int n, const int k, complex & alpha, CMatrixComplex & a, const int ia, const int ja, const int OpTypea, CMatrixComplex & b, const int ib, const int jb, const int OpTypeb, complex & beta, CMatrixComplex & c, const int ic, const int jc);
    static void CMatrixTranspose(const int m, const int n, const CMatrixComplex & a, const int ia, const int ja, CMatrixComplex & b, const int ib, const int jb);
    static void CMatrixCopy(const int m, const int n, const CMatrixComplex & a, const int ia, const int ja, CMatrixComplex & b, const int ib, const int jb);
    static void CMatrixRank1(const int m, const int n, CMatrixComplex & a, const int ia, const int ja, const complex & u, const int iu, const complex & v, const int iv);
    static void CMatrixRank1(const int m, const int n, CMatrixComplex & a, const int ia, const int ja, const CRowComplex & u, const int iu, const CRowComplex & v, const int iv);
    static void CMatrixMVect(const int m, const int n, const CMatrixComplex & a, const int ia, const int ja, const int opa, const complex & x, const int ix, complex & y, const int iy);
    static void CMatrixMVect(const int m, const int n, const CMatrixComplex & a, const int ia, const int ja, const int opa, const CRowComplex & x, const int ix, CRowComplex & y, const int iy);
    static void CMatrixRightTrsM(const int m, const int n, CMatrixComplex & a, const int i1, const int j1, const bool IsUpper, const bool IsUnit, const int OpType, CMatrixComplex & x, const int i2, const int j2);
    static void CMatrixLeftTrsM(const int m, const int n, CMatrixComplex & a, const int i1, const int j1, const bool IsUpper, const bool IsUnit, const int OpType, CMatrixComplex & x, const int i2, const int j2);
    static void GenerateReflection(CRowDouble & x, int n, double & tau);
    static void ApplyReflectionFromTheLeft(CMatrixDouble & c, double tau, CRowDouble & v, int m1, int m2, int n1, int n2, CRowDouble & work);
    static void ApplyReflectionFromTheRight(CMatrixDouble & c, double tau, CRowDouble & v, int m1, int m2, int n1, int n2, CRowDouble & work);
    static void RowWiseGramSchmidt(CMatrixDouble & q, int m, int n, CRowDouble & x, CRowDouble & qx, bool needqx);
};

class COrtFac {
public:
    static void RMatrixQR(CMatrixDouble & a, const int m, const int n, double & tau);
    static void RMatrixQR(CMatrixDouble & a, const int m, const int n, CRowDouble & tau);
    static void RMatrixLQ(CMatrixDouble & a, const int m, const int n, double & tau);
    static void RMatrixLQ(CMatrixDouble & a, const int m, const int n, CRowDouble & tau);
    static void RMatrixQRUnpackQ(CMatrixDouble & a, const int m, const int n, double & tau, const int qcolumns, CMatrixDouble & q);
    static void RMatrixQRUnpackQ(CMatrixDouble & a, const int m, const int n, CRowDouble & tau, const int qcolumns, CMatrixDouble & q);
    static void RMatrixQRUnpackR(CMatrixDouble & a, const int m, const int n, CMatrixDouble & r);
    static void RMatrixLQUnpackQ(CMatrixDouble & a, const int m, const int n, double & tau, const int qrows, CMatrixDouble & q);
    static void RMatrixLQUnpackQ(CMatrixDouble & a, const int m, const int n, CRowDouble & tau, const int qrows, CMatrixDouble & q);
    static void RMatrixLQUnpackL(CMatrixDouble & a, const int m, const int n, CMatrixDouble & l);
    static void RMatrixQRBaseCase(CMatrixDouble & a, const int m, const int n, CRowDouble & work, CRowDouble & t, CRowDouble & tau);
    static void RMatrixLQBaseCase(CMatrixDouble & a, const int m, const int n, CRowDouble & work, CRowDouble& t, CRowDouble & tau);
    static void RMatrixBD(CMatrixDouble & a, const int m, const int n, double & tauq, double & taup);
    static void RMatrixBD(CMatrixDouble & a, const int m, const int n, CRowDouble & tauq, CRowDouble & taup);
    static void RMatrixBDUnpackQ(CMatrixDouble & qp, const int m, const int n, double & tauq, const int qcolumns, CMatrixDouble & q);
    static void RMatrixBDUnpackQ(CMatrixDouble & qp, const int m, const int n, CRowDouble & tauq, const int qcolumns, CMatrixDouble & q);
    static void RMatrixBDMultiplyByQ(CMatrixDouble & qp, const int m, const int n, double & tauq, CMatrixDouble & z, const int zrows, const int zcolumns, const bool fromtheright, const bool dotranspose);
    static void RMatrixBDMultiplyByQ(CMatrixDouble & qp, const int m, const int n, CRowDouble & tauq, CMatrixDouble & z, const int zrows, const int zcolumns, const bool fromtheright, const bool dotranspose);
    static void RMatrixBDUnpackPT(CMatrixDouble & qp, const int m, const int n, double & taup, const int ptrows, CMatrixDouble & pt);
    static void RMatrixBDUnpackPT(CMatrixDouble & qp, const int m, const int n, CRowDouble & taup, const int ptrows, CMatrixDouble & pt);
    static void RMatrixBDMultiplyByP(CMatrixDouble & qp, const int m, const int n, double & taup, CMatrixDouble & z, const int zrows, const int zcolumns, const bool fromtheright, const bool dotranspose);
    static void RMatrixBDMultiplyByP(CMatrixDouble & qp, const int m, const int n, CRowDouble & taup, CMatrixDouble & z, const int zrows, const int zcolumns, const bool fromtheright, const bool dotranspose);
    static void RMatrixBDUnpackDiagonals(CMatrixDouble & b, const int m, const int n, bool & IsUpper, double & d, double & e);
    static void RMatrixBDUnpackDiagonals(CMatrixDouble & b, const int m, const int n, bool & IsUpper, CRowDouble & d, CRowDouble & e);
    static void RMatrixHessenberg(CMatrixDouble & a, const int n, double & tau);
    static void RMatrixHessenberg(CMatrixDouble & a, const int n, CRowDouble & tau);
    static void RMatrixHessenbergUnpackQ(CMatrixDouble & a, const int n, double & tau, CMatrixDouble & q);
    static void RMatrixHessenbergUnpackQ(CMatrixDouble & a, const int n, CRowDouble & tau, CMatrixDouble & q);
    static void RMatrixHessenbergUnpackH(CMatrixDouble & a, const int n, CMatrixDouble & h);
    static void SMatrixTD(CMatrixDouble & a, const int n, const bool IsUpper, double & tau, double & d, double & e);
    static void SMatrixTD(CMatrixDouble & a, const int n, const bool IsUpper, CRowDouble & tau, CRowDouble & d, CRowDouble & e);
    static void SMatrixTDUnpackQ(CMatrixDouble & a, const int n, const bool IsUpper, double & tau, CMatrixDouble & q);
    static void SMatrixTDUnpackQ(CMatrixDouble & a, const int n, const bool IsUpper, CRowDouble & tau, CMatrixDouble & q);
    static void CMatrixQR(CMatrixComplex & a, const int m, const int n, complex & tau);
    static void CMatrixQR(CMatrixComplex & a, const int m, const int n, CRowComplex & tau);
    static void CMatrixLQ(CMatrixComplex & a, const int m, const int n, complex & tau);
    static void CMatrixLQ(CMatrixComplex & a, const int m, const int n, CRowComplex & tau);
    static void CMatrixQRUnpackQ(CMatrixComplex & a, const int m, const int n, complex & tau, const int qcolumns, CMatrixComplex & q);
    static void CMatrixQRUnpackQ(CMatrixComplex & a, const int m, const int n, CRowComplex & tau, const int qcolumns, CMatrixComplex & q);
    static void CMatrixQRUnpackR(CMatrixComplex & a, const int m, const int n, CMatrixComplex & r);
    static void CMatrixLQUnpackQ(CMatrixComplex & a, const int m, const int n, complex & tau, const int qrows, CMatrixComplex & q);
    static void CMatrixLQUnpackQ(CMatrixComplex & a, const int m, const int n, CRowComplex & tau, const int qrows, CMatrixComplex & q);
    static void CMatrixLQUnpackL(CMatrixComplex & a, const int m, const int n, CMatrixComplex & l);
    static void HMatrixTD(CMatrixComplex & a, const int n, const bool IsUpper, complex & tau, double & d, double & e);
    static void HMatrixTD(CMatrixComplex & a, const int n, const bool IsUpper, CRowComplex & tau, CRowDouble & d, CRowDouble & e);
    static void HMatrixTDUnpackQ(CMatrixComplex & a, const int n, const bool IsUpper, complex & tau, CMatrixComplex & q);
    static void HMatrixTDUnpackQ(CMatrixComplex & a, const int n, const bool IsUpper, CRowComplex & tau, CMatrixComplex & q);
};

struct CSparseMatrix {
public:
    CRowDouble m_Vals;
    CRowInt m_Idx;
    CRowInt m_RIdx;
    CRowInt m_DIdx;
    CRowInt m_UIdx;
    int m_MatrixType;
    int m_M;
    int m_N;
    int m_NFree;
    int m_NInitialized;
    int m_TableSize;
    CSparseMatrix(void);
    ~CSparseMatrix();
    void Init(void);
    void Copy(const CSparseMatrix & src);
};

struct CSparseBuffers {
public:
    int m_D;
    int m_U;
    CSparseMatrix m_S;
    CSparseBuffers();
    ~CSparseBuffers();
    void Init();
    void Copy(const CSparseBuffers & src);
};

class CSparse {
public:
    static const double m_DesiredLoadFactor;
    static const double m_MaxLoadFactor;
    static const double m_GrowFactor;
    static const int m_Additional;
    static const int m_LinAlgSwitch;
    static void SparseInitDUIdx(CSparseMatrix & s);
    static void SparseFree(CSparseMatrix & s);
    static void SparseCreate(int m, int n, int k, CSparseMatrix & s);
    static void SparseCreateBuf(int m, int n, int k, CSparseMatrix & s);
    static void SparseCreateCRS(int m, int n, int & ner, CSparseMatrix & s);
    static void SparseCreateCRS(int m, int n, CRowInt & ner, CSparseMatrix & s);
    static void SparseCreateCRSBuf(int m, int n, int & ner, CSparseMatrix & s);
    static void SparseCreateCRSBuf(int m, int n, CRowInt & ner, CSparseMatrix & s);
    static void SparseCreateSKS(int m, int n, int & d, int & u, CSparseMatrix & s);
    static void SparseCreateSKS(int m, int n, CRowInt & d, CRowInt & u, CSparseMatrix & s);
    static void SparseCreateSKSBuf(int m, int n, int & d, int & u, CSparseMatrix & s);
    static void SparseCreateSKSBuf(int m, int n, CRowInt & d, CRowInt & u, CSparseMatrix & s);
    static void SparseCreateSKSBand(int m, int n, int bw, CSparseMatrix & s);
    static void SparseCreateSKSBandBuf(int m, int n, int bw, CSparseMatrix & s);
    static void SparseCreateCRSInplace(CSparseMatrix & s);
    static void SparseCopy(CSparseMatrix & s0, CSparseMatrix & s1);
    static void SparseCopyBuf(CSparseMatrix & s0, CSparseMatrix & s1);
    static void SparseSwap(CSparseMatrix & s0, CSparseMatrix & s1);
    static void SparseCopyTransposeCRS(CSparseMatrix & s0, CSparseMatrix & s1);
    static void SparseCopyTransposeCRSBuf(CSparseMatrix & s0, CSparseMatrix & s1);
    static void SparseCopyToBuf(CSparseMatrix & s0, int fmt, CSparseMatrix & s1);
    static void SparseCopyToHash(CSparseMatrix & s0, CSparseMatrix & s1);
    static void SparseCopyToHashBuf(CSparseMatrix & s0, CSparseMatrix & s1);
    static void SparseCopyToCRS(CSparseMatrix & s0, CSparseMatrix & s1);
    static void SparseCopyToCRSBuf(CSparseMatrix & s0, CSparseMatrix & s1);
    static void SparseAdd(CSparseMatrix & s, int i, int j, double v);
    static void SparseSet(CSparseMatrix & s, int i, int j, double v);
    static void SparseResizeMatrix(CSparseMatrix & s);
    static bool SparseEnumerate(CSparseMatrix & s, int & t0, int & t1, int & i, int & j, double & v);
    static bool SparseRewriteExisting(CSparseMatrix & s, int i, int j, double v);
    static void SparseConvertTo(CSparseMatrix & s0, int fmt);
    static void SparseConvertToHash(CSparseMatrix & s);
    static void SparseConvertToCRS(CSparseMatrix & s);
    static void SparseConvertToSKS(CSparseMatrix & s);
    static void SparseCopyToSKS(CSparseMatrix & s0, CSparseMatrix & s1);
    static void SparseCopyToSKSBuf(CSparseMatrix & s0, CSparseMatrix & s1);
    static double SparseGet(CSparseMatrix & s, int i, int j);
    static double SparseGetDiagonal(CSparseMatrix & s, int i);
    static double SparseGetAverageLengthofChain(CSparseMatrix & s);
    static void SparseGetRow(CSparseMatrix & s, int i, CRowDouble & irow);
    static void SparseGetCompressedRow(CSparseMatrix & s, int i, CRowInt & ColIdx, CRowDouble & Vals, int & NZCnt);
    static int SparseGetNRows(CSparseMatrix & s);
    static int SparseGetNCols(CSparseMatrix & s);
    static int SparseGetUpperCount(CSparseMatrix & s);
    static int SparseGetLowerCount(CSparseMatrix & s);
    static bool SparseExists(CSparseMatrix & s, int i, int j);
    static int SparseGetMatrixType(CSparseMatrix & s);
    static bool SparseIsHash(CSparseMatrix & s);
    static bool SparseIsCRS(CSparseMatrix & s);
    static bool SparseIsSKS(CSparseMatrix & s);
    static void SparseMV(CSparseMatrix & s, CRowDouble & x, CRowDouble & y);
    static void SparseMV2(CSparseMatrix & s, CRowDouble & x, CRowDouble & y0, CRowDouble & y1);
    static void SparseMTV(CSparseMatrix & s, CRowDouble & x, CRowDouble & y);
    static void SparseGemV(CSparseMatrix & s, double alpha, int ops, CRowDouble & x, int ix, double beta, CRowDouble & y, int iy);
    static void SparseSMV(CSparseMatrix & s, bool IsUpper, CRowDouble & x, CRowDouble & y);
    static double SparseVSMV(CSparseMatrix & s, bool IsUpper, CRowDouble & x);
    static void SparseMM(CSparseMatrix & s, CMatrixDouble & a, int k, CMatrixDouble & b);
    static void SparseMM2(CSparseMatrix & s, CMatrixDouble & a, int k, CMatrixDouble & b0, CMatrixDouble & b1);
    static void SparseMTM(CSparseMatrix & s, CMatrixDouble & a, int k, CMatrixDouble & b);
    static void SparseSMM(CSparseMatrix & s, bool IsUpper, CMatrixDouble & a, int k, CMatrixDouble & b);
    static void SparseTRMV(CSparseMatrix & s, bool IsUpper, bool IsUnit, int OpType, CRowDouble & x, CRowDouble & y);
    static void SparseTRSV(CSparseMatrix & s, bool IsUpper, bool IsUnit, int OpType, CRowDouble & x);
    static void SparseSymmPermTbl(CSparseMatrix & a, bool IsUpper, CRowInt & p, CSparseMatrix & b);
    static void SparseSymmPermTblBuf(CSparseMatrix & a, bool IsUpper, CRowInt & p, CSparseMatrix & b);
    static void SparseTransposeSKS(CSparseMatrix & s);
    static void SparseTransposeCRS(CSparseMatrix & s);
    static void SparseAlloc(CSerializer & s, CSparseMatrix & a);
    static void SparseSerialize(CSerializer & s, CSparseMatrix & a);
    static void SparseUnserialize(CSerializer & s, CSparseMatrix & a);
    static void SparseTrace(CSparseMatrix & m);
};

struct CEigSubSpaceState {
public:
    int m_N;
    int m_K;
    int m_NWork;
    int m_MaxIts;
    int m_RequestType;
    int m_RequestSize;
    int m_RepIterationsCount;
    int m_EigenVectorsNeeded;
    int m_MatrixType;
    bool m_UseWarmStart;
    bool m_FirstCall;
    bool m_Running;
    double m_Eps;
    CRowDouble m_Tau;
    CRowDouble m_RW;
    CRowDouble m_TW;
    CRowDouble m_WCur;
    CRowDouble m_WPrev;
    CRowDouble m_WRank;
    CMatrixDouble m_Q0;
    CMatrixDouble m_QCur;
    CMatrixDouble m_QNew;
    CMatrixDouble m_ZNew;
    CMatrixDouble m_R;
    CMatrixDouble m_RZ;
    CMatrixDouble m_TZ;
    CMatrixDouble m_RQ;
    CMatrixDouble m_Dummy;
    CMatrixDouble m_X;
    CMatrixDouble m_AX;
    CApBuff m_Buf;
    CHighQualityRandState m_RS;
    RCommState m_RState;
    CEigSubSpaceState(void);
    void Init(void);
    void Copy(const CEigSubSpaceState & obj);
};

struct CEigSubSpaceReport {
public:
    int m_IterationsCount;
    CEigSubSpaceReport();
    void Init();
    void Copy(const CEigSubSpaceReport & obj);
};

class CEigenVDetect {
public:
    static const int m_StepsWithinTol;
    static void EigSubSpaceCreate(int n, int k, CEigSubSpaceState & state);
    static void EigSubSpaceCreateBuf(int n, int k, CEigSubSpaceState & state);
    static void EigSubSpaceSetCond(CEigSubSpaceState & state, double eps, int maxits);
    static void EigSubSpaceSetWarmStart(CEigSubSpaceState & state, bool usewarmstart);
    static void EigSubSpaceOOCStart(CEigSubSpaceState & state, int mtype);
    static bool EigSubSpaceOOCContinue(CEigSubSpaceState & state);
    static void EigSubSpaceOOCGetRequestInfo(CEigSubSpaceState & state, int & requesttype, int & requestsize);
    static void EigSubSpaceOOCGetRequestData(CEigSubSpaceState & state, CMatrixDouble & x);
    static void EigSubSpaceOOCSendResult(CEigSubSpaceState & state, CMatrixDouble & ax);
    static void EigSubSpaceOOCStop(CEigSubSpaceState & state, CRowDouble & w, CMatrixDouble & z, CEigSubSpaceReport & rep);
    static void EigSubSpaceSolveDenses(CEigSubSpaceState & state, CMatrixDouble & a, bool IsUpper, CRowDouble & w, CMatrixDouble & z, CEigSubSpaceReport & rep);
    static void EigSubSpaceSolveSparses(CEigSubSpaceState & state, CSparseMatrix & a, bool IsUpper, CRowDouble & w, CMatrixDouble & z, CEigSubSpaceReport & rep);
    static bool EigSubspaceIteration(CEigSubSpaceState & state);
    static bool SMatrixEVD(CMatrixDouble & ca, const int n, const int zneeded, const bool IsUpper, double & d, CMatrixDouble & z);
    static bool SMatrixEVD(CMatrixDouble & ca, const int n, const int zneeded, const bool IsUpper, CRowDouble & d, CMatrixDouble & z);
    static bool SMatrixEVDR(CMatrixDouble & ca, const int n, const int zneeded, const bool IsUpper, const double b1, const double b2, int & m, double & w, CMatrixDouble & z);
    static bool SMatrixEVDR(CMatrixDouble & ca, const int n, const int zneeded, const bool IsUpper, const double b1, const double b2, int & m, CRowDouble & w, CMatrixDouble & z);
    static bool SMatrixEVDI(CMatrixDouble & ca, const int n, const int zneeded, const bool IsUpper, const int i1, const int i2, double & w, CMatrixDouble & z);
    static bool SMatrixEVDI(CMatrixDouble & ca, const int n, const int zneeded, const bool IsUpper, const int i1, const int i2, CRowDouble & w, CMatrixDouble & z);
    static bool HMatrixEVD(CMatrixComplex & ca, const int n, int zneeded, const bool IsUpper, double & d, CMatrixComplex & z);
    static bool HMatrixEVD(CMatrixComplex & ca, const int n, int zneeded, const bool IsUpper, CRowDouble & d, CMatrixComplex & z);
    static bool HMatrixEVDR(CMatrixComplex & ca, const int n, int zneeded, bool IsUpper, const double b1, const double b2, int & m, double & w, CMatrixComplex & z);
    static bool HMatrixEVDR(CMatrixComplex & ca, const int n, int zneeded, bool IsUpper, const double b1, const double b2, int & m, CRowDouble & w, CMatrixComplex & z);
    static bool HMatrixEVDI(CMatrixComplex & ca, const int n, int zneeded, const bool IsUpper, const int i1, const int i2, double & w, CMatrixComplex & z);
    static bool HMatrixEVDI(CMatrixComplex & ca, const int n, int zneeded, const bool IsUpper, const int i1, const int i2, CRowDouble & w, CMatrixComplex & z);
    static bool SMatrixTdEVD(double & d, double & ce, const int n, const int zneeded, CMatrixDouble & z);
    static bool SMatrixTdEVD(CRowDouble & d, CRowDouble & ce, const int n, const int zneeded, CMatrixDouble & z);
    static bool SMatrixTdEVDR(double & d, double & e, const int n, const int zneeded, const double a, const double b, int & m, CMatrixDouble & z);
    static bool SMatrixTdEVDR(CRowDouble & d, CRowDouble & e, const int n, const int zneeded, const double a, const double b, int & m, CMatrixDouble & z);
    static bool SMatrixTdEVDI(double & d, double & e, const int n, const int zneeded, const int i1, const int i2, CMatrixDouble & z);
    static bool SMatrixTdEVDI(CRowDouble & d, CRowDouble & e, const int n, const int zneeded, const int i1, const int i2, CMatrixDouble & z);
    static bool RMatrixEVD(CMatrixDouble & ca, const int n, const int vneeded, double & wr, double & wi, CMatrixDouble & vl, CMatrixDouble & vr);
    static bool RMatrixEVD(CMatrixDouble & ca, const int n, const int vneeded, CRowDouble & wr, CRowDouble & wi, CMatrixDouble & vl, CMatrixDouble & vr);
};

class CMatGen {
public:
    static void RMatrixRndOrthogonal(const int n, CMatrixDouble & a);
    static void RMatrixRndCond(const int n, const double c, CMatrixDouble & a);
    static void CMatrixRndOrthogonal(const int n, CMatrixComplex & a);
    static void CMatrixRndCond(const int n, const double c, CMatrixComplex & a);
    static void SMatrixRndCond(const int n, const double c, CMatrixDouble & a);
    static void SPDMatrixRndCond(const int n, const double c, CMatrixDouble & a);
    static void HMatrixRndCond(const int n, const double c, CMatrixComplex & a);
    static void HPDMatrixRndCond(const int n, const double c, CMatrixComplex & a);
    static void RMatrixRndOrthogonalFromTheRight(CMatrixDouble & a, const int m, const int n);
    static void RMatrixRndOrthogonalFromTheLeft(CMatrixDouble & a, const int m, const int n);
    static void CMatrixRndOrthogonalFromTheRight(CMatrixComplex & a, const int m, const int n);
    static void CMatrixRndOrthogonalFromTheLeft(CMatrixComplex & a, const int m, const int n);
    static void SMatrixRndMultiply(CMatrixDouble & a, const int n);
    static void HMatrixRndMultiply(CMatrixComplex & a, const int n);
};

struct CAmdKNSet {
public:
    int m_K;
    int m_N;
    CRowInt m_FlagArray;
    CRowInt m_VBegin;
    CRowInt m_VAllocated;
    CRowInt m_VCnt;
    CRowInt m_Data;
    int m_DataUsed;
    int m_IterRow;
    int m_IterIdx;
    CAmdKNSet(void);
    ~CAmdKNSet();
    void Init(void);
    void Copy(const CAmdKNSet & obj);
};

struct CAmdNSet {
public:
    int m_N;
    int m_NStored;
    CRowInt m_Items;
    CRowInt m_LocationOf;
    int m_IterIdx;
    CAmdNSet(void);
    ~CAmdNSet();
    void Init(void);
    void Copy(const CAmdNSet & obj);
};

struct CAmdVertexSet {
public:
    int m_N;
    bool m_CheckExactDegrees;
    int m_SmallestDegree;
    CRowInt m_ApproxD;
    CRowInt m_OptionalExactD;
    bool m_IsVertex;
    CRowInt m_VBegin;
    CRowInt m_VPrev;
    CRowInt m_VNext;
    CAmdVertexSet(void);
    void Init(void);
    void Copy(const CAmdVertexSet & obj);
};

struct CAmdLLMatrix {
public:
    int m_N;
    CRowInt m_VBegin;
    CRowInt m_VColCnt;
    CRowInt m_Entries;
    int m_EntriesInitialized;
    CAmdLLMatrix(void);
    ~CAmdLLMatrix();
    void Init(void);
    void Copy(const CAmdLLMatrix & obj);
};

struct CAmdBuffer {
public:
    int m_N;
    bool m_ExtendedDebug;
    bool m_CheckExactDegrees;
    bool m_IsEliminated;
    bool m_IsSuperNode;
    CAmdKNSet m_SetSuper;
    CAmdKNSet m_SetA;
    CAmdKNSet m_SetE;
    CAmdLLMatrix m_MtxL;
    CAmdVertexSet m_VertexDegrees;
    CAmdNSet m_SetQ;
    CRowInt m_Perm;
    CRowInt m_InvPerm;
    CRowInt m_ColumnSwaps;
    CAmdNSet m_SetP;
    CAmdNSet m_Lp;
    CAmdNSet m_SetRP;
    CAmdNSet m_Ep;
    CAmdNSet m_AdjI;
    CAmdNSet m_AdjJ;
    CRowInt m_Ls;
    int m_LSCnt;
    CAmdNSet m_SetQSuperCand;
    CAmdNSet m_ExactDegreeTmp0;
    CAmdKNSet m_HashBuckets;
    CAmdNSet m_NonEmptyBuckets;
    CRowInt m_SNCandidates;
    CRowInt m_Tmp0;
    CRowInt m_Arrwe;
    CMatrixDouble m_Dbga;
    CAmdBuffer(void);
    ~CAmdBuffer();
    void Init(void);
    void Copy(const CAmdBuffer & obj);
};

struct CSpCholAnalysis {
public:
    int m_TaskType;
    int m_N;
    int m_PermType;
    bool m_UnitD;
    int m_ModType;
    double m_ModParam0;
    double m_ModParam1;
    double m_ModParam2;
    double m_ModParam3;
    bool m_ExtendedDebug;
    bool m_Dotrace;
    bool m_DotraceSupernodalStructure;
    CRowInt m_ReferenceRIdx;
    int m_NSuper;
    CRowInt m_ParentSupernode;
    CRowInt m_SuperColRange;
    CRowInt m_SuperRowRIdx;
    CRowInt m_SuperRowIdx;
    CRowInt m_FillinPerm;
    CRowInt m_InvFillinPerm;
    CRowInt m_SuperPerm;
    CRowInt m_InvSuperPerm;
    CRowInt m_EffectivePerm;
    CRowInt m_InvEffectivePerm;
    bool m_IsTopologicalOrdering;
    bool m_ApplyPermutationToOutput;
    CRowInt m_LAdjPlusR;
    CRowInt m_LAdjPlus;
    CRowInt m_OutRowCounts;
    CRowDouble m_InputStorage;
    CRowDouble m_OutputStorage;
    CRowInt m_RowStrides;
    CRowInt m_RowOffSets;
    CRowDouble m_DiagD;
    CRowInt m_WrkRows;
    bool m_FlagArray;
    bool m_Eligible;
    CRowInt m_CurPriorities;
    CRowInt m_TmpParent;
    CRowInt m_Node2Supernode;
    CRowInt m_U2Smap;
    CRowInt m_Raw2Smap;
    CAmdBuffer m_AmdTmp;
    CRowInt m_Tmp0;
    CRowInt m_Tmp1;
    CRowInt m_Tmp2;
    CRowInt m_Tmp3;
    CRowInt m_Tmp4;
    CSparseMatrix m_TmpA;
    CSparseMatrix m_TmpAt;
    CSparseMatrix m_TmpA2;
    CSparseMatrix m_TmpBottomT;
    CSparseMatrix m_TmpUpdate;
    CSparseMatrix m_TmpUpdateT;
    CSparseMatrix m_TmpNewTailT;
    CRowInt m_TmpPerm;
    CRowInt m_InvTmpPerm;
    CRowDouble m_TmpX;
    CRowDouble m_SimdBuf;
    CSpCholAnalysis(void);
    ~CSpCholAnalysis();
    void Init(void);
    void Copy(const CSpCholAnalysis & obj);
    void Trace(void);
    void SpCholAlloc(CSerializer & s);
    void SpCholSerialize(CSerializer & s);
};

struct CSparseDecompositionAnalysis {
public:
    int m_N;
    int m_FactType;
    int m_PermType;
    CSpCholAnalysis m_Analysis;
    CSparseMatrix m_WrkA;
    CSparseMatrix m_WrkAT;
    CSparseMatrix m_CrsA;
    CSparseMatrix m_CrsAT;
    CSparseDecompositionAnalysis(void);
    ~CSparseDecompositionAnalysis();
    void Init(void);
    void Copy(const CSparseDecompositionAnalysis & obj);
};

class CTrFac {
public:
    static void RMatrixLU(CMatrixDouble & A, const int m, const int n, int & pivots);
    static void RMatrixLU(CMatrixDouble & A, const int m, const int n, CRowInt & pivots);
    static void CMatrixLU(CMatrixComplex & A, const int m, const int n, int & pivots);
    static void CMatrixLU(CMatrixComplex & A, const int m, const int n, CRowInt & pivots);
    static bool HPDMatrixCholesky(CMatrixComplex & A, const int n, const bool IsUpper);
    static bool SPDMatrixCholesky(CMatrixDouble & A, const int n, const bool IsUpper);
    static void SPDMatrixCholeskyUpdateAdd1(CMatrixDouble & A, int N, bool IsUpper, CRowDouble & U);
    static void SPDMatrixCholeskyUpdateFix(CMatrixDouble & A, int n, bool IsUpper, bool & Fix);
    static void SPDMatrixCholeskyUpdateAdd1Buf(CMatrixDouble & A, int n, bool IsUpper, CRowDouble & U, CRowDouble & BufR);
    static void SPDMatrixCholeskyUpdateFixBuf(CMatrixDouble & A, int n, bool IsUpper, bool & fix, CRowDouble & BufR);
    static bool SparseLU(CSparseMatrix & A, int pivottype, CRowInt & P, CRowInt & Q);
    static bool SparseCholeskySkyLine(CSparseMatrix & A, int n, bool IsUpper);
    static bool SparseCholesky(CSparseMatrix & A, bool IsUpper);
    static bool SparseCholeskyP(CSparseMatrix & A, bool IsUpper, CRowInt & p);
    static bool SparseCholeskyAnalyze(CSparseMatrix & A, bool IsUpper, int facttype, int PermType, CSparseDecompositionAnalysis & Analysis);
    static void SparseCholeskySetModType(CSparseDecompositionAnalysis & Analysis, int modstrategy, double p0, double p1, double p2, double p3);
    static bool SparseCholeskyFactorize(CSparseDecompositionAnalysis & Analysis, bool NeedUpper, CSparseMatrix & A, CRowDouble & d, CRowInt & p);
    static void SparseCholeskyReload(CSparseDecompositionAnalysis & Analysis, CSparseMatrix & A, bool IsUpper);
    static void RMatrixLUP(CMatrixDouble & A, const int m, const int n, int & pivots);
    static void RMatrixLUP(CMatrixDouble & A, const int m, const int n, CRowInt & pivots);
    static void CMatrixLUP(CMatrixComplex & A, const int m, const int n, int & pivots);
    static void CMatrixLUP(CMatrixComplex & A, const int m, const int n, CRowInt & pivots);
    static void RMatrixPLU(CMatrixDouble & A, const int m, const int n, int & pivots);
    static void RMatrixPLU(CMatrixDouble & A, const int m, const int n, CRowInt & pivots);
    static void CMatrixPLU(CMatrixComplex & A, const int m, const int n, int & pivots);
    static void CMatrixPLU(CMatrixComplex & A, const int m, const int n, CRowInt & pivots);
    static bool SPDMatrixCholeskyRec(CMatrixDouble & A, const int Offs, const int n, const bool IsUpper, double & tmp);
    static bool SPDMatrixCholeskyRec(CMatrixDouble & A, const int Offs, const int n, const bool IsUpper, CRowDouble & tmp);
};

class CDLU {
public:
    static void CMatrixLUPRec(CMatrixComplex & a, const int Offs, const int m, const int n, CRowInt & pivots, CRowComplex & tmp);
    static void RMatrixLUPRec(CMatrixDouble & a, const int Offs, const int m, const int n, CRowInt & pivots, CRowDouble & tmp);
    static void CMatrixPLURec(CMatrixComplex & a, const int Offs, const int m, const int n, CRowInt & pivots, CRowComplex & tmp);
    static void RMatrixPLURec(CMatrixDouble & a, const int Offs, const int m, const int n, CRowInt & pivots, CRowDouble & tmp);
};

class CRCond {
public:
    static double RMatrixRCond1(CMatrixDouble & ca, const int n);
    static double RMatrixRCondInf(CMatrixDouble & ca, const int n);
    static double SPDMatrixRCond(CMatrixDouble & ca, const int n, const bool IsUpper);
    static double RMatrixTrRCond1(CMatrixDouble & a, const int n, const bool IsUpper, const bool IsUnit);
    static double RMatrixTrRCondInf(CMatrixDouble & a, const int n, const bool IsUpper, const bool IsUnit);
    static double RMatrixLURCond1(CMatrixDouble & lua, const int n);
    static double RMatrixLURCondInf(CMatrixDouble & lua, const int n);
    static double SPDMatrixCholeskyRCond(CMatrixDouble & a, const int n, const bool IsUpper);
    static double HPDMatrixRCond(CMatrixComplex & ca, const int n, const bool IsUpper);
    static double CMatrixRCond1(CMatrixComplex & ca, const int n);
    static double CMatrixRCondInf(CMatrixComplex & ca, const int n);
    static double HPDMatrixCholeskyRCond(CMatrixComplex & a, const int n, const bool IsUpper);
    static double CMatrixLURCond1(CMatrixComplex & lua, const int n);
    static double CMatrixLURCondInf(CMatrixComplex & lua, const int n);
    static double CMatrixTrRCond1(CMatrixComplex & a, const int n, const bool IsUpper, const bool IsUnit);
    static double CMatrixTrRCondInf(CMatrixComplex & a, const int n, const bool IsUpper, const bool IsUnit);
    static double RCondThreshold(void);
};

class CMatInvReport {
public:
    double m_r1;
    double m_rinf;
    CMatInvReport(void);
    ~CMatInvReport();
    void Copy(const CMatInvReport & obj);
};

class CMatInvReportShell {
public:
    CMatInvReportShell(void);
    CMatInvReportShell(CMatInvReport & obj);
    ~CMatInvReportShell();
    double GetR1(void);
    void SetR1(double r);
    double GetRInf(void);
    void SetRInf(double r);
};

class CMatInv {
public:
    static void RMatrixLUInverse(CMatrixDouble & a, int & pivots, const int n, int & info, CMatInvReport & rep);
    static void RMatrixLUInverse(CMatrixDouble & a, CRowInt & pivots, const int n, int & info, CMatInvReport & rep);
    static void RMatrixInverse(CMatrixDouble & a, const int n, int & info, CMatInvReport & rep);
    static void SPDMatrixCholeskyInverse(CMatrixDouble & a, const int n, const bool IsUpper, int & info, CMatInvReport & rep);
    static void SPDMatrixInverse(CMatrixDouble & a, const int n, const bool IsUpper, int & info, CMatInvReport & rep);
    static void RMatrixTrInverse(CMatrixDouble & a, const int n, const bool IsUpper, const bool IsUnit, int & info, CMatInvReport & rep);
    static void CMatrixLUInverse(CMatrixComplex & a, int & pivots, const int n, int & info, CMatInvReport & rep);
    static void CMatrixLUInverse(CMatrixComplex & a, CRowInt & pivots, const int n, int & info, CMatInvReport & rep);
    static void CMatrixInverse(CMatrixComplex & a, const int n, int & info, CMatInvReport & rep);
    static void HPDMatrixCholeskyInverse(CMatrixComplex & a, const int n, const bool IsUpper, int & info, CMatInvReport & rep);
    static void HPDMatrixInverse(CMatrixComplex & a, const int n, const bool IsUpper, int & info, CMatInvReport & rep);
    static void CMatrixTrInverse(CMatrixComplex & a, const int n, const bool IsUpper, const bool IsUnit, int & info, CMatInvReport & rep);
    static void SPDMatrixCholeskyInverseRec(CMatrixDouble & a, const int Offs, const int n, const bool IsUpper, CRowDouble & tmp);
};

class CBdSingValueDecompose {
public:
    static bool RMatrixBdSVD(double & d, double & ce, const int n, const bool IsUpper, const bool isfractionalaccuracyrequired, CMatrixDouble & u, const int nru, CMatrixDouble & c, const int ncc, CMatrixDouble & vt, const int ncvt);
    static bool RMatrixBdSVD(CRowDouble & d, CRowDouble & ce, const int n, const bool IsUpper, const bool isfractionalaccuracyrequired, CMatrixDouble & u, const int nru, CMatrixDouble & c, const int ncc, CMatrixDouble & vt, const int ncvt);
    static bool BidiagonalSVDDecomposition(double & d, double & ce, const int n, const bool IsUpper, const bool isfractionalaccuracyrequired, CMatrixDouble & u, const int nru, CMatrixDouble & c, const int ncc, CMatrixDouble & vt, const int ncvt);
    static bool BidiagonalSVDDecomposition(CRowDouble & d, CRowDouble & ce, const int n, const bool IsUpper, const bool isfractionalaccuracyrequired, CMatrixDouble & u, const int nru, CMatrixDouble & c, const int ncc, CMatrixDouble & vt, const int ncvt);
};

class CSingValueDecompose {
public:
    static bool RMatrixSVD(CMatrixDouble & ca, const int m, const int n, const int uneeded, const int vtneeded, const int additionalmemory, double & w, CMatrixDouble & u, CMatrixDouble & vt);
    static bool RMatrixSVD(CMatrixDouble & ca, const int m, const int n, const int uneeded, const int vtneeded, const int additionalmemory, CRowDouble & w, CMatrixDouble & u, CMatrixDouble & vt);
};

struct CFblsLinCgState {
public:
    double m_e1;
    double m_e2;
    CRowDouble m_x;
    CRowDouble m_ax;
    double m_xax;
    int m_n;
    CRowDouble m_rk;
    CRowDouble m_rk1;
    CRowDouble m_xk;
    CRowDouble m_xk1;
    CRowDouble m_pk;
    CRowDouble m_pk1;
    CRowDouble m_b;
    RCommState m_rstate;
    CRowDouble m_tmp2;
    CFblsLinCgState(void);
    ~CFblsLinCgState();
    void Copy(const CFblsLinCgState & obj);
};

struct CFblsGMRESState {
public:
    CRowDouble m_b;
    CRowDouble m_x;
    CRowDouble m_ax;
    CRowDouble m_xs;
    CMatrixDouble m_qi;
    CMatrixDouble m_aqi;
    CMatrixDouble m_h;
    CMatrixDouble m_hq;
    CMatrixDouble m_hr;
    CRowDouble m_hqb;
    CRowDouble m_ys;
    CRowDouble m_tmp0;
    CRowDouble m_tmp1;
    int m_n;
    int m_itscnt;
    double m_epsort;
    double m_epsres;
    double m_epsred;
    double m_epsdiag;
    int m_itsperformed;
    int m_retcode;
    double m_reprelres;
    RCommState m_rstate;
    CFblsGMRESState(void);
    ~CFblsGMRESState();
    void Copy(const CFblsGMRESState & obj);
};

class CFbls {
public:
    static void FblsCholeskySolve(CMatrixDouble & cha, const double sqrtscalea, const int n, const bool IsUpper, double & xb, double & tmp);
    static void FblsCholeskySolve(CMatrixDouble & cha, const double sqrtscalea, const int n, const bool IsUpper, CRowDouble & xb, CRowDouble & tmp);
    static void FblsSolveCGx(CMatrixDouble & a, const int m, const int n, const double alpha, const double & b, double & x, double & buf);
    static void FblsSolveCGx(CMatrixDouble & a, const int m, const int n, const double alpha, const CRowDouble & b, CRowDouble & x, CRowDouble & buf);
    static void FblsCGCreate(double & x, double & b, const int n, CFblsLinCgState & state);
    static void FblsCGCreate(CRowDouble & x, CRowDouble & b, const int n, CFblsLinCgState & state);
    static bool FblsCGIteration(CFblsLinCgState & state);
    static void FblsGMRESCreate(CRowDouble & b, int n, int k, CFblsGMRESState & state);
    static bool FblsGMRESIteration(CFblsGMRESState & state);
    static void FblsSolveLS(CMatrixDouble & a, CRowDouble & b, int m, int n, CRowDouble & tmp0, CRowDouble & tmp1, CRowDouble & tmp2);
};

class CMatDet {
public:
    static double RMatrixLUDet(CMatrixDouble & a, int & pivots, const int n);
    static double RMatrixLUDet(CMatrixDouble & a, CRowInt & pivots, const int n);
    static double RMatrixDet(CMatrixDouble & ca, const int n);
    static double SPDMatrixCholeskyDet(CMatrixDouble & a, const int n);
    static double SPDMatrixDet(CMatrixDouble & ca, const int n, const bool IsUpper);
    static complex CMatrixLUDet(CMatrixComplex & a, int & pivots, const int n);
    static complex CMatrixLUDet(CMatrixComplex & a, CRowInt & pivots, const int n);
    static complex CMatrixDet(CMatrixComplex & ca, const int n);
};

class CSpdGEVD {
public:
    static bool SMatrixGEVD(CMatrixDouble & ca, const int n, const bool isUppera, CMatrixDouble & b, const bool isUpperb, const int zneeded, const int problemtype, double & d, CMatrixDouble & z);
    static bool SMatrixGEVD(CMatrixDouble & ca, const int n, const bool isUppera, CMatrixDouble & b, const bool isUpperb, const int zneeded, const int problemtype, CRowDouble & d, CMatrixDouble & z);
    static bool SMatrixGEVDReduce(CMatrixDouble & a, const int n, const bool isUppera, CMatrixDouble & b, const bool isUpperb, const int problemtype, CMatrixDouble & r, bool & isUpperr);
};

class CInverseUpdate {
public:
    static void RMatrixInvUpdateSimple(CMatrixDouble & inva, const int n, const int updrow, const int updcolumn, const double updval);
    static void RMatrixInvUpdateRow(CMatrixDouble & inva, const int n, const int updrow, double & v);
    static void RMatrixInvUpdateRow(CMatrixDouble & inva, const int n, const int updrow, CRowDouble & v);
    static void RMatrixInvUpdateColumn(CMatrixDouble & inva, const int n, const int updcolumn, double & u);
    static void RMatrixInvUpdateColumn(CMatrixDouble & inva, const int n, const int updcolumn, CRowDouble & u);
    static void RMatrixInvUpdateUV(CMatrixDouble & inva, const int n, double & u, double & v);
    static void RMatrixInvUpdateUV(CMatrixDouble & inva, const int n, CRowDouble & u, CRowDouble & v);
};

class CSchur {
public:
    static bool RMatrixSchur(CMatrixDouble & a, const int n, CMatrixDouble & s);
};

class CSLUV2List1Matrix {
public:
    int m_NFixed;
    int m_NDynamic;
    CRowInt m_IdxFirst;
    CRowInt m_StrgIdx;
    CRowDouble m_StrgVal;
    int m_NAllocated;
    int m_NUsed;
    CSLUV2List1Matrix(void);
    ~CSLUV2List1Matrix();
    void Init(void);
    void Copy(const CSLUV2List1Matrix & obj);
};

struct CSLUV2SparseTrail {
public:
    int m_N;
    int m_K;
    int m_MaxWrkCnt;
    int m_MaxWrkNz;
    int m_WrkCnt;
    int m_SlsUsed;
    CRowInt m_Nzc;
    CRowInt m_WrkSet;
    CRowInt m_ColId;
    bool m_IsDensified;
    CRowInt m_SlsColPtr;
    CRowInt m_SlsRowPtr;
    CRowInt m_SlsIdx;
    CRowDouble m_SlsVal;
    CRowDouble m_Tmp0;
    CSLUV2SparseTrail(void);
    ~CSLUV2SparseTrail();
    void Init(void);
    void Copy(const CSLUV2SparseTrail & obj);
};

struct CSLUV2DenseTrail {
public:
    int m_N;
    int m_NDense;
    CMatrixDouble m_D;
    CRowInt m_Did;
    CSLUV2DenseTrail(void);
    ~CSLUV2DenseTrail();
    void Init(void);
    void Copy(const CSLUV2DenseTrail & obj);
};

struct CSLUV2Buffer {
public:
    int m_N;
    CSparseMatrix m_SparseL;
    CSparseMatrix m_SparseUT;
    CSLUV2List1Matrix m_BLeft;
    CSLUV2List1Matrix m_BUpper;
    CSLUV2SparseTrail m_STrail;
    CSLUV2DenseTrail m_DTrail;
    CRowInt m_RowPermRawIdx;
    CMatrixDouble m_DBuf;
    CRowInt m_V0i;
    CRowInt m_V1i;
    CRowDouble m_V0r;
    CRowDouble m_V1r;
    CRowDouble m_Tmp0;
    CRowInt m_TmpI;
    CRowInt m_TmpP;
    CSLUV2Buffer(void);
    ~CSLUV2Buffer();
    void Init();
    void Copy(const CSLUV2Buffer & obj);
};

class CSpTrf {
public:
    static const double m_DenseBnd;
    static const int m_SlsWidth;
    static bool SpTrfLU(CSparseMatrix & a, int pivottype, CRowInt & pr, CRowInt & pc, CSLUV2Buffer & buf);
};

class CAmdOrdering {
public:
    static const int m_KNsHeaderSize;
    static const int m_LLMentrySize;
    static void GenerateAmdPermutation(CSparseMatrix & A, int n, CRowInt & Perm, CRowInt & InvPerm, CAmdBuffer & Buf);
    static int GenerateAmdPermutationX(CSparseMatrix & A, bool & Eligible, int n, CRowInt & Perm, CRowInt & InvPerm, int AmdType, CAmdBuffer & Buf);
};

class CSpChol {
public:
    static const int m_MaxSupernode;
    static const double m_MaxMergeinEfficiency;
    static const int m_SmallFakesTolerance;
    static const int m_MaxFastKernel;
    static const bool m_RelaxedSupernodes;
    static bool SpSymmAnalyze(CSparseMatrix & A, CRowInt & Priorities, int FactType, int PermType, CSpCholAnalysis & Analysis);
    static void SpSymmSetModificationStrategy(CSpCholAnalysis & Analysis, int ModStrategy, double P0, double P1, double P2, double P3);
    static void SpSymmReload(CSpCholAnalysis & Analysis, CSparseMatrix & A);
    static void SpSymmReloadDiagonal(CSpCholAnalysis & Analysis, CRowDouble & d);
    static bool SpSymmFactorize(CSpCholAnalysis & Analysis);
    static void SpSymmExtract(CSpCholAnalysis & Analysis, CSparseMatrix & A, CRowDouble & d, CRowInt & p);
    static void SpSymmSolve(CSpCholAnalysis & Analysis, CRowDouble & b);
    static void SpSymmDiagErr(CSpCholAnalysis & Analysis, double & SumSq, double & ErrSq);
};

struct CNormEstimatorState {
public:
    int m_N;
    int m_M;
    int m_NStart;
    int m_NIts;
    int m_SeedVal;
    bool m_NeedMv;
    bool m_NeedMtv;
    double m_RepNorm;
    CRowDouble m_X;
    CRowDouble m_X0;
    CRowDouble m_X1;
    CRowDouble m_T;
    CRowDouble m_XBest;
    CRowDouble m_Mv;
    CRowDouble m_Mtv;
    CHighQualityRandState m_R;
    RCommState m_RState;
    CNormEstimatorState(void);
    ~CNormEstimatorState();
    void Copy(const CNormEstimatorState & obj);
};

class CNormEstimator {
public:
    static void NormEstimatorCreate(int m, int n, int nstart, int nits, CNormEstimatorState & state);
    static void NormEstimatorSetSeed(CNormEstimatorState & state, int SeedVal);
    static bool NormEstimatorIteration(CNormEstimatorState & state);
    static void NormEstimatorEstimateSparse(CNormEstimatorState & state, CSparseMatrix & a);
    static void NormEstimatorResults(CNormEstimatorState & state, double & nrm);
    static void NormEstimatorRestart(CNormEstimatorState & state);
};

class CHsSchur {
public:
    static void RMatrixInternalSchurDecomposition(CMatrixDouble & h, int n, int tneeded, int zneeded, CRowDouble & wr, CRowDouble & wi, CMatrixDouble & z, int & info);
    static bool UpperHessenbergSchurDecomposition(CMatrixDouble & h, const int n, CMatrixDouble & s);
    static void InternalSchurDecomposition(CMatrixDouble & h, const int n, const int tneeded, const int zneeded, double & wr, double & wi, CMatrixDouble & z, int & info);
    static void InternalSchurDecomposition(CMatrixDouble & h, const int n, const int tneeded, const int zneeded, CRowDouble & wr, CRowDouble & wi, CMatrixDouble & z, int & info);
};

class CRowDouble {
public:
    CRowDouble(void);
    CRowDouble(const vector<double>& vect);
    CRowDouble(const double & vect);
    CRowDouble(const CRowDouble & vect);
    ~CRowDouble();
    int Size(void) const;
    bool Resize(const ulong n);
    void Set(const int i, const double d);
    void Add(const int i, const double d);
    void Mul(const int i, const double d);
    double Sum(void);
    bool ToArray(double & arr);
    double MaxAbs(void) const;
    void Fill(const double value);
    void Swap(int i1, int i2);
    double Max();
    ulong ArgMax();
    double Min();
    ulong ArgMin();
    double Dot(CRowDouble & obj);
    double Dot(vector<double>& obj);
    double DotR(CMatrixDouble & obj, int row);
    double DotC(CMatrixDouble & obj, int col);
    bool Clip(const double min, const double max);
    void Copy(const vector<double>& vect, const int n);
};

class CRowInt {
public:
    CRowInt(void);
    CRowInt(const CRowInt & obj);
    CRowInt(const int & array);
    ~CRowInt();
    int Size(void) const;
    void Resize(const int n);
    void Set(const int i, const int d);
    void Add(const int i, const int d);
    void Swap(int i1, int i2);
    CRowInt Pow(const int p);
    long Sum(void);
    bool ToArray(int & arr);
    CRowInt Abs(void) const;
    int MaxAbs(void) const;
    void Fill(const int value);
    void Fill(const int value, const int offset, const int count);
    int Max();
    int Min();
    long Dot(CRowInt & obj);
    void Copy(const CRowInt & obj, const int offset, const int offset_obj, const int count);
    void Copy(const int & obj, const int offset, const int offset_obj, const int count);
    void Mul(int pos, int mult);
};

class CRowComplex {
public:
    CRowComplex(void);
    CRowComplex(const complex & array);
    ~CRowComplex();
    int Size(void) const;
    void Resize(const ulong n);
    void Set(const int i, const complex c);
    void Set(const int i, const double d);
    void Mul(const int i, const complex c);
    void Mul(const int i, const double d);
    void SetRe(const int i, const double d);
    void SetIm(const int i, const double d);
    bool ToArray(complex & dst);
};

class CMatrixDouble {
public:
    CMatrixDouble(void);
    CMatrixDouble(const ulong rows);
    CMatrixDouble(const ulong rows, const ulong cols);
    CMatrixDouble(const matrix<double>& mat);
    ~CMatrixDouble();
    int Size(void) const;
    int Rows(void) const;
    int Cols(void) const;
    bool Row(const int row, const vector<double>& vect);
    bool Row(const int row, const CRowDouble & vect);
    bool Row(const int row, const CMatrixDouble & mat, const int mat_row);
    bool Col(const int col, const vector<double>& vect);
    bool Col(const int col, const CRowDouble & vect);
    bool Col(const int col, const CRowInt & vect);
    bool Resize(const ulong n, const ulong m);
    bool Set(const ulong row, const ulong col, double d);
    void Add(const ulong row, const ulong col, double d);
    void Mul(const ulong row, const ulong col, double d);
    double Get(const ulong row, const ulong col) const;
    double Max(void) const;
    double Min(void) const;
    double Mean(void) const;
    double Std(void) const;
    void Split(ulong & parts, int axis, matrix<double>& splitted) const;
    matrix<double> TriU(const long diag = 0) const;
    matrix<double> TriL(const long diag = 0) const;
    vector<double> Diag(const long diag = 0) const;
    void Diag(const vector<double>& vect, const long diag = 0);
    void Diag(const CRowDouble & vect, const long diag = 0);
    bool SwapRows(const ulong row1, const ulong row2);
    bool SwapCols(const ulong col1, const ulong col2);
    void Fill(double value);
    void Fill(double value, int rows, int cols);
    matrix<double> MatMul(CMatrixDouble & matr, bool transpose = false);
    int Compare(const matrix<double>& mat, const double epsilon = 1e-308);
    bool InsertRow(int row);
    bool InsertCol(int col);
    bool DeleteRow(int row);
    bool DeleteCol(int col);
};

class CMatrixInt {
public:
    CMatrixInt(void);
    CMatrixInt(const int rows);
    CMatrixInt(const int rows, const int cols);
    ~CMatrixInt();
    int Size(void) const;
    int Rows(void) const;
    int Cols(void) const;
    void Resize(const int n, const int m);
    bool Set(const int row, const int col, int d);
    int Get(const int row, const int col) const;
    void Fill(const int value);
};

class CMatrixComplex {
public:
    CMatrixComplex(void);
    CMatrixComplex(const ulong rows);
    CMatrixComplex(const ulong rows, const ulong cols);
    CMatrixComplex(matrix<complex>& mat);
    ~CMatrixComplex();
    int Size(void) const;
    int Rows(void) const;
    int Cols(void) const;
    bool Col(const ulong col, vector<complex>& vect);
    bool Resize(const ulong n, const ulong m);
    bool Set(const ulong row, const ulong col, complex d);
    complex Get(const ulong row, const ulong col) const;
    bool Set(const ulong row, const ulong col, const double d);
    bool Set(const ulong row, const ulong col, const int d);
    bool SetRe(const ulong row, const ulong col, const double d);
    bool SetIm(const ulong row, const ulong col, const double d);
    bool Mul(const ulong row, const ulong col, const double d);
    bool Mul(const ulong row, const ulong col, const int d);
    matrix<complex> TriU(const long diag = 0) const;
    matrix<complex> TriL(const long diag = 0) const;
};

struct COptGuardReport {
public:
    bool m_nonc0suspected;
    bool m_nonc0test0positive;
    int m_nonc0fidx;
    double m_nonc0lipschitzc;
    bool m_nonc1suspected;
    bool m_nonc1test0positive;
    bool m_nonc1test1positive;
    int m_nonc1fidx;
    double m_nonc1lipschitzc;
    bool m_badgradsuspected;
    int m_badgradfidx;
    int m_badgradvidx;
    CRowDouble m_badgradxbase;
    CMatrixDouble m_badgraduser;
    CMatrixDouble m_badgradnum;
    COptGuardReport(void);
    ~COptGuardReport();
    void Copy(const COptGuardReport & obj);
};

struct COptGuardNonC0Report {
public:
    int m_stpidxb;
    int m_cnt;
    int m_stpidxa;
    int m_n;
    int m_fidx;
    bool m_positive;
    CRowDouble m_d;
    CRowDouble m_x0;
    CRowDouble m_stp;
    CRowDouble m_f;
    COptGuardNonC0Report(void);
    ~COptGuardNonC0Report();
    void Copy(const COptGuardNonC0Report & obj);
};

struct COptGuardNonC1Test0Report {
public:
    int m_cnt;
    int m_fidx;
    int m_n;
    int m_stpidxa;
    int m_stpidxb;
    bool m_positive;
    CRowDouble m_d;
    CRowDouble m_f;
    CRowDouble m_stp;
    CRowDouble m_x0;
    COptGuardNonC1Test0Report(void);
    ~COptGuardNonC1Test0Report();
    void Copy(const COptGuardNonC1Test0Report & obj);
};

struct COptGuardNonC1Test1Report {
public:
    int m_cnt;
    int m_fidx;
    int m_n;
    int m_stpidxa;
    int m_stpidxb;
    int m_vidx;
    bool m_positive;
    CRowDouble m_d;
    CRowDouble m_g;
    CRowDouble m_stp;
    CRowDouble m_x0;
    COptGuardNonC1Test1Report(void);
    ~COptGuardNonC1Test1Report();
    void Copy(const COptGuardNonC1Test1Report & obj);
};

class COptGuardApi {
public:
    static void OptGuardInitInternal(COptGuardReport & rep, int n, int k);
    static void OptGuardExportReport(COptGuardReport & srcrep, int n, int k, bool badgradhasxj, COptGuardReport & dstrep);
    static void SmoothnessMonitorExportC1Test0Report(COptGuardNonC1Test0Report & srcrep, CRowDouble & s, COptGuardNonC1Test0Report & dstrep);
    static void SmoothnessMonitorExportC1Test1Report(COptGuardNonC1Test1Report & srcrep, CRowDouble & s, COptGuardNonC1Test1Report & dstrep);
    static bool OptGuardAllClear(COptGuardReport & rep);
};

struct CPrecBufLBFGS {
public:
    CRowInt m_bufb;
    CRowInt m_idx;
    CRowDouble m_alpha;
    CRowDouble m_bufa;
    CRowDouble m_norms;
    CRowDouble m_rho;
    CMatrixDouble m_yk;
    CRowDouble norms;
    CPrecBufLBFGS(void);
    ~CPrecBufLBFGS();
    void Copy(const CPrecBufLBFGS & obj);
};

struct CPrecBufLowRank {
public:
    int m_k;
    int m_n;
    CRowDouble m_bufc;
    CRowDouble m_d;
    CRowDouble m_tmp;
    CMatrixDouble m_bufw;
    CMatrixDouble m_bufz;
    CMatrixDouble m_v;
    CPrecBufLowRank(void);
    ~CPrecBufLowRank();
    void Copy(const CPrecBufLowRank & obj);
};

struct CSmoothnessMonitor {
public:
    RCommState m_probingrcomm;
    RCommState m_rstateg0;
    COptGuardReport m_rep;
    COptGuardNonC1Test1Report m_nonc1test1lngrep;
    COptGuardNonC1Test1Report m_nonc1test1strrep;
    COptGuardNonC1Test0Report m_nonc1test0lngrep;
    COptGuardNonC1Test0Report m_nonc1test0strrep;
    COptGuardNonC0Report m_nonc0lngrep;
    COptGuardNonC0Report m_nonc0strrep;
    int m_enqueuedcnt;
    int m_k;
    int m_n;
    int m_probingnstepsstored;
    int m_probingnvalues;
    int m_sortedcnt;
    double m_nonc0currentrating;
    double m_nonc0lngrating;
    double m_nonc0strrating;
    double m_nonc1currentrating;
    double m_nonc1test0lngrating;
    double m_nonc1test0strrating;
    double m_nonc1test1lngrating;
    double m_nonc1test1strrating;
    double m_probingstepmax;
    double m_probingstepscale;
    double m_probingstp;
    bool m_badgradhasxj;
    bool m_checksmoothness;
    bool m_linesearchspoiled;
    bool m_linesearchstarted;
    bool m_needfij;
    CRowInt m_bufi;
    CRowInt m_sortedidx;
    CRowInt m_tmpidx;
    CRowDouble m_bufr;
    CRowDouble m_dcur;
    CRowDouble m_deltax;
    CRowDouble m_du;
    CRowDouble m_enqueuedfunc;
    CRowDouble m_enqueuedstp;
    CRowDouble m_enqueuedx;
    CRowDouble m_f;
    CRowDouble m_f0;
    CRowDouble m_fbase;
    CRowDouble m_fc;
    CRowDouble m_fi;
    CRowDouble m_fm;
    CRowDouble m_fp;
    CRowDouble m_g;
    CRowDouble m_jc;
    CRowDouble m_jm;
    CRowDouble m_jp;
    CRowDouble m_probingf;
    CRowDouble m_probingsteps;
    CRowDouble m_s;
    CRowDouble m_sortedstp;
    CRowDouble m_stp;
    CRowDouble m_x;
    CRowDouble m_xbase;
    CRowDouble m_xu;
    CMatrixDouble m_enqueuedjac;
    CMatrixDouble m_j;
    CMatrixDouble m_j0;
    CMatrixDouble m_jbasenum;
    CMatrixDouble m_jbaseusr;
    CMatrixDouble m_probingslopes;
    CMatrixDouble m_probingvalues;
    CSmoothnessMonitor(void);
    ~CSmoothnessMonitor();
    void Copy(const CSmoothnessMonitor & obj);
};

class COptServ {
public:
    static const double m_ognoiselevelf;
    static const double m_ognoiselevelg;
    static const double m_ogminrating0;
    static const double m_ogminrating1;
    static void CheckBcViolation(bool & HasBndL, CRowDouble & bndl, bool & HasBndU, CRowDouble & bndu, CRowDouble & x, int n, CRowDouble & s, bool nonunits, double & bcerr, int & bcidx);
    static void CheckLcViolation(CMatrixDouble & cleic, CRowInt & lcsrcidx, int nec, int nic, CRowDouble & x, int n, double & lcerr, int & lcidx);
    static void CheckNLcViolation(CRowDouble & fi, int ng, int nh, double & nlcerr, int & nlcidx);
    static void UnScaleAndCheckNLcViolation(CRowDouble & fi, CRowDouble & fscales, int ng, int nh, double & nlcerr, int & nlcidx);
    static void TrimPrepare(double f, double & threshold);
    static void TrimFunction(double & f, double & g, const int n, const double threshold);
    static void TrimFunction(double & f, CRowDouble & g, const int n, const double threshold);
    static bool EnforceBoundaryConstraints(CRowDouble & x, CRowDouble & bl, bool & havebl, CRowDouble & bu, bool & havebu, int nmain, int nslack);
    static void ProjectGradientIntoBC(CRowDouble & x, CRowDouble & g, CRowDouble & bl, bool & havebl, CRowDouble & bu, bool & havebu, int nmain, int nslack);
    static void CalculateStepBound(CRowDouble & x, CRowDouble & d, double alpha, CRowDouble & bndl, bool & havebndl, CRowDouble & bndu, bool & havebndu, int nmain, int nslack, int & variabletofreeze, double & valuetofreeze, double & maxsteplen);
    static int PostProcessBoundedStep(CRowDouble & x, CRowDouble & xprev, CRowDouble & bndl, bool & havebndl, CRowDouble & bndu, bool & havebndu, int nmain, int nslack, int variabletofreeze, double valuetofreeze, double steptaken, double maxsteplen);
    static void FilterDirection(CRowDouble & d, CRowDouble & x, CRowDouble & bndl, bool & havebndl, CRowDouble & bndu, bool & havebndu, CRowDouble & s, int nmain, int nslack, double droptol);
    static int NumberOfChangedConstraints(CRowDouble & x, CRowDouble & xprev, CRowDouble & bndl, bool & havebndl, CRowDouble & bndu, bool & havebndu, int nmain, int nslack);
    static bool FindFeasiblePoint(CRowDouble & x, CRowDouble & bndl, bool & havebndl, CRowDouble & bndu, bool & havebndu, int nmain, int nslack, CMatrixDouble & ce, int k, double epsi, int & qpits, int & gpaits);
    static bool DerivativeCheck(double f0, double df0, double f1, double df1, double f, double df, double width);
    static void EstimateParabolicModel(double absasum, double absasum2, double mx, double mb, double md, double d1, double d2, int & d1est, int & d2est);
    static void InexactLBFGSPreconditioner(CRowDouble & s, int n, CRowDouble & d, CRowDouble & c, CMatrixDouble & w, int k, CPrecBufLBFGS & buf);
    static void PrepareLowRankPreconditioner(CRowDouble & d, CRowDouble & c, CMatrixDouble & w, int n, int k, CPrecBufLowRank & buf);
    static void ApplyLowRankPreconditioner(CRowDouble & s, CPrecBufLowRank & buf);
    static void SmoothnessMonitorInit(CSmoothnessMonitor & monitor, CRowDouble & s, int n, int k, bool checksmoothness);
    static void SmoothnessMonitorStartLineSearch(CSmoothnessMonitor & monitor, CRowDouble & x, CRowDouble & fi, CMatrixDouble & jac);
    static void SmoothnessMonitorStartLineSearch1u(CSmoothnessMonitor & monitor, CRowDouble & s, CRowDouble & invs, CRowDouble & x, double f0, CRowDouble & j0);
    static void SmoothnessMonitorEnqueuePoint(CSmoothnessMonitor & monitor, CRowDouble & d, double stp, CRowDouble & x, CRowDouble & fi, CMatrixDouble & jac);
    static void SmoothnessMonitorEnqueuePoint1u(CSmoothnessMonitor & monitor, CRowDouble & s, CRowDouble & invs, CRowDouble & d, double stp, CRowDouble & x, double f0, CRowDouble & j0);
    static void SmoothnessMonitorFinalizeLineSearch(CSmoothnessMonitor & monitor);
    static void SmoothnessMonitorStartProbing(CSmoothnessMonitor & monitor, double stpmax, int nvalues, double stepscale);
    static bool SmoothnessMonitorProbe(CSmoothnessMonitor & monitor);
    static void SmoothnessMonitorTraceProbingResults(CSmoothnessMonitor & monitor);
    static void SmoothnessMonitorTraceStatus(CSmoothnessMonitor & monitor, bool callersuggeststrace);
    static void SmoothnessMonitorExportReport(CSmoothnessMonitor & monitor, COptGuardReport & rep);
    static bool SmoothnessMonitorCheckGradientATX0(CSmoothnessMonitor & monitor, CRowDouble & unscaledx0, CRowDouble & s, CRowDouble & bndl, CRowDouble & bndu, bool hasboxconstraints, double teststep);
};

class CMinCGState {
public:
    int m_cgtype;
    int m_debugrestartscount;
    int m_k;
    int m_maxits;
    int m_mcinfo;
    int m_mcstage;
    int m_n;
    int m_nfev;
    int m_prectype;
    int m_repiterationscount;
    int m_repnfev;
    int m_repterminationtype;
    int m_rstimer;
    int m_smoothnessguardlevel;
    int m_vcnt;
    double m_betady;
    double m_betahs;
    double m_curstpmax;
    double m_diffstep;
    double m_epsf;
    double m_epsg;
    double m_epsx;
    double m_f;
    double m_fbase;
    double m_fm1;
    double m_fm2;
    double m_fold;
    double m_fp1;
    double m_fp2;
    double m_lastgoodstep;
    double m_lastscaledstep;
    double m_stp;
    double m_stpmax;
    double m_suggestedstep;
    double m_teststep;
    double m_trimthreshold;
    bool m_algpowerup;
    bool m_drep;
    bool m_innerresetneeded;
    bool m_lsend;
    bool m_lsstart;
    bool m_needf;
    bool m_needfg;
    bool m_terminationneeded;
    bool m_userterminationneeded;
    bool m_xrep;
    bool m_xupdated;
    RCommState m_rstate;
    CSmoothnessMonitor m_smonitor;
    CLinMinState m_lstate;
    CRowDouble m_d;
    CRowDouble m_diagh;
    CRowDouble m_diaghl2;
    CRowDouble m_dk;
    CRowDouble m_dn;
    CRowDouble m_g;
    CRowDouble m_invs;
    CRowDouble m_lastscaleused;
    CRowDouble m_s;
    CRowDouble m_work0;
    CRowDouble m_work1;
    CRowDouble m_x;
    CRowDouble m_xbase;
    CRowDouble m_xk;
    CRowDouble m_xn;
    CRowDouble m_yk;
    CMatrixDouble m_vcorr;
    CMinCGState(void);
    ~CMinCGState();
    void Copy(const CMinCGState & obj);
};

class CMinCGStateShell {
public:
    CMinCGStateShell(void);
    CMinCGStateShell(CMinCGState & obj);
    ~CMinCGStateShell();
    bool GetNeedF(void);
    void SetNeedF(const bool b);
    bool GetNeedFG(void);
    void SetNeedFG(const bool b);
    bool GetXUpdated(void);
    void SetXUpdated(const bool b);
    double GetF(void);
    void SetF(const double d);
};

class CMinCGReport {
public:
    int m_iterationscount;
    int m_nfev;
    int m_terminationtype;
    CMinCGReport(void);
    ~CMinCGReport();
    void Copy(const CMinCGReport & obj);
};

class CMinCGReportShell {
public:
    CMinCGReportShell(void);
    CMinCGReportShell(CMinCGReport & obj);
    ~CMinCGReportShell();
    int GetIterationsCount(void);
    void SetIterationsCount(const int i);
    int GetNFev(void);
    void SetNFev(const int i);
    int GetTerminationType(void);
    void SetTerminationType(const int i);
};

class CMinCG {
public:
    static const int m_rscountdownlen;
    static const double m_gtol;
    static void MinCGCreate(const int n, double & x, CMinCGState & State);
    static void MinCGCreate(const int n, CRowDouble & x, CMinCGState & State);
    static void MinCGCreateF(const int n, double & x, const double diffstep, CMinCGState & State);
    static void MinCGCreateF(const int n, CRowDouble & x, const double diffstep, CMinCGState & State);
    static void MinCGSetCond(CMinCGState & State, const double epsg, const double epsf, double epsx, const int m_maxits);
    static void MinCGSetScale(CMinCGState & State, double & s);
    static void MinCGSetScale(CMinCGState & State, CRowDouble & s);
    static void MinCGSetXRep(CMinCGState & State, const bool needxrep);
    static void MinCGSetDRep(CMinCGState & State, const bool needdrep);
    static void MinCGSetCGType(CMinCGState & State, int cgtype);
    static void MinCGSetStpMax(CMinCGState & State, const double stpmax);
    static void MinCGSuggestStep(CMinCGState & State, const double stp);
    static double MinCGLastGoodStep(CMinCGState & State);
    static void MinCGSetPrecDefault(CMinCGState & State);
    static void MinCGSetPrecDiag(CMinCGState & State, double & d);
    static void MinCGSetPrecDiag(CMinCGState & State, CRowDouble & d);
    static void MinCGSetPrecScale(CMinCGState & State);
    static void MinCGOptGuardGradient(CMinCGState & State, double teststep);
    static void MinCGOptGuardSmoothness(CMinCGState & State, int level);
    static void MinCGOptGuardResults(CMinCGState & State, COptGuardReport & rep);
    static void MinCGOptGuardNonC1Test0Results(CMinCGState & State, COptGuardNonC1Test0Report & strrep, COptGuardNonC1Test0Report & lngrep);
    static void MinCGOptGuardNonC1Test1Results(CMinCGState & State, COptGuardNonC1Test1Report & strrep, COptGuardNonC1Test1Report & lngrep);
    static void MinCGResults(CMinCGState & State, double & x, CMinCGReport & rep);
    static void MinCGResults(CMinCGState & State, CRowDouble & x, CMinCGReport & rep);
    static void MinCGResultsBuf(CMinCGState & State, double & x, CMinCGReport & rep);
    static void MinCGResultsBuf(CMinCGState & State, CRowDouble & x, CMinCGReport & rep);
    static void MinCGRestartFrom(CMinCGState & State, double & x);
    static void MinCGRestartFrom(CMinCGState & State, CRowDouble & x);
    static void MinCGRequestTermination(CMinCGState & State);
    static void MinCGSetPrecDiagFast(CMinCGState & State, double & d);
    static void MinCGSetPrecDiagFast(CMinCGState & State, CRowDouble & d);
    static void MinCGSetPrecLowRankFast(CMinCGState & State, double & d1, double & c, CMatrixDouble & v, const int vcnt);
    static void MinCGSetPrecLowRankFast(CMinCGState & State, CRowDouble & d1, CRowDouble & c, CMatrixDouble & v, const int vcnt);
    static void MinCGSetPrecVarPart(CMinCGState & State, double & d2);
    static void MinCGSetPrecVarPart(CMinCGState & State, CRowDouble & d2);
    static bool MinCGIteration(CMinCGState & State);
};

struct CSNNLSSolver {
public:
    int m_debugmaxinnerits;
    int m_nd;
    int m_nr;
    int m_ns;
    double m_debugflops;
    bool m_nnc;
    CRowInt m_rdtmprowmap;
    CRowDouble m_b;
    CRowDouble m_cb;
    CRowDouble m_cborg;
    CRowDouble m_crb;
    CRowDouble m_cx;
    CRowDouble m_d;
    CRowDouble m_diagaa;
    CRowDouble m_dx;
    CRowDouble m_g;
    CRowDouble m_r;
    CRowDouble m_regdiag;
    CRowDouble m_tmp0;
    CRowDouble m_tmp1;
    CRowDouble m_tmp2;
    CRowDouble m_tmpcholesky;
    CRowDouble m_trdd;
    CRowDouble m_xn;
    CRowDouble m_xp;
    CMatrixDouble m_densea;
    CMatrixDouble m_tmpca;
    CMatrixDouble m_tmplq;
    CMatrixDouble m_trda;
    CSNNLSSolver(void);
    ~CSNNLSSolver();
    void Copy(const CSNNLSSolver & obj);
};

class CSNNLS {
public:
    static void SNNLSInit(int nsmax, int ndmax, int nrmax, CSNNLSSolver & s);
    static void SNNLSSetProblem(CSNNLSSolver & s, CMatrixDouble & a, CRowDouble & b, int ns, int nd, int nr);
    static void SNNLSDropNNC(CSNNLSSolver & s, int idx);
    static void SNNLSSolve(CSNNLSSolver & s, CRowDouble & x);
};

struct CSActiveSet {
public:
    int m_algostate;
    int m_basisage;
    int m_densebatchsize;
    int m_n;
    int m_nec;
    int m_nic;
    int m_sparsebatchsize;
    bool m_basisisready;
    bool m_constraintschanged;
    bool m_feasinitpt;
    bool m_HasBndL;
    bool m_HasBndU;
    bool m_hasxc;
    bool m_mtnew;
    bool m_rctmpisequality;
    CSNNLSSolver m_solver;
    CRowInt m_cstatus;
    CRowInt m_mtas;
    CRowInt m_rctmpconstraintidx;
    CRowInt m_sparsebatch;
    CRowDouble m_bndl;
    CRowDouble m_bndu;
    CRowDouble m_cdtmp;
    CRowDouble m_corrtmp;
    CRowDouble m_h;
    CRowDouble m_mtx;
    CRowDouble m_rctmpg;
    CRowDouble m_rctmplambdas;
    CRowDouble m_rctmprightpart;
    CRowDouble m_rctmps;
    CRowDouble m_s;
    CRowDouble m_scntmp;
    CRowDouble m_tmp0;
    CRowDouble m_tmpci;
    CRowDouble m_tmpcp;
    CRowDouble m_tmpcs;
    CRowDouble m_tmpfeas;
    CRowDouble m_tmpnormestimates;
    CRowDouble m_tmpprodp;
    CRowDouble m_tmpprods;
    CRowDouble m_tmpreciph;
    CRowDouble m_unitdiagonal;
    CRowDouble m_xc;
    CMatrixDouble m_cleic;
    CMatrixDouble m_idensebatch;
    CMatrixDouble m_pdensebatch;
    CMatrixDouble m_rctmpdense0;
    CMatrixDouble m_rctmpdense1;
    CMatrixDouble m_sdensebatch;
    CMatrixDouble m_tmpbasis;
    CMatrixDouble m_tmpm0;
    CSActiveSet(void);
    ~CSActiveSet();
    void Copy(const CSActiveSet & obj);
};

class CSActiveSets {
public:
    static const int m_maxbasisage;
    static const double m_maxbasisdecay;
    static const double m_minnormseparation;
    static void SASInit(int n, CSActiveSet & s);
    static void SASSetScale(CSActiveSet & State, CRowDouble & s);
    static void SASSetPrecDiag(CSActiveSet & State, CRowDouble & d);
    static void SASSetBC(CSActiveSet & State, CRowDouble & bndl, CRowDouble & bndu);
    static void SASSetLC(CSActiveSet & State, CMatrixDouble & c, CRowInt & ct, int k);
    static void SASSetLCX(CSActiveSet & State, CMatrixDouble & cleic, int nec, int nic);
    static bool SASStartOptimization(CSActiveSet & State, CRowDouble & x);
    static void SASExploreDirection(CSActiveSet & State, CRowDouble & d, double & stpmax, int & cidx, double & vval);
    static int SASMoveTo(CSActiveSet & State, CRowDouble & xn, bool needact, int cidx, double cval);
    static void SASImmediateActivation(CSActiveSet & State, int cidx, double cval);
    static void SASConstrainedDescent(CSActiveSet & State, CRowDouble & g, CRowDouble & d);
    static void SASConstrainedDescentPrec(CSActiveSet & State, CRowDouble & g, CRowDouble & d);
    static void SASConstrainedDirection(CSActiveSet & State, CRowDouble & d);
    static void SASConstrainedDirectionPrec(CSActiveSet & State, CRowDouble & d);
    static void SASCorrection(CSActiveSet & State, CRowDouble & x, double & penalty);
    static double SASActiveLCPenalty1(CSActiveSet & State, CRowDouble & x);
    static double SASScaledConstrainedNorm(CSActiveSet & State, CRowDouble & d);
    static void SASStopOptimization(CSActiveSet & State);
    static void SASReactivateConstraints(CSActiveSet & State, CRowDouble & gc);
    static void SASReactivateConstraintsPrec(CSActiveSet & State, CRowDouble & gc);
    static void SASRebuildBasis(CSActiveSet & State);
    static void SASAppendToBasis(CSActiveSet & State, bool & newentries);
};

class CMinBLEICState {
public:
    int m_bufsize;
    int m_cidx;
    int m_maxits;
    int m_mcstage;
    int m_nec;
    int m_nfev;
    int m_nic;
    int m_nmain;
    int m_nonmonotoniccnt;
    int m_nslack;
    int m_prectype;
    int m_repdebugfeasgpaits;
    int m_repdebugfeasqpits;
    int m_repinneriterationscount;
    int m_repnfev;
    int m_repouteriterationscount;
    int m_repterminationtype;
    int m_repvaridx;
    int m_smoothnessguardlevel;
    double m_activationstep;
    double m_curstpmax;
    double m_cval;
    double m_diffstep;
    double m_epsf;
    double m_epsg;
    double m_epsx;
    double m_f;
    double m_fbase;
    double m_fc;
    double m_fm1;
    double m_fm2;
    double m_fn;
    double m_fp1;
    double m_fp2;
    double m_fp;
    double m_gm1;
    double m_gp1;
    double m_lastgoodstep;
    double m_lastscaledgoodstep;
    double m_maxscaledgrad;
    double m_repdebugdx;
    double m_repdebugeqerr;
    double m_repdebugff;
    double m_repdebugfs;
    double m_stp;
    double m_stpmax;
    double m_teststep;
    double m_trimthreshold;
    double m_xm1;
    double m_xp1;
    bool m_boundedstep;
    bool m_drep;
    bool m_lsstart;
    bool m_needf;
    bool m_needfg;
    bool m_steepestdescentstep;
    bool m_userterminationneeded;
    bool m_xrep;
    bool m_xupdated;
    RCommState m_rstate;
    CSmoothnessMonitor m_smonitor;
    CSNNLSSolver m_solver;
    CSActiveSet m_sas;
    CLinMinState m_lstate;
    bool m_HasBndL;
    bool m_HasBndU;
    CRowDouble m_bndl;
    CRowDouble m_bndu;
    CRowDouble m_bufrho;
    CRowDouble m_buftheta;
    CRowDouble m_cgc;
    CRowDouble m_cgn;
    CRowDouble m_d;
    CRowDouble m_diagh;
    CRowDouble m_g;
    CRowDouble m_invs;
    CRowDouble m_lastscaleused;
    CRowDouble m_s;
    CRowDouble m_tmp0;
    CRowDouble m_tmpprec;
    CRowDouble m_ugc;
    CRowDouble m_ugn;
    CRowDouble m_work;
    CRowDouble m_x;
    CRowDouble m_xn;
    CRowDouble m_xp;
    CRowDouble m_xstart;
    CMatrixDouble m_bufsk;
    CMatrixDouble m_bufyk;
    CMatrixDouble m_cleic;
    CMinBLEICState(void);
    ~CMinBLEICState();
    void Copy(const CMinBLEICState & obj);
};

class CMinBLEICStateShell {
public:
    CMinBLEICStateShell(void);
    CMinBLEICStateShell(CMinBLEICState & obj);
    ~CMinBLEICStateShell();
    bool GetNeedF(void);
    void SetNeedF(const bool b);
    bool GetNeedFG(void);
    void SetNeedFG(const bool b);
    bool GetXUpdated(void);
    void SetXUpdated(const bool b);
    double GetF(void);
    void SetF(const double d);
};

class CMinBLEICReport {
public:
    int m_debugfeasgpaits;
    int m_debugfeasqpits;
    int m_inneriterationscount;
    int m_iterationscount;
    int m_nfev;
    int m_outeriterationscount;
    int m_terminationtype;
    int m_varidx;
    double m_debugdx;
    double m_debugeqerr;
    double m_debugff;
    double m_debugfs;
    CMinBLEICReport(void);
    ~CMinBLEICReport();
    void Copy(const CMinBLEICReport & obj);
};

class CMinBLEICReportShell {
public:
    CMinBLEICReportShell(void);
    CMinBLEICReportShell(CMinBLEICReport & obj);
    ~CMinBLEICReportShell();
    int GetInnerIterationsCount(void);
    void SetInnerIterationsCount(const int i);
    int GetOuterIterationsCount(void);
    void SetOuterIterationsCount(const int i);
    int GetNFev(void);
    void SetNFev(const int i);
    int GetTerminationType(void);
    void SetTerminationType(const int i);
    double GetDebugEqErr(void);
    void SetDebugEqErr(const double d);
    double GetDebugFS(void);
    void SetDebugFS(const double d);
    double GetDebugFF(void);
    void SetDebugFF(const double d);
    double GetDebugDX(void);
    void SetDebugDX(const double d);
};

class CMinBLEIC {
public:
    static const double m_maxnonmonotoniclen;
    static const double m_gtol;
    static const double m_initialdecay;
    static const double m_mindecay;
    static const double m_decaycorrection;
    static const double m_penaltyfactor;
    static void MinBLEICCreate(const int n, double & x, CMinBLEICState & State);
    static void MinBLEICCreate(const int n, CRowDouble & x, CMinBLEICState & State);
    static void MinBLEICCreateF(const int n, double & x, const double diffstep, CMinBLEICState & State);
    static void MinBLEICCreateF(const int n, CRowDouble & x, const double diffstep, CMinBLEICState & State);
    static void MinBLEICSetBC(CMinBLEICState & State, double & bndl, double & bndu);
    static void MinBLEICSetBC(CMinBLEICState & State, CRowDouble & bndl, CRowDouble & bndu);
    static void MinBLEICSetLC(CMinBLEICState & State, CMatrixDouble & c, int & ct, const int k);
    static void MinBLEICSetLC(CMinBLEICState & State, CMatrixDouble & c, CRowInt & ct, const int k);
    static void MinBLEICSetInnerCond(CMinBLEICState & State, const double epsg, const double epsf, const double epsx);
    static void MinBLEICSetOuterCond(CMinBLEICState & State, const double epsx, const double epsi);
    static void MinBLEICSetCond(CMinBLEICState & State, double epsg, double epsf, double epsx, int m_maxits);
    static void MinBLEICSetScale(CMinBLEICState & State, double & s);
    static void MinBLEICSetScale(CMinBLEICState & State, CRowDouble & s);
    static void MinBLEICSetPrecDefault(CMinBLEICState & State);
    static void MinBLEICSetPrecDiag(CMinBLEICState & State, double & d);
    static void MinBLEICSetPrecDiag(CMinBLEICState & State, CRowDouble & d);
    static void MinBLEICSetPrecScale(CMinBLEICState & State);
    static void MinBLEICSetMaxIts(CMinBLEICState & State, const int m_maxits);
    static void MinBLEICSetXRep(CMinBLEICState & State, const bool needxrep);
    static void MinBLEICSetDRep(CMinBLEICState & State, bool needdrep);
    static void MinBLEICSetStpMax(CMinBLEICState & State, const double stpmax);
    static void MinBLEICOptGuardGradient(CMinBLEICState & State, double & teststep);
    static void MinBLEICOptGuardSmoothness(CMinBLEICState & State, int level);
    static void MinBLEICOptGuardResults(CMinBLEICState & State, COptGuardReport & rep);
    static void MinBLEICOptGuardNonC1Test0Results(CMinBLEICState & State, COptGuardNonC1Test0Report & strrep, COptGuardNonC1Test0Report & lngrep);
    static void MinBLEICOptGuardNonC1Test1Results(CMinBLEICState & State, COptGuardNonC1Test1Report & strrep, COptGuardNonC1Test1Report & lngrep);
    static void MinBLEICResults(CMinBLEICState & State, double & x, CMinBLEICReport & rep);
    static void MinBLEICResults(CMinBLEICState & State, CRowDouble & x, CMinBLEICReport & rep);
    static void MinBLEICResultsBuf(CMinBLEICState & State, double & x, CMinBLEICReport & rep);
    static void MinBLEICResultsBuf(CMinBLEICState & State, CRowDouble & x, CMinBLEICReport & rep);
    static void MinBLEICRestartFrom(CMinBLEICState & State, double & x);
    static void MinBLEICRestartFrom(CMinBLEICState & State, CRowDouble & x);
    static void MinBLEICRequestTermination(CMinBLEICState & State);
    static void MinBLEICEmergencyTermination(CMinBLEICState & State);
    static bool MinBLEICIteration(CMinBLEICState & State);
};

class CMinLBFGSState {
public:
    int m_k;
    int m_m;
    int m_maxits;
    int m_mcstage;
    int m_n;
    int m_nfev;
    int m_p;
    int m_preck;
    int m_prectype;
    int m_q;
    int m_repiterationscount;
    int m_repnfev;
    int m_repterminationtype;
    int m_smoothnessguardlevel;
    double m_diffstep;
    double m_epsf;
    double m_epsg;
    double m_epsx;
    double m_f;
    double m_fbase;
    double m_fm1;
    double m_fm2;
    double m_fold;
    double m_fp1;
    double m_fp2;
    double m_gammak;
    double m_stp;
    double m_stpmax;
    double m_teststep;
    double m_trimthreshold;
    bool m_needf;
    bool m_needfg;
    bool m_userterminationneeded;
    bool m_xrep;
    bool m_xupdated;
    RCommState m_rstate;
    CSmoothnessMonitor m_smonitor;
    CRowDouble m_autobuf;
    CRowDouble m_d;
    CRowDouble m_diagh;
    CRowDouble m_g;
    CRowDouble m_invs;
    CRowDouble m_lastscaleused;
    CRowDouble m_precc;
    CRowDouble m_precd;
    CRowDouble m_rho;
    CRowDouble m_s;
    CRowDouble m_theta;
    CRowDouble m_work;
    CRowDouble m_x;
    CRowDouble m_xbase;
    CRowDouble m_xp;
    CPrecBufLowRank m_lowrankbuf;
    CPrecBufLBFGS m_precbuf;
    CMatrixDouble m_denseh;
    CMatrixDouble m_precw;
    CMatrixDouble m_sk;
    CMatrixDouble m_yk;
    CLinMinState m_lstate;
    CMinLBFGSState(void);
    ~CMinLBFGSState();
    void Copy(CMinLBFGSState & obj);
};

class CMinLBFGSStateShell {
public:
    CMinLBFGSStateShell(void);
    CMinLBFGSStateShell(CMinLBFGSState & obj);
    ~CMinLBFGSStateShell();
    bool GetNeedF(void);
    void SetNeedF(const bool b);
    bool GetNeedFG(void);
    void SetNeedFG(const bool b);
    bool GetXUpdated(void);
    void SetXUpdated(const bool b);
    double GetF(void);
    void SetF(const double d);
};

class CMinLBFGSReport {
public:
    int m_iterationscount;
    int m_nfev;
    int m_terminationtype;
    CMinLBFGSReport(void);
    ~CMinLBFGSReport();
    void Copy(CMinLBFGSReport & obj);
};

class CMinLBFGSReportShell {
public:
    CMinLBFGSReportShell(void);
    CMinLBFGSReportShell(CMinLBFGSReport & obj);
    ~CMinLBFGSReportShell();
    int GetIterationsCount(void);
    void SetIterationsCount(const int i);
    int GetNFev(void);
    void SetNFev(const int i);
    int GetTerminationType(void);
    void SetTerminationType(const int i);
};

class CMinLBFGS {
public:
    static const double m_gtol;
    static void MinLBFGSCreate(const int n, const int m, double & x, CMinLBFGSState & State);
    static void MinLBFGSCreate(const int n, const int m, CRowDouble & x, CMinLBFGSState & State);
    static void MinLBFGSCreateF(const int n, const int m, double & x, const double diffstep, CMinLBFGSState & State);
    static void MinLBFGSSetCond(CMinLBFGSState & State, const double epsg, const double epsf, double epsx, const int m_maxits);
    static void MinLBFGSSetXRep(CMinLBFGSState & State, const bool needxrep);
    static void MinLBFGSSetStpMax(CMinLBFGSState & State, const double stpmax);
    static void MinLBFGSSetScale(CMinLBFGSState & State, double & s);
    static void MinLBFGSCreateX(const int n, const int m, double & x, int flags, const double diffstep, CMinLBFGSState & State);
    static void MinLBFGSCreateX(const int n, const int m, CRowDouble & x, int flags, const double diffstep, CMinLBFGSState & State);
    static void MinLBFGSSetPrecDefault(CMinLBFGSState & State);
    static void MinLBFGSSetPrecCholesky(CMinLBFGSState & State, CMatrixDouble & p, const bool IsUpper);
    static void MinLBFGSSetPrecDiag(CMinLBFGSState & State, double & d);
    static void MinLBFGSSetPrecScale(CMinLBFGSState & State);
    static void MinLBFGSSetPrecRankKLBFGSFast(CMinLBFGSState & State, CRowDouble & d, CRowDouble & c, CMatrixDouble & w, int cnt);
    static void MinLBFGSSetPrecLowRankExact(CMinLBFGSState & State, CRowDouble & d, CRowDouble & c, CMatrixDouble & w, int cnt);
    static void MinLBFGSResults(CMinLBFGSState & State, double & x, CMinLBFGSReport & rep);
    static void MinLBFGSResults(CMinLBFGSState & State, CRowDouble & x, CMinLBFGSReport & rep);
    static void MinLBFGSResultsBuf(CMinLBFGSState & State, double & x, CMinLBFGSReport & rep);
    static void MinLBFGSResultsBuf(CMinLBFGSState & State, CRowDouble & x, CMinLBFGSReport & rep);
    static void MinLBFGSRestartFrom(CMinLBFGSState & State, double & x);
    static void MinLBFGSRestartFrom(CMinLBFGSState & State, CRowDouble & x);
    static void MinLBFGSRequestTermination(CMinLBFGSState & State);
    static bool MinLBFGSIteration(CMinLBFGSState & State);
};

struct CVIPMVars {
public:
    int m_m;
    int m_n;
    CRowDouble m_g;
    CRowDouble m_p;
    CRowDouble m_q;
    CRowDouble m_s;
    CRowDouble m_t;
    CRowDouble m_v;
    CRowDouble m_w;
    CRowDouble m_x;
    CRowDouble m_y;
    CRowDouble m_z;
    CVIPMVars(void);
    ~CVIPMVars();
    void Copy(const CVIPMVars & obj);
};

struct CVIPMReducedSparseSystem {
public:
    int m_ntotal;
    bool m_isdiagonal;
    CSparseMatrix m_rawsystem;
    CSpCholAnalysis m_analysis;
    CRowInt m_coldegrees;
    CRowInt m_priorities;
    CRowInt m_rowdegrees;
    CRowDouble m_effectivediag;
    CVIPMReducedSparseSystem(void);
    ~CVIPMReducedSparseSystem();
    void Copy(const CVIPMReducedSparseSystem & obj);
};

struct CVIPMRightHandSide {
public:
    CRowDouble m_alpha;
    CRowDouble m_beta;
    CRowDouble m_gammaq;
    CRowDouble m_gammas;
    CRowDouble m_gammaw;
    CRowDouble m_gammaz;
    CRowDouble m_nu;
    CRowDouble m_rho;
    CRowDouble m_sigma;
    CRowDouble m_tau;
    CVIPMRightHandSide(void);
    ~CVIPMRightHandSide();
    void Copy(const CVIPMRightHandSide & obj);
};

struct CVIPMState {
public:
    int m_cntgz;
    int m_cntpq;
    int m_cntts;
    int m_cntwv;
    int m_factorizationtype;
    int m_hkind;
    int m_mdense;
    int m_msparse;
    int m_n;
    int m_nmain;
    int m_repiterationscount;
    int m_repncholesky;
    double m_epsd;
    double m_epsgap;
    double m_epsp;
    double m_targetscale;
    bool m_aflips;
    bool m_dodetailedtrace;
    bool m_dotrace;
    bool m_factorizationpoweredup;
    bool m_factorizationpresent;
    bool m_HasBndL;
    bool m_HasBndU;
    bool m_hasgz;
    bool m_haspq;
    bool m_hasr;
    bool m_hasts;
    bool m_haswv;
    bool m_isdiagonalh;
    bool m_isfrozen;
    bool m_islinear;
    bool m_slacksforequalityconstraints;
    CSparseMatrix m_combinedaslack;
    CSparseMatrix m_sparseafull;
    CSparseMatrix m_sparseamain;
    CSparseMatrix m_sparseh;
    CSparseMatrix m_tmpsparse0;
    CVIPMVars m_best;
    CVIPMVars m_current;
    CVIPMVars m_deltaaff;
    CVIPMVars m_deltacorr;
    CVIPMVars m_trial;
    CVIPMVars m_zerovars;
    CVIPMRightHandSide m_rhs;
    CVIPMReducedSparseSystem m_reducedsparsesystem;
    CRowInt m_tmpi;
    CRowDouble m_ascales;
    CRowDouble m_b;
    CRowDouble m_bndl;
    CRowDouble m_bndu;
    CRowDouble m_c;
    CRowDouble m_deltaxy;
    CRowDouble m_diagddr;
    CRowDouble m_diagde;
    CRowDouble m_diagder;
    CRowDouble m_diagdq;
    CRowDouble m_diagdqi;
    CRowDouble m_diagdqiri;
    CRowDouble m_diagds;
    CRowDouble m_diagdsi;
    CRowDouble m_diagdsiri;
    CRowDouble m_diagdw;
    CRowDouble m_diagdwi;
    CRowDouble m_diagdwir;
    CRowDouble m_diagdz;
    CRowDouble m_diagdzi;
    CRowDouble m_diagdziri;
    CRowDouble m_diagr;
    CRowDouble m_dummyr;
    CRowDouble m_factinvregdzrz;
    CRowDouble m_factregdhrh;
    CRowDouble m_factregewave;
    CRowDouble m_facttmpdiag;
    CRowDouble m_invscl;
    CRowDouble m_tmp0;
    CRowDouble m_tmp1;
    CRowDouble m_r;
    CRowDouble m_rawbndl;
    CRowDouble m_rawbndu;
    CRowDouble m_rhsalphacap;
    CRowDouble m_rhsbetacap;
    CRowDouble m_rhsnucap;
    CRowDouble m_rhstaucap;
    CRowDouble m_scl;
    CRowDouble m_tmp2;
    CRowDouble m_tmpaty;
    CRowDouble m_tmpax;
    CRowDouble m_tmphx;
    CRowDouble m_tmplaggrad;
    CRowDouble m_tmpy;
    CRowDouble m_xorigin;
    CMatrixDouble m_denseafull;
    CMatrixDouble m_denseamain;
    CMatrixDouble m_denseh;
    CMatrixDouble m_factdensehaug;
    CMatrixDouble m_tmpr2;
    CVIPMState(void);
    ~CVIPMState();
    void Copy(const CVIPMState & obj);
};

class CVIPMSolver {
public:
    static const double m_muquasidense;
    static const int m_maxipmits;
    static const double m_initslackval;
    static const double m_steplengthdecay;
    static const double m_stagnationdelta;
    static const double m_primalinfeasible1;
    static const double m_dualinfeasible1;
    static const double m_bigy;
    static const double m_ygrowth;
    static const int m_itersfortoostringentcond;
    static const int m_minitersbeforedroppingbounds;
    static const int m_minitersbeforeinfeasible;
    static const int m_minitersbeforestagnation;
    static const int m_minitersbeforeeworststagnation;
    static const int m_primalstagnationlen;
    static const int m_dualstagnationlen;
    static const double m_bigconstrxtol;
    static const double m_bigconstrmag;
    static const double m_minitersbeforesafeguards;
    static const double m_badsteplength;
    static void VIPMInitDense(CVIPMState & State, CRowDouble & s, CRowDouble & xorigin, int n);
    static void VIPMInitDenseWithSlacks(CVIPMState & State, CRowDouble & s, CRowDouble & xorigin, int nmain, int n);
    static void VIPMInitSparse(CVIPMState & State, CRowDouble & s, CRowDouble & xorigin, int n);
    static void VIPMSetQuadraticLinear(CVIPMState & State, CMatrixDouble & denseh, CSparseMatrix & sparseh, int hkind, bool IsUpper, CRowDouble & c);
    static void VIPMSetConstraints(CVIPMState & State, CRowDouble & bndl, CRowDouble & bndu, CSparseMatrix & sparsea, int msparse, CMatrixDouble & densea, int mdense, CRowDouble & cl, CRowDouble & cu);
    static void VIPMSetCond(CVIPMState & State, double epsp, double epsd, double epsgap);
    static void VIPMOptimize(CVIPMState & State, bool dropbigbounds, CRowDouble & xs, CRowDouble & lagbc, CRowDouble & laglc, int & terminationtype);
};

struct CConvexQuadraticModel {
public:
    int m_ecakind;
    int m_k;
    int m_n;
    int m_nfree;
    double m_alpha;
    double m_ec;
    double m_tau;
    double m_theta;
    double m_tk0;
    double m_tq0;
    bool m_activeset;
    bool m_isactivesetchanged;
    bool m_islineartermchanged;
    bool m_ismaintermchanged;
    bool m_issecondarytermchanged;
    CRowDouble m_b;
    CRowDouble m_d;
    CRowDouble m_eb;
    CRowDouble m_ecadiag;
    CRowDouble m_r;
    CRowDouble m_tb;
    CRowDouble m_tk1;
    CRowDouble m_tmp0;
    CRowDouble m_tmp1;
    CRowDouble m_tmpg;
    CRowDouble m_tq1;
    CRowDouble m_tq2diag;
    CRowDouble m_txc;
    CRowDouble m_xc;
    CMatrixDouble m_a;
    CMatrixDouble m_ecadense;
    CMatrixDouble m_eccm;
    CMatrixDouble m_eq;
    CMatrixDouble m_q;
    CMatrixDouble m_tk2;
    CMatrixDouble m_tmp2;
    CMatrixDouble m_tq2dense;
    CConvexQuadraticModel(void);
    ~CConvexQuadraticModel();
    void Copy(const CConvexQuadraticModel & obj);
};

class CCQModels {
public:
    static const int m_newtonrefinementits;
    static void CQMInit(int n, CConvexQuadraticModel & s);
    static void CQMSetA(CConvexQuadraticModel & s, CMatrixDouble & a, bool IsUpper, double alpha);
    static void CQMGetA(CConvexQuadraticModel & s, CMatrixDouble & a);
    static void CQMRewriteDenseDiagonal(CConvexQuadraticModel & s, CRowDouble & z);
    static void CQMSetD(CConvexQuadraticModel & s, CRowDouble & d, double tau);
    static void CQMDropA(CConvexQuadraticModel & s);
    static void CQMSetB(CConvexQuadraticModel & s, CRowDouble & b);
    static void CQMSetQ(CConvexQuadraticModel & s, CMatrixDouble & q, CRowDouble & r, int k, double theta);
    static void CQMSetActiveSet(CConvexQuadraticModel & s, CRowDouble & x, bool & activeset);
    static double CQMEval(CConvexQuadraticModel & s, CRowDouble & x);
    static void CQMEvalX(CConvexQuadraticModel & s, CRowDouble & x, double & r, double & noise);
    static void CQMGradUnconstrained(CConvexQuadraticModel & s, CRowDouble & x, CRowDouble & g);
    static double CQMXTADX2(CConvexQuadraticModel & s, CRowDouble & x, CRowDouble & tmp);
    static void CQMADX(CConvexQuadraticModel & s, CRowDouble & x, CRowDouble & y);
    static bool CQMConstrainedOptimum(CConvexQuadraticModel & s, CRowDouble & x);
    static void CQMScaleVector(CConvexQuadraticModel & s, CRowDouble & x);
    static void CQMGetDiagA(CConvexQuadraticModel & s, CRowDouble & x);
    static double CQMDebugConstrainedEvalT(CConvexQuadraticModel & s, CRowDouble & x);
    static double CQMDebugConstrainedEvalE(CConvexQuadraticModel & s, CRowDouble & x);
};

struct CQQPSettings {
public:
    int m_cgmaxits;
    int m_cgminits;
    int m_cnmaxupdates;
    int m_maxouterits;
    int m_sparsesolver;
    double m_epsf;
    double m_epsg;
    double m_epsx;
    bool m_cgphase;
    bool m_cnphase;
    CQQPSettings(void);
    ~CQQPSettings();
    void Copy(const CQQPSettings & obj);
};

struct CQQPBuffers {
public:
    int m_akind;
    int m_cnmodelage;
    int m_n;
    int m_nfree;
    int m_repinneriterationscount;
    int m_repncholesky;
    int m_repncupdates;
    int m_repouteriterationscount;
    double m_absamax;
    double m_absasum;
    double m_absasum2;
    bool m_activated;
    bool m_havebndl;
    bool m_havebndu;
    bool m_sparseupper;
    bool m_tmpcnb;
    CSparseMatrix m_sparsea;
    CSparseMatrix m_sparsecca;
    CSparseBuffers m_sbuf;
    CSActiveSet m_sas;
    CRowInt m_tmpcni;
    CRowInt m_yidx;
    CRowDouble m_b;
    CRowDouble m_bndl;
    CRowDouble m_bndu;
    CRowDouble m_cgc;
    CRowDouble m_cgp;
    CRowDouble m_dc;
    CRowDouble m_dp;
    CRowDouble m_gc;
    CRowDouble m_regdiag;
    CRowDouble m_regx0;
    CRowDouble m_stpbuf;
    CRowDouble m_tmp0;
    CRowDouble m_tmp1;
    CRowDouble m_tmpcn;
    CRowDouble m_xf;
    CRowDouble m_xp;
    CRowDouble m_xs;
    CMatrixDouble m_densea;
    CMatrixDouble m_densez;
    CQQPBuffers(void);
    ~CQQPBuffers();
    void Copy(const CQQPBuffers & obj);
};

class CQQPSolver {
public:
    static const int m_quickqprestartcg;
    static const double m_regz;
    static void QQPLoadDefaults(int n, CQQPSettings & s);
    static void QQPCopySettings(CQQPSettings & src, CQQPSettings & dst);
    static void QQPPreAllocateGrowDense(CQQPBuffers & sstate, int nexpected, int ngrowto);
    static void QQPOptimize(CConvexQuadraticModel & cqmac, CSparseMatrix & sparseac, CMatrixDouble & denseac, int akind, bool IsUpper, CRowDouble & bc, CRowDouble & bndlc, CRowDouble & bnduc, CRowDouble & sc, CRowDouble & xoriginc, int nc, CQQPSettings & Settings, CQQPBuffers & sstate, CRowDouble & xs, int & terminationtype);
};

struct CQPDenseAULSettings {
public:
    int m_outerits;
    double m_epsx;
    double m_rho;
    CQPDenseAULSettings(void);
    ~CQPDenseAULSettings();
    void Copy(const CQPDenseAULSettings & obj);
};

struct CQPDenseAULBuffers {
public:
    int m_repinneriterationscount;
    int m_repncholesky;
    int m_repnmv;
    int m_repnwrk0;
    int m_repnwrk1;
    int m_repnwrkchanges;
    int m_repnwrkf;
    int m_repouteriterationscount;
    bool m_sclsfthasbndl;
    bool m_sclsfthasbndu;
    CSparseMatrix m_dummysparse;
    CRowInt m_cidx;
    CRowInt m_nicnact;
    CRowDouble m_cscales;
    CRowDouble m_d;
    CRowDouble m_deltax;
    CRowDouble m_exb;
    CRowDouble m_exbndl;
    CRowDouble m_exbndu;
    CRowDouble m_exscale;
    CRowDouble m_exxc;
    CRowDouble m_exxorigin;
    CRowDouble m_modelg;
    CRowDouble m_nicerr;
    CRowDouble m_nulc;
    CRowDouble m_nulcest;
    CRowDouble m_qrrightpart;
    CRowDouble m_qrsv0;
    CRowDouble m_qrsvx1;
    CRowDouble m_qrtau;
    CRowDouble m_sclsftb;
    CRowDouble m_sclsftbndl;
    CRowDouble m_sclsftbndu;
    CRowDouble m_sclsftxc;
    CRowDouble m_tmp0;
    CRowDouble m_tmpg;
    CQQPSettings m_qqpsettingsuser;
    CQQPBuffers m_qqpbuf;
    CMatrixDouble m_exa;
    CMatrixDouble m_qrkkt;
    CMatrixDouble m_sclsfta;
    CMatrixDouble m_sclsftcleic;
    CMatrixDouble m_tmp2;
    CConvexQuadraticModel m_dummycqm;
    CQPDenseAULBuffers(void);
    ~CQPDenseAULBuffers();
    void Copy(const CQPDenseAULBuffers & obj);
};

class CQPDenseAULSolver {
public:
    static const double m_evictionlevel;
    static const double m_expansionratio;
    static void QPDenseAULLoadDefaults(int nmain, CQPDenseAULSettings & s);
    static void QPDenseAULOptimize(CConvexQuadraticModel & a, CSparseMatrix & sparsea, int akind, bool sparseaupper, CRowDouble & b, CRowDouble & bndl, CRowDouble & bndu, CRowDouble & s, CRowDouble & xorigin, int nn, CMatrixDouble & cleic, int dnec, int dnic, CSparseMatrix & scleic, int snec, int snic, bool renormlc, CQPDenseAULSettings & Settings, CQPDenseAULBuffers & State, CRowDouble & xs, CRowDouble & lagbc, CRowDouble & laglc, int & terminationtype);
};

struct CQPBLEICSettings {
public:
    int m_maxits;
    double m_epsf;
    double m_epsg;
    double m_epsx;
    CQPBLEICSettings(void);
    ~CQPBLEICSettings();
    void Copy(const CQPBLEICSettings & obj);
};

struct CQPBLEICbuffers {
public:
    int m_repinneriterationscount;
    int m_repouteriterationscount;
    CRowInt m_tmpi;
    CRowDouble m_tmp0;
    CRowDouble m_tmp1;
    CMinBLEICState m_solver;
    CMinBLEICReport m_solverrep;
    CQPBLEICbuffers(void);
    ~CQPBLEICbuffers();
    void Copy(const CQPBLEICbuffers & obj);
};

class CQPBLEICSolver {
public:
    static void QPBLEICLoadDefaults(int nmain, CQPBLEICSettings & s);
    static void QPBLEICCopySettings(CQPBLEICSettings & src, CQPBLEICSettings & dst);
    static void QPBLEICOptimize(CConvexQuadraticModel & a, CSparseMatrix & sparsea, int akind, bool sparseaupper, double absasum, double absasum2, CRowDouble & b, CRowDouble & bndl, CRowDouble & bndu, CRowDouble & s, CRowDouble & xorigin, int n, CMatrixDouble & cleic, int nec, int nic, CQPBLEICSettings & Settings, CQPBLEICbuffers & sstate, bool & firstcall, CRowDouble & xs, int & terminationtype);
};

class CMinQPState {
public:
    int m_akind;
    int m_algokind;
    int m_mdense;
    int m_msparse;
    int m_n;
    int m_repinneriterationscount;
    int m_repncholesky;
    int m_repnmv;
    int m_repouteriterationscount;
    int m_repterminationtype;
    int m_stype;
    double m_absamax;
    double m_absasum2;
    double m_absasum;
    double m_veps;
    bool m_dbgskipconstraintnormalization;
    bool m_havex;
    bool m_qpbleicfirstcall;
    bool m_sparseaupper;
    CVIPMState m_vsolver;
    CQQPSettings m_qqpsettingsuser;
    CQQPBuffers m_qqpbuf;
    CQPDenseAULSettings m_qpdenseaulsettingsuser;
    CQPDenseAULBuffers m_qpdenseaulbuf;
    CQPBLEICbuffers m_qpbleicbuf;
    CQPBLEICSettings m_qpbleicsettingsuser;
    CConvexQuadraticModel m_a;
    bool m_havebndl;
    bool m_havebndu;
    CRowInt m_elagidx;
    CRowDouble m_b;
    CRowDouble m_bndl;
    CRowDouble m_bndu;
    CRowDouble m_cl;
    CRowDouble m_cu;
    CRowDouble m_effectives;
    CRowDouble m_elaglc;
    CRowDouble m_elagmlt;
    CRowDouble m_replagbc;
    CRowDouble m_replaglc;
    CRowDouble m_s;
    CRowDouble m_startx;
    CRowDouble m_tmp0;
    CRowDouble m_wrkbndl;
    CRowDouble m_wrkbndu;
    CRowDouble m_wrkcl;
    CRowDouble m_wrkcu;
    CRowDouble m_xorigin;
    CRowDouble m_xs;
    CSparseMatrix m_dummysparse;
    CSparseMatrix m_sparsea;
    CSparseMatrix m_sparsec;
    CSparseMatrix m_wrksparsec;
    CMatrixDouble m_densec;
    CMatrixDouble m_dummyr2;
    CMatrixDouble m_ecleic;
    CMatrixDouble m_tmpr2;
    CMatrixDouble m_wrkdensec;
    CMinQPState(void);
    ~CMinQPState();
    void Copy(const CMinQPState & obj);
};

class CMinQPStateShell {
public:
    CMinQPStateShell(void);
    CMinQPStateShell(CMinQPState & obj);
    ~CMinQPStateShell();
};

class CMinQPReport {
public:
    int m_inneriterationscount;
    int m_outeriterationscount;
    int m_nmv;
    int m_ncholesky;
    int m_terminationtype;
    CRowDouble m_lagbc;
    CRowDouble m_laglc;
    CMinQPReport(void);
    ~CMinQPReport();
    void Copy(const CMinQPReport & obj);
};

class CMinQPReportShell {
public:
    CMinQPReportShell(void);
    CMinQPReportShell(CMinQPReport & obj);
    ~CMinQPReportShell();
    int GetInnerIterationsCount(void);
    void SetInnerIterationsCount(const int i);
    int GetOuterIterationsCount(void);
    void SetOuterIterationsCount(const int i);
    int GetNMV(void);
    void SetNMV(const int i);
    int GetNCholesky(void);
    void SetNCholesky(const int i);
    int GetTerminationType(void);
    void SetTerminationType(const int i);
};

class CMinQP {
public:
    static void MinQPCreate(const int n, CMinQPState & State);
    static void MinQPSetLinearTerm(CMinQPState & State, double & b);
    static void MinQPSetLinearTerm(CMinQPState & State, CRowDouble & b);
    static void MinQPSetQuadraticTerm(CMinQPState & State, CMatrixDouble & a, const bool IsUpper);
    static void MinQPSetQuadraticTermSparse(CMinQPState & State, CSparseMatrix & a, bool IsUpper);
    static void MinQPSetStartingPoint(CMinQPState & State, double & x);
    static void MinQPSetStartingPoint(CMinQPState & State, CRowDouble & x);
    static void MinQPSetOrigin(CMinQPState & State, double & xorigin);
    static void MinQPSetOrigin(CMinQPState & State, CRowDouble & xorigin);
    static void MinQPSetScale(CMinQPState & State, CRowDouble & s);
    static void MinQPSetScaleAutoDiag(CMinQPState & State);
    static void MinQPSetAlgoBLEIC(CMinQPState & State, double epsg, double epsf, double epsx, int m_maxits);
    static void MinQPSetAlgoDenseAUL(CMinQPState & State, double epsx, double rho, int itscnt);
    static void MinQPSetAlgoDenseIPM(CMinQPState & State, double eps);
    static void MinQPSetAlgoSparseIPM(CMinQPState & State, double eps);
    static void MinQPSetAlgoQuickQP(CMinQPState & State, double epsg, double epsf, double epsx, int maxouterits, bool usenewton);
    static void MinQPSetAlgoCholesky(CMinQPState & State);
    static void MinQPSetBC(CMinQPState & State, double & bndl, double & bndu);
    static void MinQPSetBC(CMinQPState & State, CRowDouble & bndl, CRowDouble & bndu);
    static void MinQPSetBCAll(CMinQPState & State, double bndl, double bndu);
    static void MinQPSetBCI(CMinQPState & State, int i, double bndl, double bndu);
    static void MinQPSetLC(CMinQPState & State, CMatrixDouble & c, CRowInt & ct, int k);
    static void MinQPSetLCSparse(CMinQPState & State, CSparseMatrix & c, CRowInt & ct, int k);
    static void MinQPSetLCMixed(CMinQPState & State, CSparseMatrix & sparsec, CRowInt & sparsect, int sparsek, CMatrixDouble & densec, CRowInt & densect, int densek);
    static void MinQPSetLCMixedLegacy(CMinQPState & State, CMatrixDouble & densec, CRowInt & densect, int densek, CSparseMatrix & sparsec, CRowInt & sparsect, int sparsek);
    static void MinQPSetLC2Dense(CMinQPState & State, CMatrixDouble & a, CRowDouble & al, CRowDouble & au, int k);
    static void MinQPSetLC2(CMinQPState & State, CSparseMatrix & a, CRowDouble & al, CRowDouble & au, int k);
    static void MinQPSetLC2Mixed(CMinQPState & State, CSparseMatrix & sparsea, int ksparse, CMatrixDouble & densea, int kdense, CRowDouble & al, CRowDouble & au);
    static void MinQPAddLC2Dense(CMinQPState & State, CRowDouble & a, double al, double au);
    static void MinQPAddLC2(CMinQPState & State, CRowInt & idxa, CRowDouble & vala, int nnz, double al, double au);
    static void MinQPAddLC2SparseFromDense(CMinQPState & State, CRowDouble & da, double al, double au);
    static void MinQPOptimize(CMinQPState & State);
    static void MinQPResults(CMinQPState & State, double & x, CMinQPReport & rep);
    static void MinQPResults(CMinQPState & State, CRowDouble & x, CMinQPReport & rep);
    static void MinQPResultsBuf(CMinQPState & State, double & x, CMinQPReport & rep);
    static void MinQPResultsBuf(CMinQPState & State, CRowDouble & x, CMinQPReport & rep);
    static void MinQPSetLinearTermFast(CMinQPState & State, double & b);
    static void MinQPSetLinearTermFast(CMinQPState & State, CRowDouble & b);
    static void MinQPSetQuadraticTermFast(CMinQPState & State, CMatrixDouble & a, const bool IsUpper, const double s);
    static void MinQPRewriteDiagonal(CMinQPState & State, double & s);
    static void MinQPRewriteDiagonal(CMinQPState & State, CRowDouble & s);
    static void MinQPSetStartingPointFast(CMinQPState & State, double & x);
    static void MinQPSetStartingPointFast(CMinQPState & State, CRowDouble & x);
    static void MinQPSetOriginFast(CMinQPState & State, double & xorigin);
    static void MinQPSetOriginFast(CMinQPState & State, CRowDouble & xorigin);
};

struct CMinLMStepFinder {
public:
    int m_m;
    int m_maxmodelage;
    int m_modelage;
    int m_n;
    double m_actualdecrease;
    double m_epsx;
    double m_f;
    double m_fbase;
    double m_predicteddecrease;
    double m_stpmax;
    bool m_hasfi;
    bool m_havebndl;
    bool m_havebndu;
    bool m_needf;
    bool m_needfi;
    RCommState m_rstate;
    CSparseMatrix m_tmpsp;
    CRowInt m_tmpct;
    CRowDouble m_bndl;
    CRowDouble m_bndu;
    CRowDouble m_choleskybuf;
    CRowDouble m_fi;
    CRowDouble m_fibase;
    CRowDouble m_modeldiag;
    CRowDouble m_s;
    CRowDouble m_tmp0;
    CRowDouble m_x;
    CRowDouble m_xbase;
    CRowDouble m_xdir;
    CMinQPState m_qpstate;
    CMinQPReport m_qprep;
    CMinLMStepFinder(void);
    ~CMinLMStepFinder();
    void Copy(const CMinLMStepFinder & obj);
};

class CMinLMState {
public:
    int m_algomode;
    int m_m;
    int m_maxits;
    int m_maxmodelage;
    int m_modelage;
    int m_n;
    int m_nec;
    int m_nic;
    int m_repiterationscount;
    int m_repncholesky;
    int m_repnfunc;
    int m_repngrad;
    int m_repnhess;
    int m_repnjac;
    int m_repterminationtype;
    double m_actualdecrease;
    double m_diffstep;
    double m_epsx;
    double m_f;
    double m_fbase;
    double m_lambdav;
    double m_nu;
    double m_predicteddecrease;
    double m_stpmax;
    double m_teststep;
    double m_xm1;
    double m_xp1;
    bool m_deltafready;
    bool m_deltaxready;
    bool m_hasf;
    bool m_hasfi;
    bool m_hasg;
    bool m_makeadditers;
    bool m_needf;
    bool m_needfg;
    bool m_needfgh;
    bool m_needfi;
    bool m_needfij;
    bool m_userterminationneeded;
    bool m_xrep;
    bool m_xupdated;
    RCommState m_rstate;
    CSmoothnessMonitor m_smonitor;
    CMinQPState m_qpstate;
    CMinQPReport m_qprep;
    CMinLMStepFinder m_finderstate;
    CMinLBFGSState m_internalstate;
    CMinLBFGSReport m_internalrep;
    bool m_havebndl;
    bool m_havebndu;
    CRowDouble m_bndl;
    CRowDouble m_bndu;
    CRowDouble m_choleskybuf;
    CRowDouble m_deltaf;
    CRowDouble m_deltax;
    CRowDouble m_fc1;
    CRowDouble m_fi;
    CRowDouble m_fibase;
    CRowDouble m_fm1;
    CRowDouble m_fp1;
    CRowDouble m_g;
    CRowDouble m_gbase;
    CRowDouble m_gc1;
    CRowDouble m_gm1;
    CRowDouble m_gp1;
    CRowDouble m_lastscaleused;
    CRowDouble m_s;
    CRowDouble m_tmp0;
    CRowDouble m_x;
    CRowDouble m_xbase;
    CRowDouble m_xdir;
    CRowDouble m_xnew;
    CMatrixDouble m_cleic;
    CMatrixDouble m_h;
    CMatrixDouble m_j;
    CMatrixDouble m_quadraticmodel;
    CMinLMState(void);
    ~CMinLMState();
    void Copy(const CMinLMState & obj);
};

class CMinLMStateShell {
public:
    CMinLMStateShell(void);
    CMinLMStateShell(CMinLMState & obj);
    ~CMinLMStateShell();
    bool GetNeedF(void);
    void SetNeedF(const bool b);
    bool GetNeedFG(void);
    void SetNeedFG(const bool b);
    bool GetNeedFGH(void);
    void SetNeedFGH(const bool b);
    bool GetNeedFI(void);
    void SetNeedFI(const bool b);
    bool GetNeedFIJ(void);
    void SetNeedFIJ(const bool b);
    bool GetXUpdated(void);
    void SetXUpdated(const bool b);
    double GetF(void);
    void SetF(const double d);
};

class CMinLMReport {
public:
    int m_iterationscount;
    int m_terminationtype;
    int m_nfunc;
    int m_njac;
    int m_ngrad;
    int m_nhess;
    int m_ncholesky;
    CMinLMReport(void);
    ~CMinLMReport();
    void Copy(const CMinLMReport & obj);
};

class CMinLMReportShell {
public:
    CMinLMReportShell(void);
    CMinLMReportShell(CMinLMReport & obj);
    ~CMinLMReportShell();
    int GetIterationsCount(void);
    void SetIterationsCount(const int i);
    int GetTerminationType(void);
    void SetTerminationType(const int i);
    int GetNFunc(void);
    void SetNFunc(const int i);
    int GetNJAC(void);
    void SetNJAC(const int i);
    int GetNGrad(void);
    void SetNGrad(const int i);
    int GetNHess(void);
    void SetNHess(const int i);
    int GetNCholesky(void);
    void SetNCholesky(const int i);
};

class CMinLM {
public:
    static const double m_lambdaup;
    static const double m_lambdadown;
    static const double m_suspiciousnu;
    static const int m_smallmodelage;
    static const int m_additers;
    static void MinLMCreateVJ(const int n, const int m, double & x, CMinLMState & State);
    static void MinLMCreateVJ(const int n, const int m, CRowDouble & x, CMinLMState & State);
    static void MinLMCreateV(const int n, const int m, double & x, const double diffstep, CMinLMState & State);
    static void MinLMCreateV(const int n, const int m, CRowDouble & x, const double diffstep, CMinLMState & State);
    static void MinLMCreateFGH(const int n, double & x, CMinLMState & State);
    static void MinLMCreateFGH(const int n, CRowDouble & x, CMinLMState & State);
    static void MinLMSetCond(CMinLMState & State, double epsx, const int m_maxits);
    static void MinLMSetXRep(CMinLMState & State, const bool needxrep);
    static void MinLMSetStpMax(CMinLMState & State, const double stpmax);
    static void MinLMSetScale(CMinLMState & State, double & s);
    static void MinLMSetScale(CMinLMState & State, CRowDouble & s);
    static void MinLMSetBC(CMinLMState & State, double & bndl, double & bndu);
    static void MinLMSetBC(CMinLMState & State, CRowDouble & bndl, CRowDouble & bndu);
    static void MinLMSetLC(CMinLMState & State, CMatrixDouble & c, CRowInt & ct, int k);
    static void MinLMSetAccType(CMinLMState & State, int acctype);
    static void MinLMOptGuardGradient(CMinLMState & State, double teststep);
    static void MinLMOptGuardResults(CMinLMState & State, COptGuardReport & rep);
    static void MinLMResults(CMinLMState & State, double & x, CMinLMReport & rep);
    static void MinLMResults(CMinLMState & State, CRowDouble & x, CMinLMReport & rep);
    static void MinLMResultsBuf(CMinLMState & State, double & x, CMinLMReport & rep);
    static void MinLMResultsBuf(CMinLMState & State, CRowDouble & x, CMinLMReport & rep);
    static void MinLMRestartFrom(CMinLMState & State, double & x);
    static void MinLMRestartFrom(CMinLMState & State, CRowDouble & x);
    static void MinLMRequestTermination(CMinLMState & State);
    static void MinLMCreateVGJ(const int n, const int m, double & x, CMinLMState & State);
    static void MinLMCreateVGJ(const int n, const int m, CRowDouble & x, CMinLMState & State);
    static void MinLMCreateFGJ(const int n, const int m, double & x, CMinLMState & State);
    static void MinLMCreateFGJ(const int n, const int m, CRowDouble & x, CMinLMState & State);
    static void MinLMCreateFJ(const int n, const int m, double & x, CMinLMState & State);
    static void MinLMCreateFJ(const int n, const int m, CRowDouble & x, CMinLMState & State);
    static bool MinLMIteration(CMinLMState & State);
};

class CMinASAState {
public:
    int m_n;
    double m_epsg;
    double m_epsf;
    double m_epsx;
    int m_maxits;
    bool m_xrep;
    double m_stpmax;
    int m_cgtype;
    int m_k;
    int m_nfev;
    int m_mcstage;
    int m_curalgo;
    int m_acount;
    double m_mu;
    double m_finit;
    double m_dginit;
    double m_fold;
    double m_stp;
    double m_laststep;
    double m_f;
    bool m_needfg;
    bool m_xupdated;
    RCommState m_rstate;
    int m_repiterationscount;
    int m_repnfev;
    int m_repterminationtype;
    int m_debugrestartscount;
    CLinMinState m_lstate;
    double m_betahs;
    double m_betady;
    double m_bndl;
    double m_bndu;
    double m_ak;
    double m_xk;
    double m_dk;
    double m_an;
    double m_xn;
    double m_dn;
    double m_d;
    double m_work;
    double m_yk;
    double m_gc;
    double m_x;
    double m_g;
    CMinASAState(void);
    ~CMinASAState();
    void Copy(CMinASAState & obj);
};

class CMinASAStateShell {
public:
    CMinASAStateShell(void);
    CMinASAStateShell(CMinASAState & obj);
    ~CMinASAStateShell();
    bool GetNeedFG(void);
    void SetNeedFG(const bool b);
    bool GetXUpdated(void);
    void SetXUpdated(const bool b);
    double GetF(void);
    void SetF(const double d);
};

class CMinASAReport {
public:
    int m_iterationscount;
    int m_nfev;
    int m_terminationtype;
    int m_activeconstraints;
    CMinASAReport(void);
    ~CMinASAReport();
    void Copy(CMinASAReport & obj);
};

class CMinASAReportShell {
public:
    CMinASAReportShell(void);
    CMinASAReportShell(CMinASAReport & obj);
    ~CMinASAReportShell();
    int GetIterationsCount(void);
    void SetIterationsCount(const int i);
    int GetNFev(void);
    void SetNFev(const int i);
    int GetTerminationType(void);
    void SetTerminationType(const int i);
    int GetActiveConstraints(void);
    void SetActiveConstraints(const int i);
};

class CMinComp {
public:
    static const int m_n1;
    static const int m_n2;
    static const double m_stpmin;
    static const double m_gtol;
    static const double m_gpaftol;
    static const double m_gpadecay;
    static const double m_asarho;
    static void MinLBFGSSetDefaultPreconditioner(CMinLBFGSState & State);
    static void MinLBFGSSetCholeskyPreconditioner(CMinLBFGSState & State, CMatrixDouble & p, const bool IsUpper);
    static void MinBLEICSetBarrierWidth(CMinBLEICState & State, const double mu);
    static void MinBLEICSetBarrierDecay(CMinBLEICState & State, const double mudecay);
    static void MinASACreate(const int n, double & x, double & bndl, double & bndu, CMinASAState & State);
    static void MinASASetCond(CMinASAState & State, const double epsg, const double epsf, double epsx, const int m_maxits);
    static void MinASASetXRep(CMinASAState & State, const bool needxrep);
    static void MinASASetAlgorithm(CMinASAState & State, int algotype);
    static void MinASASetStpMax(CMinASAState & State, const double stpmax);
    static void MinASAResults(CMinASAState & State, double & x, CMinASAReport & rep);
    static void MinASAResultsBuf(CMinASAState & State, double & x, CMinASAReport & rep);
    static void MinASARestartFrom(CMinASAState & State, double & x, double & bndl, double & bndu);
    static bool MinASAIteration(CMinASAState & State);
};

class CLPQPServ {
public:
    static void ScaleShiftBCInplace(CRowDouble & s, CRowDouble & xorigin, CRowDouble & bndl, CRowDouble & bndu, int n);
    static void ScaleShiftDenseBRLCInplace(CRowDouble & s, CRowDouble & xorigin, int n, CMatrixDouble & densea, CRowDouble & ab, CRowDouble & ar, int m);
    static void ScaleShiftMixedBRLCInplace(CRowDouble & s, CRowDouble & xorigin, int n, CSparseMatrix & sparsea, int msparse, CMatrixDouble & densea, int mdense, CRowDouble & ab, CRowDouble & ar);
    static void ScaleDenseQPInplace(CMatrixDouble & densea, bool IsUpper, int nmain, CRowDouble & denseb, int ntotal, CRowDouble & s);
    static void ScaleSparseQPInplace(CRowDouble & s, int n, CSparseMatrix & sparsea, CRowDouble & denseb);
    static void NormalizeDenseBRLCInplace(CMatrixDouble & densea, CRowDouble & ab, CRowDouble & ar, int n, int m, CRowDouble & rownorms, bool neednorms);
    static void NormalizeMixedBRLCInplace(CSparseMatrix & sparsea, int msparse, CMatrixDouble & densea, int mdense, CRowDouble & ab, CRowDouble & ar, int n, bool limitedamplification, CRowDouble & rownorms, bool neednorms);
    static double NormalizeDenseQPInplace(CMatrixDouble & densea, bool IsUpper, int nmain, CRowDouble & denseb, int ntotal);
    static double NormalizeSparseQPInplace(CSparseMatrix & sparsea, bool IsUpper, CRowDouble & denseb, int n);
    static void UnscaleUnshiftPointBC(CRowDouble & s, CRowDouble & xorigin, CRowDouble & rawbndl, CRowDouble & rawbndu, CRowDouble & sclsftbndl, CRowDouble & sclsftbndu, bool & HasBndL, bool & HasBndU, CRowDouble & x, int n);
};

struct CMinSQPSubSolver {
public:
    int m_activesetsize;
    int m_algokind;
    bool m_hasal;
    bool m_hasau;
    bool m_HasBndL;
    bool m_HasBndU;
    CVIPMState m_ipmsolver;
    CSparseMatrix m_sparsedummy;
    CSparseMatrix m_sparseefflc;
    CSparseMatrix m_sparserawlc;
    CRowInt m_activeidx;
    CRowDouble m_activerhs;
    CRowDouble m_cural;
    CRowDouble m_curau;
    CRowDouble m_curb;
    CRowDouble m_curbndl;
    CRowDouble m_curbndu;
    CRowDouble m_d0;
    CRowDouble m_sk;
    CRowDouble m_tmp0;
    CRowDouble m_tmp1;
    CRowDouble m_tmp2;
    CRowDouble m_yk;
    CMatrixDouble m_activea;
    CMatrixDouble m_densedummy;
    CMatrixDouble m_h;
    CMinSQPSubSolver(void);
    ~CMinSQPSubSolver();
    void Copy(const CMinSQPSubSolver & obj);
};

struct CMinSQPTmpLagrangian {
public:
    CRowDouble m_sclagtmp0;
    CRowDouble m_sclagtmp1;
    CMinSQPTmpLagrangian(void);
    ~CMinSQPTmpLagrangian();
    void Copy(const CMinSQPTmpLagrangian & obj);
};

struct CMinSQPTmpMerit {
public:
    CRowDouble m_mftmp0;
    CMinSQPTmpMerit(void);
    ~CMinSQPTmpMerit();
    void Copy(const CMinSQPTmpMerit & obj);
};

struct CMinSQPMeritPhaseState {
public:
    int m_n;
    int m_nec;
    int m_nic;
    int m_nlec;
    int m_nlic;
    int m_status;
    bool m_increasebigc;
    RCommState m_rmeritphasestate;
    CRowDouble m_d;
    CRowDouble m_dummylagmult;
    CRowDouble m_dx;
    CRowDouble m_lagmult;
    CRowDouble m_penalties;
    CRowDouble m_stepkfi;
    CRowDouble m_stepkfic;
    CRowDouble m_stepkfin;
    CRowDouble m_stepklaggrad;
    CRowDouble m_stepknlaggrad;
    CRowDouble m_stepkx;
    CRowDouble m_stepkxc;
    CRowDouble m_stepkxn;
    CMinSQPTmpMerit m_tmpmerit;
    CMinSQPTmpLagrangian m_tmplagrangianfg;
    CMatrixDouble m_stepkj;
    CMatrixDouble m_stepkjc;
    CMatrixDouble m_stepkjn;
    CMinSQPMeritPhaseState(void);
    ~CMinSQPMeritPhaseState();
    void Copy(const CMinSQPMeritPhaseState & obj);
};

struct CMinSQPState {
public:
    int m_fstagnationcnt;
    int m_maxits;
    int m_n;
    int m_nec;
    int m_nic;
    int m_nlec;
    int m_nlic;
    int m_repbcidx;
    int m_repiterationscount;
    int m_replcidx;
    int m_repnlcidx;
    int m_repsimplexiterations1;
    int m_repsimplexiterations2;
    int m_repsimplexiterations3;
    int m_repsimplexiterations;
    int m_repterminationtype;
    int m_trustradstagnationcnt;
    double m_bigc;
    double m_epsx;
    double m_f;
    double m_repbcerr;
    double m_replcerr;
    double m_repnlcerr;
    double m_trustrad;
    bool m_HasBndL;
    bool m_HasBndU;
    bool m_haslagmult;
    bool m_needfij;
    bool m_xupdated;
    RCommState m_rstate;
    CRowInt m_lcsrcidx;
    CRowDouble m_backupfi;
    CRowDouble m_backupx;
    CRowDouble m_dummylagmult;
    CRowDouble m_fi;
    CRowDouble m_fscales;
    CRowDouble m_meritlagmult;
    CRowDouble m_s;
    CRowDouble m_scaledbndl;
    CRowDouble m_scaledbndu;
    CRowDouble m_step0fi;
    CRowDouble m_step0x;
    CRowDouble m_stepkfi;
    CRowDouble m_stepkx;
    CRowDouble m_tracegamma;
    CRowDouble m_x;
    CMinSQPTmpMerit m_tmpmerit;
    CMinSQPSubSolver m_subsolver;
    CMinSQPMeritPhaseState m_meritstate;
    CMatrixDouble m_abslagmemory;
    CMatrixDouble m_j;
    CMatrixDouble m_scaledcleic;
    CMatrixDouble m_step0j;
    CMatrixDouble m_stepkj;
    CMinSQPState(void);
    ~CMinSQPState();
    void Copy(const CMinSQPState & obj);
};

class CNLCSQP {
public:
    static const int m_fstagnationlimit;
    static const int m_penaltymemlen;
    static const int m_trustradstagnationlimit;
    static const double m_augmentationfactor;
    static const double m_inittrustrad;
    static const double m_maxbigc;
    static const double m_maxtrustraddecay;
    static const double m_maxtrustradgrowth;
    static const double m_meritfunctionbase;
    static const double m_meritfunctiongain;
    static const double m_sqpbigscale;
    static const double m_sqpdeltadecrease;
    static const double m_sqpdeltaincrease;
    static const double m_sqpsmallscale;
    static const double m_stagnationepsf;
    static void MinSQPInitBuf(CRowDouble & bndl, CRowDouble & bndu, CRowDouble & s, CRowDouble & x0, int n, CMatrixDouble & cleic, CRowInt & lcsrcidx, int nec, int nic, int nlec, int nlic, double epsx, int m_maxits, CMinSQPState & State);
    static bool MinSQPIteration(CMinSQPState & State, CSmoothnessMonitor & smonitor, bool userterminationneeded);
};

struct CPresolveInfo {
public:
    int m_newm;
    int m_newn;
    int m_oldm;
    int m_oldn;
    double m_costscale;
    CSparseMatrix m_sparsea;
    CRowDouble m_al;
    CRowDouble m_au;
    CRowDouble m_bndl;
    CRowDouble m_bndu;
    CRowDouble m_c;
    CRowDouble m_colscales;
    CRowDouble m_rawbndl;
    CRowDouble m_rawbndu;
    CRowDouble m_rowscales;
    CPresolveInfo(void);
    ~CPresolveInfo();
    void Copy(const CPresolveInfo & obj);
};

class CLPQPPresolve {
public:
    static void PresolveNoneScaleUser(CRowDouble & s, CRowDouble & c, CRowDouble & bndl, CRowDouble & bndu, int n, CSparseMatrix & sparsea, CRowDouble & al, CRowDouble & au, int k, CPresolveInfo & Info);
    static void PresolveBwd(CPresolveInfo & Info, CRowDouble & x, CRowInt & stats, CRowDouble & lagbc, CRowDouble & laglc);
};

struct CDualSimplexSettings {
public:
    int m_maxtrfage;
    int m_pricing;
    int m_ratiotest;
    int m_shifting;
    int m_trftype;
    double m_dtolabs;
    double m_perturbmag;
    double m_pivottol;
    double m_xtolabs;
    double m_xtolrelabs;
    CDualSimplexSettings(void);
    ~CDualSimplexSettings();
    void Copy(const CDualSimplexSettings & obj);
};

struct CDSSVector {
public:
    int m_k;
    int m_n;
    CRowInt m_idx;
    CRowDouble m_dense;
    CRowDouble m_vals;
    CDSSVector(void);
    ~CDSSVector();
    void Copy(const CDSSVector & obj);
};

struct CDualSimplexBasis {
public:
    int m_m;
    int m_ns;
    int m_statfact;
    int m_statupdt;
    int m_trfage;
    int m_trftype;
    double m_eminu;
    double m_statoffdiag;
    bool m_dsevalid;
    bool m_isbasic;
    bool m_isvalidtrf;
    CSparseMatrix m_sparsel;
    CSparseMatrix m_sparselu1;
    CSparseMatrix m_sparselu2;
    CSparseMatrix m_sparseludbg;
    CSparseMatrix m_sparseu;
    CSparseMatrix m_sparseut;
    CSLUV2Buffer m_lubuf2;
    CRowInt m_colpermbwd;
    CRowInt m_densep2;
    CRowInt m_densep2c;
    CRowInt m_dk;
    CRowInt m_idx;
    CRowInt m_nidx;
    CRowInt m_nrs;
    CRowInt m_rk;
    CRowInt m_rowpermbwd;
    CRowInt m_tcinvidx;
    CRowInt m_tmpi;
    CRowInt m_utmpi;
    CRowDouble m_densemu;
    CRowDouble m_densepfieta;
    CRowDouble m_dseweights;
    CRowDouble m_utmp0;
    CRowDouble m_wtmp0;
    CRowDouble m_wtmp1;
    CRowDouble m_wtmp2;
    CMatrixDouble m_denselu2;
    CMatrixDouble m_denselu;
    CDualSimplexBasis(void);
    ~CDualSimplexBasis();
    void Copy(const CDualSimplexBasis & obj);
};

struct CDualSimplexSubproblem {
public:
    int m_m;
    int m_ns;
    int m_state;
    CRowInt m_bndt;
    CRowInt m_bndtb;
    CRowDouble m_bndl;
    CRowDouble m_bndlb;
    CRowDouble m_bndtollb;
    CRowDouble m_bndtolub;
    CRowDouble m_bndu;
    CRowDouble m_bndub;
    CRowDouble m_d;
    CRowDouble m_effc;
    CRowDouble m_rawc;
    CRowDouble m_xa;
    CRowDouble m_xb;
    CDualSimplexSubproblem(void);
    ~CDualSimplexSubproblem();
    void Copy(const CDualSimplexSubproblem & obj);
};

struct CDualSimplexState {
public:
    int m_m;
    int m_ns;
    int m_possibleflipscnt;
    int m_repdualbtrantime;
    int m_repdualftrantime;
    int m_repdualpivotrowtime;
    int m_repdualpricingtime;
    int m_repdualratiotesttime;
    int m_repdualupdatesteptime;
    int m_repfilldensemucnt;
    int m_repfillpivotrowcnt;
    int m_repfillrhorcnt;
    int m_repiterationscount1;
    int m_repiterationscount2;
    int m_repiterationscount3;
    int m_repiterationscount;
    int m_repphase1time;
    int m_repphase2time;
    int m_repphase3time;
    int m_repterminationtype;
    double m_repfilldensemu;
    double m_repfillpivotrow;
    double m_repfillrhor;
    bool m_dodetailedtrace;
    bool m_dotimers;
    bool m_dotrace;
    CSparseMatrix m_a;
    CSparseMatrix m_at;
    CRowInt m_eligiblealphar;
    CRowInt m_harrisset;
    CRowInt m_possibleflips;
    CRowInt m_repstats;
    CRowInt m_ustmpi;
    CRowDouble m_alphaq;
    CRowDouble m_alphaqim;
    CRowDouble m_btrantmp0;
    CRowDouble m_btrantmp1;
    CRowDouble m_btrantmp2;
    CRowDouble m_dfctmp0;
    CRowDouble m_dfctmp1;
    CRowDouble m_dfctmp2;
    CRowDouble m_ftrantmp0;
    CRowDouble m_ftrantmp1;
    CRowDouble m_rawbndl;
    CRowDouble m_rawbndu;
    CRowDouble m_replagbc;
    CRowDouble m_replaglc;
    CRowDouble m_repx;
    CRowDouble m_rowscales;
    CRowDouble m_tau;
    CRowDouble m_tmp0;
    CRowDouble m_tmp1;
    CRowDouble m_tmp2;
    CDualSimplexSubproblem m_phase1;
    CDualSimplexSubproblem m_phase3;
    CDualSimplexSubproblem m_primary;
    CDualSimplexBasis m_basis;
    CDSSVector m_alphar;
    CDSSVector m_rhor;
    CApBuff m_xydsbuf;
    CDualSimplexState(void);
    ~CDualSimplexState();
    void Copy(const CDualSimplexState & obj);
};

class CRevisedDualSimplex {
public:
    static const int m_maxforcedrestarts;
    static const int m_safetrfage;
    static const int m_defaultmaxtrfage;
    static const double m_minbeta;
    static const double m_maxudecay;
    static const double m_shiftlen;
    static const double m_alphatrigger;
    static const double m_alphatrigger2;
    static const int m_ssinvalid;
    static const int m_ssvalidxn;
    static const int m_ssvalid;
    static const int m_ccfixed;
    static const int m_cclower;
    static const int m_ccupper;
    static const int m_ccrange;
    static const int m_ccfree;
    static const int m_ccinfeasible;
    static void DSSSettingsInit(CDualSimplexSettings & Settings);
    static void DSSInit(int n, CDualSimplexState & s);
    static void DSSSetProblem(CDualSimplexState & State, CRowDouble & c, CRowDouble & bndl, CRowDouble & bndu, CMatrixDouble & densea, CSparseMatrix & sparsea, int akind, CRowDouble & al, CRowDouble & au, int k, CDualSimplexBasis & proposedbasis, int basisinittype, CDualSimplexSettings & Settings);
    static void DSSExportBasis(CDualSimplexState & State, CDualSimplexBasis & basis);
    static void DSSOptimize(CDualSimplexState & State, CDualSimplexSettings & Settings);
};

struct CMinLPState {
public:
    int m_algokind;
    int m_m;
    int m_n;
    int m_repiterationscount;
    int m_repm;
    int m_repn;
    int m_repterminationtype;
    double m_dsseps;
    double m_ipmeps;
    double m_ipmlambda;
    double m_repdualerror;
    double m_repf;
    double m_repprimalerror;
    double m_repslackerror;
    CVIPMState m_ipm;
    CSparseMatrix m_a;
    CSparseMatrix m_ipmquadratic;
    CRowInt m_adddtmpi;
    CRowInt m_cs;
    CRowDouble m_adddtmpr;
    CRowDouble m_al;
    CRowDouble m_au;
    CRowDouble m_bndl;
    CRowDouble m_bndu;
    CRowDouble m_c;
    CRowDouble m_lagbc;
    CRowDouble m_laglc;
    CRowDouble m_s;
    CRowDouble m_tmpax;
    CRowDouble m_tmpg;
    CRowDouble m_units;
    CRowDouble m_xs;
    CRowDouble m_zeroorigin;
    CPresolveInfo m_presolver;
    CDualSimplexState m_dss;
    CMinLPState(void);
    ~CMinLPState();
    void Copy(const CMinLPState & obj);
};

struct CMinLPReport {
public:
    int m_iterationscount;
    int m_terminationtype;
    double m_dualerror;
    double m_f;
    double m_primalerror;
    double m_slackerror;
    CRowInt m_stats;
    CRowDouble m_lagbc;
    CRowDouble m_laglc;
    CRowDouble m_y;
    CMinLPReport(void);
    ~CMinLPReport();
    void Copy(const CMinLPReport & obj);
};

class CMinLP {
public:
    static const int m_alllogicalsbasis;
    static void MinLPCreate(int n, CMinLPState & State);
    static void MinLPSetAlgoDSS(CMinLPState & State, double eps);
    static void MinLPSetAlgoIPM(CMinLPState & State, double eps);
    static void MinLPSetCost(CMinLPState & State, CRowDouble & c);
    static void MinLPSetScale(CMinLPState & State, CRowDouble & s);
    static void MinLPSetBC(CMinLPState & State, CRowDouble & bndl, CRowDouble & bndu);
    static void MinLPSetBCAll(CMinLPState & State, double bndl, double bndu);
    static void MinLPSetBCi(CMinLPState & State, int i, double bndl, double bndu);
    static void MinLPSetLC(CMinLPState & State, CMatrixDouble & a, CRowInt & ct, int k);
    static void MinLPSetLC2Dense(CMinLPState & State, CMatrixDouble & a, CRowDouble & al, CRowDouble & au, int k);
    static void MinLPSetLC2(CMinLPState & State, CSparseMatrix & a, CRowDouble & al, CRowDouble & au, int k);
    static void MinLPAddLC2Dense(CMinLPState & State, CRowDouble & a, double al, double au);
    static void MinLPAddLC2(CMinLPState & State, CRowInt & idxa, CRowDouble & vala, int nnz, double al, double au);
    static void MinLPOptimize(CMinLPState & State);
    static void MinLPResults(CMinLPState & State, CRowDouble & x, CMinLPReport & rep);
    static void MinLPResultsBuf(CMinLPState & State, CRowDouble & x, CMinLPReport & rep);
};

struct CMinSLPSubsolver {
public:
    int m_curdcnt;
    int m_hessiantype;
    bool m_basispresent;
    CSparseMatrix m_sparsedummy;
    CSparseMatrix m_sparseefflc;
    CSparseMatrix m_sparserawlc;
    CRowInt m_cs;
    CRowDouble m_cural;
    CRowDouble m_curau;
    CRowDouble m_curb;
    CRowDouble m_curbndl;
    CRowDouble m_curbndu;
    CRowDouble m_lagbc;
    CRowDouble m_laglc;
    CRowDouble m_sk;
    CRowDouble m_tmp0;
    CRowDouble m_tmp1;
    CRowDouble m_xs;
    CRowDouble m_yk;
    CPresolveInfo m_presolver;
    CMatrixDouble m_curd;
    CMatrixDouble m_curhd;
    CMatrixDouble m_densedummy;
    CMatrixDouble m_h;
    CDualSimplexState m_dss;
    CDualSimplexSettings m_dsssettings;
    CDualSimplexBasis m_lastbasis;
    CMinSLPSubsolver(void);
    ~CMinSLPSubsolver();
    void Copy(const CMinSLPSubsolver & obj);
};

struct CMinSLPTmpLagrangian {
public:
    CRowDouble m_sclagtmp0;
    CRowDouble m_sclagtmp1;
    CMinSLPTmpLagrangian(void);
    ~CMinSLPTmpLagrangian();
    void Copy(const CMinSLPTmpLagrangian & obj);
};

struct CMinSLPTmpMerit {
public:
    CRowDouble m_mftmp0;
    CMinSLPTmpMerit(void);
    ~CMinSLPTmpMerit();
    void Copy(const CMinSLPTmpMerit & obj);
};

struct CMinSLPPhase13State {
public:
    bool m_usecorrection;
    RCommState m_rphase13state;
    CRowDouble m_d;
    CRowDouble m_dummylagmult;
    CRowDouble m_dx;
    CRowDouble m_stepkfic;
    CRowDouble m_stepkfin;
    CRowDouble m_stepkxc;
    CRowDouble m_stepkxn;
    CMinSLPTmpMerit m_tmpmerit;
    CMatrixDouble m_stepkjc;
    CMatrixDouble m_stepkjn;
    CMinSLPPhase13State(void);
    ~CMinSLPPhase13State();
    void Copy(const CMinSLPPhase13State & obj);
};

struct CMinSLPPhase2State {
public:
    int m_lastlcidx;
    int m_lastnlcidx;
    double m_lastlcerr;
    double m_lastnlcerr;
    RCommState m_rphase2state;
    CRowDouble m_d;
    CRowDouble m_meritlagmult;
    CRowDouble m_stepkfic;
    CRowDouble m_stepkfin;
    CRowDouble m_stepklaggrad;
    CRowDouble m_stepknlaggrad;
    CRowDouble m_stepknlagmult;
    CRowDouble m_stepkxc;
    CRowDouble m_stepkxn;
    CRowDouble m_tmp0;
    CMinSLPTmpMerit m_tmpmerit;
    CMinSLPTmpLagrangian m_tmplagrangianfg;
    CMatrixDouble m_stepkjc;
    CMatrixDouble m_stepkjn;
    CLinMinState m_mcstate;
    CMinSLPPhase2State(void);
    ~CMinSLPPhase2State();
    void Copy(const CMinSLPPhase2State & obj);
};

struct CMinSLPState {
public:
    int m_fstagnationcnt;
    int m_hessiantype;
    int m_historylen;
    int m_lpfailurecnt;
    int m_maxits;
    int m_n;
    int m_nec;
    int m_nic;
    int m_nlec;
    int m_nlic;
    int m_repbcidx;
    int m_repinneriterationscount;
    int m_replcidx;
    int m_repnlcidx;
    int m_repouteriterationscount;
    int m_repsimplexiterations1;
    int m_repsimplexiterations2;
    int m_repsimplexiterations3;
    int m_repsimplexiterations;
    int m_repterminationtype;
    double m_bigc;
    double m_epsx;
    double m_f;
    double m_repbcerr;
    double m_replcerr;
    double m_repnlcerr;
    double m_trustrad;
    bool m_HasBndL;
    bool m_HasBndU;
    bool m_needfij;
    bool m_xupdated;
    RCommState m_rstate;
    CRowInt m_lcsrcidx;
    CRowDouble m_backupfi;
    CRowDouble m_backupx;
    CRowDouble m_dummylagmult;
    CRowDouble m_fi;
    CRowDouble m_fscales;
    CRowDouble m_maxlaghistory;
    CRowDouble m_meritfunctionhistory;
    CRowDouble m_meritlagmult;
    CRowDouble m_s;
    CRowDouble m_scaledbndl;
    CRowDouble m_scaledbndu;
    CRowDouble m_step0fi;
    CRowDouble m_step0x;
    CRowDouble m_stepkfi;
    CRowDouble m_stepkx;
    CRowDouble m_x;
    CMinSLPTmpMerit m_tmpmerit;
    CMinSLPSubsolver m_subsolver;
    CMinSLPPhase2State m_state2;
    CMinSLPPhase13State m_state13;
    CMatrixDouble m_backupj;
    CMatrixDouble m_j;
    CMatrixDouble m_scaledcleic;
    CMatrixDouble m_step0j;
    CMatrixDouble m_stepkj;
    CMinSLPState(void);
    ~CMinSLPState();
    void Copy(const CMinSLPState & obj);
};

class CNLCSLP {
public:
    static const double m_slpstpclosetozero;
    static const double m_slpdeltadecrease;
    static const double m_slpdeltaincrease;
    static const double m_slpstpclosetoone;
    static const double m_maxtrustraddecay;
    static const double m_maxtrustradgrowth;
    static const double m_slpgtol;
    static const double m_initbigc;
    static const double m_maxbigc;
    static const double m_bfgstol;
    static const double m_defaultl1penalty;
    static const double m_meritfunctionbase;
    static const double m_meritfunctiongain;
    static const double m_inequalitydampingfactor;
    static const double m_augmentationfactor;
    static const double m_inittrustrad;
    static const double m_stagnationepsf;
    static const int m_lpfailureslimit;
    static const int m_fstagnationlimit;
    static const int m_nondescentlimit;
    static const int m_nonmonotonicphase2limit;
    static const double m_slpbigscale;
    static const double m_slpsmallscale;
    static const double m_defaultmaglagdecay;
    static void MinSLPInitBuf(CRowDouble & bndl, CRowDouble & bndu, CRowDouble & s, CRowDouble & x0, int n, CMatrixDouble & cleic, CRowInt & lcsrcidx, int nec, int nic, int nlec, int nlic, double epsx, int m_maxits, CMinSLPState & State);
    static bool MinSLPIteration(CMinSLPState & State, CSmoothnessMonitor & smonitor, bool userterminationneeded);
};

struct CMinNLCState {
public:
    int m_aulitscnt;
    int m_maxits;
    int m_n;
    int m_nec;
    int m_ng;
    int m_nh;
    int m_nic;
    int m_prectype;
    int m_repbcidx;
    int m_repdbgphase0its;
    int m_repinneriterationscount;
    int m_replcidx;
    int m_repnfev;
    int m_repnlcidx;
    int m_repouteriterationscount;
    int m_repterminationtype;
    int m_smoothnessguardlevel;
    int m_solvertype;
    int m_updatefreq;
    double m_diffstep;
    double m_epsx;
    double m_f;
    double m_gammak;
    double m_initialinequalitymultiplier;
    double m_repbcerr;
    double m_replcerr;
    double m_repnlcerr;
    double m_rho;
    double m_stabilizingpoint;
    double m_stpmax;
    double m_teststep;
    bool m_HasBndL;
    bool m_HasBndU;
    bool m_needfi;
    bool m_needfij;
    bool m_userterminationneeded;
    bool m_xkpresent;
    bool m_xrep;
    bool m_xupdated;
    RCommState m_rstate;
    RCommState m_rstateaul;
    RCommState m_rstateslp;
    CSmoothnessMonitor m_smonitor;
    CRowInt m_lcsrcidx;
    CRowDouble m_bndl;
    CRowDouble m_bndu;
    CRowDouble m_bufc;
    CRowDouble m_bufd;
    CRowDouble m_dfbase;
    CRowDouble m_dfm1;
    CRowDouble m_dfp1;
    CRowDouble m_fbase;
    CRowDouble m_fi;
    CRowDouble m_fm1;
    CRowDouble m_fm2;
    CRowDouble m_fp1;
    CRowDouble m_fp2;
    CRowDouble m_gk1;
    CRowDouble m_gk;
    CRowDouble m_lastscaleused;
    CRowDouble m_nubc;
    CRowDouble m_nulc;
    CRowDouble m_nunlc;
    CRowDouble m_s;
    CRowDouble m_scaledbndl;
    CRowDouble m_scaledbndu;
    CRowDouble m_tmp0;
    CRowDouble m_x;
    CRowDouble m_xbase;
    CRowDouble m_xc;
    CRowDouble m_xk1;
    CRowDouble m_xk;
    CRowDouble m_xstart;
    CMinSQPState m_sqpsolverstate;
    CMinSLPState m_slpsolverstate;
    CMinLBFGSState m_auloptimizer;
    CMinLBFGSReport m_aulreport;
    CMatrixDouble m_bufw;
    CMatrixDouble m_bufz;
    CMatrixDouble m_cleic;
    CMatrixDouble m_j;
    CMatrixDouble m_scaledcleic;
    CMinNLCState(void);
    ~CMinNLCState();
    void Copy(const CMinNLCState & obj);
};

struct CMinNLCReport {
public:
    int m_bcidx;
    int m_dbgphase0its;
    int m_iterationscount;
    int m_lcidx;
    int m_nfev;
    int m_nlcidx;
    int m_terminationtype;
    double m_bcerr;
    double m_lcerr;
    double m_nlcerr;
    CMinNLCReport(void);
    ~CMinNLCReport();
    void Copy(const CMinNLCReport & obj);
};

class CMinNLC {
public:
    static const int m_lbfgsfactor;
    static const double m_aulmaxgrowth;
    static const double m_maxlagmult;
    static const double m_hessesttol;
    static const double m_initgamma;
    static const double m_regprec;
    static void MinNLCCreate(int n, CRowDouble & x, CMinNLCState & State);
    static void MinNLCCreateF(int n, CRowDouble & x, double diffstep, CMinNLCState & State);
    static void MinNLCSetBC(CMinNLCState & State, CRowDouble & bndl, CRowDouble & bndu);
    static void MinNLCSetLC(CMinNLCState & State, CMatrixDouble & c, CRowInt & ct, int k);
    static void MinNLCSetNLC(CMinNLCState & State, int nlec, int nlic);
    static void MinNLCSetCond(CMinNLCState & State, double epsx, int m_maxits);
    static void MinNLCSetScale(CMinNLCState & State, CRowDouble & s);
    static void MinNLCSetPrecInexact(CMinNLCState & State);
    static void MinNLCSetPrecExactLowRank(CMinNLCState & State, int updatefreq);
    static void MinNLCSetPrecExactRobust(CMinNLCState & State, int updatefreq);
    static void MinNLCSetPrecNone(CMinNLCState & State);
    static void MinNLCSetSTPMax(CMinNLCState & State, double stpmax);
    static void MinNLCSetAlgoAUL(CMinNLCState & State, double rho, int itscnt);
    static void MinNLCSetAlgoSLP(CMinNLCState & State);
    static void MinNLCSetAlgoSQP(CMinNLCState & State);
    static void MinNLCSetXRep(CMinNLCState & State, bool needxrep);
    static bool MinNLCIteration(CMinNLCState & State);
    static void MinNLCOptGuardGradient(CMinNLCState & State, double teststep);
    static void MinNLCOptGuardSmoothness(CMinNLCState & State, int level);
    static void MinNLCOptGuardResults(CMinNLCState & State, COptGuardReport & rep);
    static void MinNLCOptGuardNonC1Test0Results(CMinNLCState & State, COptGuardNonC1Test0Report & strrep, COptGuardNonC1Test0Report & lngrep);
    static void MinNLCOptGuardNonC1Test1Results(CMinNLCState & State, COptGuardNonC1Test1Report & strrep, COptGuardNonC1Test1Report  & lngrep);
    static void MinNLCResults(CMinNLCState & State, CRowDouble & x, CMinNLCReport & rep);
    static void MinNLCResultsBuf(CMinNLCState & State, CRowDouble & x, CMinNLCReport & rep);
    static void MinNLCRequestTermination(CMinNLCState & State);
    static void MinNLCRestartFrom(CMinNLCState & State, CRowDouble & x);
    static void MinNLCEqualityPenaltyFunction(double alpha, double & f, double & df, double & d2f);
    static void MinNLCInequalityPenaltyFunction(double alpha, double stabilizingpoint, double & f, double & df, double & d2f);
    static void MinNLCInequalityShiftFunction(double alpha, double & f, double & df, double & d2f);
};

struct CMinNSQP {
public:
    double m_fc;
    double m_fn;
    bool m_tmpb;
    CSNNLSSolver m_nnls;
    CRowInt m_tmpidx;
    CRowDouble m_d;
    CRowDouble m_gc;
    CRowDouble m_invutc;
    CRowDouble m_tmp0;
    CRowDouble m_tmpc;
    CRowDouble m_tmpd;
    CRowDouble m_tmplambdas;
    CRowDouble m_x0;
    CRowDouble m_xc;
    CRowDouble m_xn;
    CMatrixDouble m_ch;
    CMatrixDouble m_rk;
    CMatrixDouble m_tmpc2;
    CMatrixDouble m_uh;
    CMinNSQP(void);
    ~CMinNSQP();
    void Copy(const CMinNSQP & obj);
};

struct CMinNSState {
public:
    int m_agsmaxbacktrack;
    int m_agsmaxbacktracknonfull;
    int m_agsmaxraddecays;
    int m_agsminupdate;
    int m_agssamplesize;
    int m_agsshortlimit;
    int m_dbgncholesky;
    int m_maxits;
    int m_n;
    int m_nec;
    int m_ng;
    int m_nh;
    int m_nic;
    int m_repfuncidx;
    int m_repinneriterationscount;
    int m_repnfev;
    int m_repouteriterationscount;
    int m_repterminationtype;
    int m_repvaridx;
    int m_solvertype;
    double m_agsalphadecay;
    double m_agsdecrease;
    double m_agsinitstp;
    double m_agspenaltyincrease;
    double m_agspenaltylevel;
    double m_agsraddecay;
    double m_agsradius;
    double m_agsrhononlinear;
    double m_agsshortf;
    double m_agsshortstpabs;
    double m_agsshortstprel;
    double m_agsstattold;
    double m_diffstep;
    double m_epsx;
    double m_f;
    double m_meritf;
    double m_rawf;
    double m_replcerr;
    double m_repnlcerr;
    double m_rholinear;
    bool m_HasBndL;
    bool m_HasBndU;
    bool m_needfi;
    bool m_needfij;
    bool m_userterminationneeded;
    bool m_xrep;
    bool m_xupdated;
    RCommState m_rstate;
    RCommState m_rstateags;
    CRowInt m_tmp3;
    CRowDouble m_bndl;
    CRowDouble m_bndu;
    CRowDouble m_colmax;
    CRowDouble m_d;
    CRowDouble m_diagh;
    CRowDouble m_fbase;
    CRowDouble m_fi;
    CRowDouble m_fm;
    CRowDouble m_fp;
    CRowDouble m_meritg;
    CRowDouble m_rawg;
    CRowDouble m_s;
    CRowDouble m_samplef;
    CRowDouble m_scaledbndl;
    CRowDouble m_scaledbndu;
    CRowDouble m_signmax;
    CRowDouble m_signmin;
    CRowDouble m_tmp0;
    CRowDouble m_tmp1;
    CRowDouble m_x;
    CRowDouble m_xbase;
    CRowDouble m_xc;
    CRowDouble m_xn;
    CRowDouble m_xscaled;
    CRowDouble m_xstart;
    CMinNSQP m_nsqp;
    CMatrixDouble m_cleic;
    CMatrixDouble m_j;
    CMatrixDouble m_samplegm;
    CMatrixDouble m_samplegmbc;
    CMatrixDouble m_samplex;
    CMatrixDouble m_scaledcleic;
    CMatrixDouble m_tmp2;
    CHighQualityRandState m_agsrs;
    CMinNSState(void);
    ~CMinNSState();
    void Copy(const CMinNSState & obj);
};

struct CMinNSReport {
public:
    int m_funcidx;
    int m_iterationscount;
    int m_nfev;
    int m_terminationtype;
    int m_varidx;
    double m_cerr;
    double m_lcerr;
    double m_nlcerr;
    CMinNSReport(void);
    ~CMinNSReport();
    void Copy(const CMinNSReport & obj);
};

class CMinNS {
public:
    static void MinNSCreate(int n, CRowDouble & x, CMinNSState & State);
    static void MinNSCreateF(int n, CRowDouble & x, double diffstep, CMinNSState & State);
    static void MinNSSetBC(CMinNSState & State, CRowDouble & bndl, CRowDouble & bndu);
    static void MinNSSetLC(CMinNSState & State, CMatrixDouble & c, CRowInt & ct, int k);
    static void MinNSSetNLC(CMinNSState & State, int nlec, int nlic);
    static void MinNSSetCond(CMinNSState & State, double epsx, int m_maxits);
    static void MinNSSetScale(CMinNSState & State, CRowDouble & s);
    static void MinNSSetAlgoAGS(CMinNSState & State, double radius, double penalty);
    static void MinNSSetXRep(CMinNSState & State, bool needxrep);
    static void MinNSRequestTermination(CMinNSState & State);
    static bool MinNSIteration(CMinNSState & State);
    static void MinNSResults(CMinNSState & State, CRowDouble & x, CMinNSReport & rep);
    static void MinNSResultsBuf(CMinNSState & State, CRowDouble & x, CMinNSReport & rep);
    static void MinNSRestartFrom(CMinNSState & State, CRowDouble & x);
};

struct CMinBCState {
public:
    int m_bufsize;
    int m_maxits;
    int m_mcstage;
    int m_nfev;
    int m_nmain;
    int m_nonmonotoniccnt;
    int m_prectype;
    int m_repiterationscount;
    int m_repnfev;
    int m_repterminationtype;
    int m_repvaridx;
    int m_smoothnessguardlevel;
    double m_curstpmax;
    double m_diffstep;
    double m_epsf;
    double m_epsg;
    double m_epsx;
    double m_f;
    double m_fbase;
    double m_fc;
    double m_fm1;
    double m_fm2;
    double m_fn;
    double m_fp1;
    double m_fp2;
    double m_fp;
    double m_gm1;
    double m_gp1;
    double m_lastscaledgoodstep;
    double m_stp;
    double m_stpmax;
    double m_teststep;
    double m_trimthreshold;
    double m_xm1;
    double m_xp1;
    bool m_HasBndL;
    bool m_HasBndU;
    bool m_needf;
    bool m_needfg;
    bool m_userterminationneeded;
    bool m_xrep;
    bool m_xupdated;
    RCommState m_rstate;
    CSmoothnessMonitor m_smonitor;
    CRowDouble m_bndl;
    CRowDouble m_bndu;
    CRowDouble m_bufrho;
    CRowDouble m_buftheta;
    CRowDouble m_cgc;
    CRowDouble m_cgn;
    CRowDouble m_d;
    CRowDouble m_diagh;
    CRowDouble m_g;
    CRowDouble m_invs;
    CRowDouble m_lastscaleused;
    CRowDouble m_s;
    CRowDouble m_tmp0;
    CRowDouble m_tmpprec;
    CRowDouble m_ugc;
    CRowDouble m_ugn;
    CRowDouble m_work;
    CRowDouble m_x;
    CRowDouble m_xc;
    CRowDouble m_xn;
    CRowDouble m_xp;
    CRowDouble m_xstart;
    CMatrixDouble m_bufsk;
    CMatrixDouble m_bufyk;
    CLinMinState m_lstate;
    CMinBCState(void);
    ~CMinBCState();
    void Copy(const CMinBCState & obj);
};

struct CMinBCReport {
public:
    int m_iterationscount;
    int m_nfev;
    int m_terminationtype;
    int m_varidx;
    CMinBCReport(void);
    ~CMinBCReport();
    void Copy(const CMinBCReport & obj);
};

class CMinBC {
public:
    static const double m_gtol;
    static const double m_maxnonmonotoniclen;
    static const double m_initialdecay;
    static const double m_mindecay;
    static const double m_decaycorrection;
    static void MinBCCreate(int n, CRowDouble & x, CMinBCState & State);
    static void MinBCCreateF(int n, CRowDouble & x, double diffstep, CMinBCState & State);
    static void MinBCSetBC(CMinBCState & State, CRowDouble & bndl, CRowDouble & bndu);
    static void MinBCSetCond(CMinBCState & State, double epsg, double epsf, double epsx, int maxits);
    static void MinBCSetScale(CMinBCState & State, CRowDouble & s);
    static void MinBCSetPrecDefault(CMinBCState & State);
    static void MinBCSetPrecDiag(CMinBCState & State, CRowDouble & d);
    static void MinBCSetPrecScale(CMinBCState & State);
    static void MinBCSetXRep(CMinBCState & State, bool needxrep);
    static void MinBCSetStpMax(CMinBCState & State, double stpmax);
    static bool MinBCIteration(CMinBCState & State);
    static void MinBCOptGuardGradient(CMinBCState & State, double teststep);
    static void MinBCOptGuardSmoothness(CMinBCState & State, int level);
    static void MinBCOptGuardResults(CMinBCState & State, COptGuardReport & rep);
    static void MinBCOptGuardNonC1Test0Results(CMinBCState & State, COptGuardNonC1Test0Report & strrep, COptGuardNonC1Test0Report & lngrep);
    static void MinBCOptGuardNonC1Test1Results(CMinBCState & State, COptGuardNonC1Test1Report & strrep, COptGuardNonC1Test1Report & lngrep);
    static void MinBCResults(CMinBCState & State, CRowDouble & x, CMinBCReport & rep);
    static void MinBCResultsBuf(CMinBCState & State, CRowDouble & x, CMinBCReport & rep);
    static void MinBCRestartFrom(CMinBCState & State, CRowDouble & x);
    static void MinBCRequestTermination(CMinBCState & State);
protected:
    static void ClearRequestFields(CMinBCState & State);
    static void MinBCInitInternal(int n, CRowDouble & x, double diffstep, CMinBCState & State);
    static void UpdateEstimateOfGoodStep(double & estimate, double newstep);
};

struct CLPTestProblem {
public:
    int m_m;
    int m_n;
    double m_targetf;
    bool m_hasknowntarget;
    CSparseMatrix m_a;
    CRowDouble m_al;
    CRowDouble m_au;
    CRowDouble m_bndl;
    CRowDouble m_bndu;
    CRowDouble m_c;
    CRowDouble m_s;
    CLPTestProblem(void);
    ~CLPTestProblem();
    void Copy(const CLPTestProblem & obj);
};

class COPTS {
public:
    static void LPTestProblemCreate(int n, bool hasknowntarget, double targetf, CLPTestProblem & p);
    static bool LPTestProblemHasKnownTarget(CLPTestProblem & p);
    static double LPTestProblemGetTargetF(CLPTestProblem & p);
    static int LPTestProblemGetN(CLPTestProblem & p);
    static int LPTestProblemGetM(CLPTestProblem & p);
    static void LPTestProblemSetScale(CLPTestProblem & p, CRowDouble & s);
    static void LPTestProblemSetCost(CLPTestProblem & p, CRowDouble & c);
    static void LPTestProblemSetBC(CLPTestProblem & p, CRowDouble & bndl, CRowDouble & bndu);
    static void LPTestProblemSetLC2(CLPTestProblem & p, CSparseMatrix & a, CRowDouble & al, CRowDouble & au, int m);
    static void LPTestProblemAlloc(CSerializer & s, CLPTestProblem & p);
    static void LPTestProblemSerialize(CSerializer & s, CLPTestProblem & p);
    static void LPTestProblemUnserialize(CSerializer & s, CLPTestProblem & p);
    static void XDBGMinLPCreateFromTestProblem(CLPTestProblem & p, CMinLPState & State);
};

class CDenseSolverReport {
public:
    double m_r1;
    double m_rinf;
    CDenseSolverReport(void);
    ~CDenseSolverReport();
    void Copy(CDenseSolverReport & obj);
};

class CDenseSolverReportShell {
public:
    CDenseSolverReportShell(void);
    CDenseSolverReportShell(CDenseSolverReport & obj);
    ~CDenseSolverReportShell();
    double GetR1(void);
    void SetR1(const double d);
    double GetRInf(void);
    void SetRInf(const double d);
};

class CDenseSolverLSReport {
public:
    double m_r2;
    CMatrixDouble m_cx;
    int m_n;
    int m_k;
    CDenseSolverLSReport(void);
    ~CDenseSolverLSReport();
    void Copy(CDenseSolverLSReport & obj);
};

class CDenseSolverLSReportShell {
public:
    CDenseSolverLSReportShell(void);
    CDenseSolverLSReportShell(CDenseSolverLSReport & obj);
    ~CDenseSolverLSReportShell();
    double GetR2(void);
    void SetR2(const double d);
    int GetN(void);
    void SetN(const int i);
    int GetK(void);
    void SetK(const int i);
};

class CDenseSolver {
public:
    static void RMatrixSolve(CMatrixDouble & a, const int n, double & b, int & info, CDenseSolverReport & rep, double & x);
    static void RMatrixSolve(CMatrixDouble & a, const int n, CRowDouble & b, int & info, CDenseSolverReport & rep, CRowDouble & x);
    static void RMatrixSolveM(CMatrixDouble & a, const int n, CMatrixDouble & b, const int m, const bool rfs, int & info, CDenseSolverReport & rep, CMatrixDouble & x);
    static void RMatrixLUSolve(CMatrixDouble & lua, int & p, const int n, double & b, int & info, CDenseSolverReport & rep, double & x);
    static void RMatrixLUSolveM(CMatrixDouble & lua, int & p, const int n, CMatrixDouble & b, const int m, int & info, CDenseSolverReport & rep, CMatrixDouble & x);
    static void RMatrixMixedSolve(CMatrixDouble & a, CMatrixDouble & lua, int & p, const int n, double & b, int & info, CDenseSolverReport & rep, double & x);
    static void RMatrixMixedSolveM(CMatrixDouble & a, CMatrixDouble & lua, int & p, const int n, CMatrixDouble & b, const int m, int & info, CDenseSolverReport & rep, CMatrixDouble & x);
    static void CMatrixSolveM(CMatrixComplex & a, const int n, CMatrixComplex & b, const int m, const bool rfs, int & info, CDenseSolverReport & rep, CMatrixComplex & x);
    static void CMatrixSolve(CMatrixComplex & a, const int n, complex & b, int & info, CDenseSolverReport & rep, complex & x);
    static void CMatrixLUSolveM(CMatrixComplex & lua, int & p, const int n, CMatrixComplex & b, const int m, int & info, CDenseSolverReport & rep, CMatrixComplex & x);
    static void CMatrixLUSolve(CMatrixComplex & lua, int & p, const int n, complex & b, int & info, CDenseSolverReport & rep, complex & x);
    static void CMatrixMixedSolveM(CMatrixComplex & a, CMatrixComplex & lua, int & p, const int n, CMatrixComplex & b, const int m, int & info, CDenseSolverReport & rep, CMatrixComplex & x);
    static void CMatrixMixedSolve(CMatrixComplex & a, CMatrixComplex & lua, int & p, const int n, complex & b, int & info, CDenseSolverReport & rep, complex & x);
    static void SPDMatrixSolveM(CMatrixDouble & a, const int n, const bool IsUpper, CMatrixDouble & b, const int m, int & info, CDenseSolverReport & rep, CMatrixDouble & x);
    static void SPDMatrixSolve(CMatrixDouble & a, const int n, const bool IsUpper, double & b, int & info, CDenseSolverReport & rep, double & x);
    static void SPDMatrixCholeskySolveM(CMatrixDouble & cha, const int n, const bool IsUpper, CMatrixDouble & b, const int m, int & info, CDenseSolverReport & rep, CMatrixDouble & x);
    static void SPDMatrixCholeskySolve(CMatrixDouble & cha, const int n, const bool IsUpper, double & b, int & info, CDenseSolverReport & rep, double & x);
    static void SPDMatrixCholeskySolve(CMatrixDouble & cha, const int n, const bool IsUpper, CRowDouble & b, int & info, CDenseSolverReport & rep, CRowDouble & x);
    static void HPDMatrixSolveM(CMatrixComplex & a, const int n, const bool IsUpper, CMatrixComplex & b, const int m, int & info, CDenseSolverReport & rep, CMatrixComplex & x);
    static void HPDMatrixSolve(CMatrixComplex & a, const int n, const bool IsUpper, complex & b, int & info, CDenseSolverReport & rep, complex & x);
    static void HPDMatrixCholeskySolveM(CMatrixComplex & cha, const int n, const bool IsUpper, CMatrixComplex & b, const int m, int & info, CDenseSolverReport & rep, CMatrixComplex & x);
    static void HPDMatrixCholeskySolve(CMatrixComplex & cha, const int n, const bool IsUpper, complex & b, int & info, CDenseSolverReport & rep, complex & x);
    static void RMatrixSolveLS(CMatrixDouble & a, const int nrows, const int ncols, double & b, double threshold, int & info, CDenseSolverLSReport & rep, double & x);
};

class CNlEqState {
public:
    int m_n;
    int m_m;
    double m_epsf;
    int m_maxits;
    bool m_xrep;
    double m_stpmax;
    double m_f;
    bool m_needf;
    bool m_needfij;
    bool m_xupdated;
    RCommState m_rstate;
    int m_repiterationscount;
    int m_repnfunc;
    int m_repnjac;
    int m_repterminationtype;
    double m_fbase;
    double m_fprev;
    double m_x;
    double m_fi;
    double m_xbase;
    double m_candstep;
    double m_rightpart;
    double m_cgbuf;
    CMatrixDouble m_j;
    CNlEqState(void);
    ~CNlEqState();
    void Copy(CNlEqState & obj);
};

class CNlEqStateShell {
public:
    CNlEqStateShell(void);
    CNlEqStateShell(CNlEqState & obj);
    ~CNlEqStateShell();
    bool GetNeedF(void);
    void SetNeedF(const bool b);
    bool GetNeedFIJ(void);
    void SetNeedFIJ(const bool b);
    bool GetXUpdated(void);
    void SetXUpdated(const bool b);
    double GetF(void);
    void SetF(const double d);
};

class CNlEqReport {
public:
    int m_iterationscount;
    int m_nfunc;
    int m_njac;
    int m_terminationtype;
    CNlEqReport(void);
    ~CNlEqReport();
    void Copy(CNlEqReport & obj);
};

class CNlEqReportShell {
public:
    CNlEqReportShell(void);
    CNlEqReportShell(CNlEqReport & obj);
    ~CNlEqReportShell();
    int GetIterationsCount(void);
    void SetIterationsCount(const int i);
    int GetNFunc(void);
    void SetNFunc(const int i);
    int GetNJac(void);
    void SetNJac(const int i);
    int GetTerminationType(void);
    void SetTerminationType(const int i);
};

class CNlEq {
public:
    static const int m_armijomaxfev;
    static void NlEqCreateLM(const int n, const int m, double & x, CNlEqState & state);
    static void NlEqSetCond(CNlEqState & state, double epsf, const int maxits);
    static void NlEqSetXRep(CNlEqState & state, const bool needxrep);
    static void NlEqSetStpMax(CNlEqState & state, const double stpmax);
    static void NlEqResults(CNlEqState & state, double & x, CNlEqReport & rep);
    static void NlEqResultsBuf(CNlEqState & state, double & x, CNlEqReport & rep);
    static void NlEqRestartFrom(CNlEqState & state, double & x);
    static bool NlEqIteration(CNlEqState & state);
};

struct CPolynomialSolverReport {
public:
    double m_maxerr;
    CPolynomialSolverReport(void);
    ~CPolynomialSolverReport();
    void Copy(const CPolynomialSolverReport & obj);
};

class CPolynomialSolver {
public:
    static void PolynomialSolve(CRowDouble & a, int n, CRowComplex & x, CPolynomialSolverReport & rep);
};

struct CSparseSolverReport {
public:
    int m_iterationscount;
    int m_nmv;
    int m_terminationtype;
    double m_r2;
    CSparseSolverReport(void);
    ~CSparseSolverReport();
    void Copy(const CSparseSolverReport & obj);
};

class CDirectSparseSolvers {
public:
    static void SparseSPDSolveSKS(CSparseMatrix & a, bool IsUpper, CRowDouble & b, CRowDouble & x, CSparseSolverReport & rep);
    static void SparseSPDSolve(CSparseMatrix & a, bool IsUpper, CRowDouble & b, CRowDouble & x, CSparseSolverReport & rep);
    static void SparseSPDCholeskySolve(CSparseMatrix & a, bool IsUpper, CRowDouble & b, CRowDouble & x, CSparseSolverReport & rep);
    static void SparseSolve(CSparseMatrix & a, CRowDouble & b, CRowDouble & x, CSparseSolverReport & rep);
    static void SparseLUSolve(CSparseMatrix & a, CRowInt & p, CRowInt & q, CRowDouble & b, CRowDouble & x, CSparseSolverReport & rep);
    static void InitSparseSolverReport(CSparseSolverReport & rep);
};

struct CSparseSolverState {
public:
    int m_algotype;
    int m_gmresk;
    int m_maxits;
    int m_n;
    int m_repiterationscount;
    int m_repnmv;
    int m_repterminationtype;
    int m_requesttype;
    double m_epsf;
    double m_reply1;
    double m_repr2;
    bool m_running;
    bool m_userterminationneeded;
    bool m_xrep;
    RCommState m_rstate;
    CSparseMatrix m_convbuf;
    CRowDouble m_ax;
    CRowDouble m_b;
    CRowDouble m_wrkb;
    CRowDouble m_x0;
    CRowDouble m_x;
    CRowDouble m_xf;
    CFblsGMRESState m_gmressolver;
    CSparseSolverState(void);
    ~CSparseSolverState();
    void Copy(const CSparseSolverState & obj);
};

class CIterativeSparse {
public:
    static void SparseSolveSymmetricGMRES(CSparseMatrix & a, bool IsUpper, CRowDouble & b, int k, double epsf, int maxits, CRowDouble & x, CSparseSolverReport & rep);
    static void SparseSolveGMRES(CSparseMatrix & a, CRowDouble & b, int k, double epsf, int maxits, CRowDouble & x, CSparseSolverReport & rep);
    static void SparseSolverCreate(int n, CSparseSolverState & state);
    static void SparseSolverSetAlgoGMRES(CSparseSolverState & state, int k);
    static void SparseSolverSetStartingPoint(CSparseSolverState & state, CRowDouble & x);
    static void SparseSolverSetCond(CSparseSolverState & state, double epsf, int maxits);
    static void SparseSolverSolveSymmetric(CSparseSolverState & state, CSparseMatrix & a, bool IsUpper, CRowDouble & b);
    static void SparseSolverSolve(CSparseSolverState & state, CSparseMatrix & a, CRowDouble & b);
    static void SparseSolverResults(CSparseSolverState & state, CRowDouble & x, CSparseSolverReport & rep);
    static void SparseSolverSetXRep(CSparseSolverState & state, bool needxrep);
    static void SparseSolverOOCStart(CSparseSolverState & state, CRowDouble & b);
    static bool SparseSolverOOCContinue(CSparseSolverState & state);
    static void SparseSolverOOCGetRequestInfo(CSparseSolverState & state, int & requesttype);
    static void SparseSolverOOCGetRequestData(CSparseSolverState & state, CRowDouble & x);
    static void SparseSolverOOCGetRequestData1(CSparseSolverState & state, double & v);
    static void SparseSolverOOCSendResult(CSparseSolverState & state, CRowDouble & ax);
    static void SparseSolverOOCStop(CSparseSolverState & state, CRowDouble & x, CSparseSolverReport & rep);
    static void SparseSolverRequestTermination(CSparseSolverState & state);
    static bool SparseSolverIteration(CSparseSolverState & state);
};

struct CLinCGState {
public:
    int m_itsbeforerestart;
    int m_itsbeforerupdate;
    int m_maxits;
    int m_n;
    int m_prectype;
    int m_repiterationscount;
    int m_repnmv;
    int m_repterminationtype;
    double m_alpha;
    double m_beta;
    double m_epsf;
    double m_meritfunction;
    double m_r2;
    double m_vmv;
    bool m_needmtv;
    bool m_needmv2;
    bool m_needmv;
    bool m_needprec;
    bool m_needvmv;
    bool m_running;
    bool m_xrep;
    bool m_xupdated;
    RCommState m_rstate;
    CRowDouble m_b;
    CRowDouble m_cr;
    CRowDouble m_cx;
    CRowDouble m_cz;
    CRowDouble m_mv;
    CRowDouble m_p;
    CRowDouble m_pv;
    CRowDouble m_r;
    CRowDouble m_rx;
    CRowDouble m_startx;
    CRowDouble m_tmpd;
    CRowDouble m_x;
    CRowDouble m_z;
    CLinCGState(void);
    ~CLinCGState();
    void Copy(const CLinCGState & obj);
};

struct CLinCGReport {
public:
    int m_iterationscount;
    int m_nmv;
    int m_terminationtype;
    double m_r2;
    CLinCGReport(void);
    ~CLinCGReport();
    void Copy(const CLinCGReport & obj);
};

class CLinCG {
public:
    static const double m_defaultprecision;
    static void LinCGCreate(int n, CLinCGState & state);
    static void LinCGSetStartingPoint(CLinCGState & state, CRowDouble & x);
    static void LinCGSetB(CLinCGState & state, CRowDouble & b);
    static void LinCGSetPrecUnit(CLinCGState & state);
    static void LinCGSetPrecDiag(CLinCGState & state);
    static void LinCGSetCond(CLinCGState & state, double epsf, int maxits);
    static bool LinCGIteration(CLinCGState & state);
    static void LinCGSolveSparse(CLinCGState & state, CSparseMatrix & a, bool IsUpper, CRowDouble & b);
    static void LinCGResult(CLinCGState & state, CRowDouble & x, CLinCGReport & rep);
    static void LinCGSetRestartFreq(CLinCGState & state, int srf);
    static void LinCGSetRUpdateFreq(CLinCGState & state, int freq);
    static void LinCGSetXRep(CLinCGState & state, bool needxrep);
    static void LinCGRestart(CLinCGState & state);
};

struct CLinLSQRState {
public:
    int m_m;
    int m_maxits;
    int m_n;
    int m_prectype;
    int m_repiterationscount;
    int m_repnmv;
    int m_repterminationtype;
    double m_alphai;
    double m_alphaip1;
    double m_anorm;
    double m_betai;
    double m_betaip1;
    double m_bnorm2;
    double m_ci;
    double m_dnorm;
    double m_epsa;
    double m_epsb;
    double m_epsc;
    double m_lambdai;
    double m_phibari;
    double m_phibarip1;
    double m_phii;
    double m_r2;
    double m_rhobari;
    double m_rhobarip1;
    double m_rhoi;
    double m_si;
    double m_theta;
    bool m_needmtv;
    bool m_needmv2;
    bool m_needmv;
    bool m_needprec;
    bool m_needvmv;
    bool m_running;
    bool m_userterminationneeded;
    bool m_xrep;
    bool m_xupdated;
    RCommState m_rstate;
    CRowDouble m_b;
    CRowDouble m_d;
    CRowDouble m_mtv;
    CRowDouble m_mv;
    CRowDouble m_omegai;
    CRowDouble m_omegaip1;
    CRowDouble m_rx;
    CRowDouble m_tmpd;
    CRowDouble m_tmpx;
    CRowDouble m_ui;
    CRowDouble m_uip1;
    CRowDouble m_vi;
    CRowDouble m_vip1;
    CRowDouble m_x;
    CNormEstimatorState m_nes;
    CLinLSQRState(void);
    ~CLinLSQRState();
    void Copy(const CLinLSQRState & obj);
};

struct CLinLSQRReport {
public:
    int m_iterationscount;
    int m_nmv;
    int m_terminationtype;
    CLinLSQRReport(void);
    ~CLinLSQRReport();
    void Copy(const CLinLSQRReport & obj);
};

class CLinLSQR {
public:
    static const double m_atol;
    static const double m_btol;
    static void LinLSQRCreate(int m, int n, CLinLSQRState & state);
    static void LinLSQRCreateBuf(int m, int n, CLinLSQRState & state);
    static void LinLSQRSetB(CLinLSQRState & state, CRowDouble & b);
    static void LinLSQRSetPrecUnit(CLinLSQRState & state);
    static void LinLSQRSetPrecDiag(CLinLSQRState & state);
    static void LinLSQRSetLambdaI(CLinLSQRState & state, double lambdai);
    static bool LinLSQRIteration(CLinLSQRState & state);
    static void LinLSQRSolveSparse(CLinLSQRState & state, CSparseMatrix & a, CRowDouble & b);
    static void LinLSQRSetCond(CLinLSQRState & state, double epsa, double epsb, int maxits);
    static void LinLSQRResults(CLinLSQRState & state, CRowDouble & x, CLinLSQRReport & rep);
    static void LinLSQRSetXRep(CLinLSQRState & state, bool needxrep);
    static int LinLSQRPeekIterationsCount(CLinLSQRState & s);
    static void LinLSQRRequestTermination(CLinLSQRState & state);
};

class CGammaFunc {
public:
    static double GammaFunc(double x);
    static double LnGamma(double x, double & sgngam);
};

class CNormalDistr {
public:
    static double ErrorFunction(double x);
    static double ErrorFunctionC(double x);
    static double NormalDistribution(const double x);
    static double NormalPDF(const double x);
    static double NormalCDF(const double x);
    static double InvErF(const double e);
    static double InvNormalDistribution(double y0);
    static double InvNormalCDF(const double y0);
    static double BivariateNormalPDF(const double x, const double y, const double rho);
    static double BivariateNormalCDF(double x, double y, const double rho);
};

class CIncGammaF {
public:
    static double IncompleteGamma(const double a, const double x);
    static double IncompleteGammaC(const double a, const double x);
    static double InvIncompleteGammaC(const double a, const double y0);
};

class CAiryF {
public:
    static void Airy(const double x, double & ai, double & aip, double & bi, double & bip);
};

class CBessel {
public:
    static double BesselJ0(double x);
    static double BesselJ1(double x);
    static double BesselJN(int n, double x);
    static double BesselY0(double x);
    static double BesselY1(double x);
    static double BesselYN(int n, double x);
    static double BesselI0(double x);
    static double BesselI1(double x);
    static double BesselK0(double x);
    static double BesselK1(double x);
    static double BesselKN(int nn, double x);
};

class CBetaF {
public:
    static double Beta(const double a, const double b);
};

class CIncBetaF {
public:
    static double IncompleteBeta(double a, double b, double x);
    static double InvIncompleteBeta(const double a, double b, double y);
};

class CBinomialDistr {
public:
    static double BinomialDistribution(const int k, const int n, const double p);
    static double BinomialComplDistribution(const int k, const int n, const double p);
    static double InvBinomialDistribution(const int k, const int n, const double y);
};

class CChebyshev {
public:
    static double ChebyshevCalculate(const int r, const int n, const double x);
    static double ChebyshevSum(double & c, const int r, const int n, const double x);
    static void ChebyshevCoefficients(const int n, double & c);
    static void FromChebyshev(double & a, const int n, double & b);
};

class CChiSquareDistr {
public:
    static double ChiSquareDistribution(const double v, const double x);
    static double ChiSquareComplDistribution(const double v, const double x);
    static double InvChiSquareDistribution(const double v, const double y);
};

class CDawson {
public:
    static double DawsonIntegral(double x);
};

class CElliptic {
public:
    static double EllipticIntegralK(const double m);
    static double EllipticIntegralKhighPrecision(const double m1);
    static double IncompleteEllipticIntegralK(double phi, const double m);
    static double EllipticIntegralE(double m);
    static double IncompleteEllipticIntegralE(const double phi, const double m);
};

class CExpIntegrals {
public:
    static double ExponentialIntegralEi(const double x);
    static double ExponentialIntegralEn(const double x, const int n);
};

class CFDistr {
public:
    static double FDistribution(const int a, const int b, const double x);
    static double FComplDistribution(const int a, const int b, const double x);
    static double InvFDistribution(const int a, const int b, const double y);
};

class CFresnel {
public:
    static void FresnelIntegral(double x, double & c, double & s);
};

class CHermite {
public:
    static double HermiteCalculate(const int n, const double x);
    static double HermiteSum(double & c, const int n, const double x);
    static void HermiteCoefficients(const int n, double & c);
};

class CJacobianElliptic {
public:
    static void JacobianEllipticFunctions(const double u, const double m, double & sn, double & cn, double & dn, double & ph);
};

class CLaguerre {
public:
    static double LaguerreCalculate(const int n, const double x);
    static double LaguerreSum(double & c, const int n, const double x);
    static void LaguerreCoefficients(const int n, double & c);
};

class CLegendre {
public:
    static double LegendreCalculate(const int n, const double x);
    static double LegendreSum(double & c, const int n, const double x);
    static void LegendreCoefficients(const int n, double & c);
};

class CPoissonDistr {
public:
    static double PoissonDistribution(const int k, const double m);
    static double PoissonComplDistribution(const int k, const double m);
    static double InvPoissonDistribution(const int k, const double y);
};

class CPsiF {
public:
    static double Psi(double x);
};

class CStudenttDistr {
public:
    static double StudenttDistribution(const int k, const double t);
    static double InvStudenttDistribution(const int k, double p);
};

class CTrigIntegrals {
public:
    static void SineCosineIntegrals(double x, double & si, double & ci);
    static void HyperbolicSineCosineIntegrals(double x, double & shi, double & chi);
};

class CBaseStat {
public:
    static bool SampleMoments(const double & cx, const int n, double & mean, double & variance, double & skewness, double & kurtosis);
    static bool SampleMoments(const CRowDouble & cx, const int n, double & mean, double & variance, double & skewness, double & kurtosis);
    static double SampleMean(CRowDouble & x, int n);
    static double SampleVariance(CRowDouble & x, int n);
    static double SampleSkewness(CRowDouble & x, int n);
    static double SampleKurtosis(CRowDouble & x, int n);
    static bool SampleAdev(const double & cx, const int n, double & adev);
    static bool SampleAdev(const CRowDouble & cx, const int n, double & adev);
    static bool SampleMedian(const double & cx, const int n, double & median);
    static bool SampleMedian(const CRowDouble & cx, const int n, double & median);
    static bool SamplePercentile(const double & cx, const int n, const double p, double & v);
    static bool SamplePercentile(const CRowDouble & cx, const int n, const double p, double & v);
    static double Cov2(const double & cx, const double & cy, const int n);
    static double Cov2(const CRowDouble & cx, const CRowDouble & cy, const int n);
    static double PearsonCorr2(const double & cx, const double & cy, const int n);
    static double PearsonCorr2(const CRowDouble & cx, const CRowDouble & cy, const int n);
    static double SpearmanCorr2(const double & cx, const double & cy, const int n);
    static double SpearmanCorr2(const CRowDouble & cx, const CRowDouble & cy, const int n);
    static bool CovM(const CMatrixDouble & cx, const int n, const int m, CMatrixDouble & c);
    static bool PearsonCorrM(const CMatrixDouble & cx, const int n, const int m, CMatrixDouble & c);
    static bool SpearmanCorrM(const CMatrixDouble & cx, const int n, const int m, CMatrixDouble & c);
    static bool CovM2(const CMatrixDouble & cx, const CMatrixDouble & cy, const int n, const int m1, const int m2, CMatrixDouble & c);
    static bool PearsonCorrM2(const CMatrixDouble & cx, const CMatrixDouble & cy, const int n, const int m1, const int m2, CMatrixDouble & c);
    static bool SpearmanCorrM2(const CMatrixDouble & cx, const CMatrixDouble & cy, const int n, const int m1, const int m2, CMatrixDouble & c);
    static void RankData(CMatrixDouble & xy, int npoints, int nfeatures);
    static void RankDataCentered(CMatrixDouble & xy, int npoints, int nfeatures);
    static double PearsonCorrelation(const double & x, const double & y, const int n);
    static double PearsonCorrelation(const CRowDouble & x, const CRowDouble & y, const int n);
    static double SpearmanRankCorrelation(const double & x, const double & y, const int n);
    static double SpearmanRankCorrelation(const CRowDouble & x, const CRowDouble & y, const int n);
};

class CCorrTests {
public:
    static void PearsonCorrSignific(const double r, const int n, double & bothTails, double & leftTail, double & rightTail);
    static void SpearmanRankCorrSignific(const double r, const int n, double & bothTails, double & leftTail, double & rightTail);
};

class CJarqueBera {
public:
    static bool JarqueBeraTest(const double & x, const int n, double & p);
    static bool JarqueBeraTest(const CRowDouble & x, const int n, double & p);
};

class CMannWhitneyU {
public:
    static void CMannWhitneyUTest(const double & x, const int n, const double & y, const int m, double & bothTails, double & leftTail, double & rightTail);
    static void CMannWhitneyUTest(const CRowDouble & x, const int n, const CRowDouble & y, const int m, double & bothTails, double & leftTail, double & rightTail);
};

class CSignTest {
public:
    static void OneSampleSignTest(const double & x, const int n, const double median, double & bothTails, double & leftTail, double & rightTail);
    static void OneSampleSignTest(const CRowDouble & x, const int n, const double median, double & bothTails, double & leftTail, double & rightTail);
};

class CStudentTests {
public:
    static void StudentTest1(const double & x, const int n, const double mean, double & bothTails, double & leftTail, double & rightTail);
    static void StudentTest1(const CRowDouble & x, const int n, const double mean, double & bothTails, double & leftTail, double & rightTail);
    static void StudentTest2(const double & x, const int n, const double & y, const int m, double & bothTails, double & leftTail, double & rightTail);
    static void StudentTest2(const CRowDouble & x, const int n, const CRowDouble & y, const int m, double & bothTails, double & leftTail, double & rightTail);
    static void UnequalVarianceTest(const double & x, const int n, const double & y, const int m, double & bothTails, double & leftTail, double & rightTail);
    static void UnequalVarianceTest(const CRowDouble & x, const int n, const CRowDouble & y, const int m, double & bothTails, double & leftTail, double & rightTail);
};

class CVarianceTests {
public:
    static void FTest(const double & x, const int n, const double & y, const int m, double & bothTails, double & leftTail, double & rightTail);
    static void FTest(const CRowDouble & x, const int n, const CRowDouble & y, const int m, double & bothTails, double & leftTail, double & rightTail);
    static void OneSampleVarianceTest(const double & x, const int n, const double variance, double & bothTails, double & leftTail, double & rightTail);
    static void OneSampleVarianceTest(const CRowDouble& x, const int n, const double variance, double& bothTails, double& leftTail, double& rightTail);
};

class CWilcoxonSignedRank {
public:
    static void WilcoxonSignedRankTest(const double & cx, const int n, const double e, double & bothTails, double & leftTail, double & rightTail);
    static void WilcoxonSignedRankTest(const CRowDouble & cx, const int n, const double e, double & bothTails, double & leftTail, double & rightTail);
};

class CDictionary_Obj_Obj : public CObject {
public:
    CDictionary_Obj_Obj(void);
    ~CDictionary_Obj_Obj();
    void Key(CObject * key);
    void Value(CObject * value);
    void SetAll(CObject * key, CObject * value);
};

class CDictionary_String_Obj : public CObject {
public:
    CDictionary_String_Obj(void);
    ~CDictionary_String_Obj();
    string Key();
    void Key(const string key);
    void Value(CObject * value);
    void SetAll(const string key, CObject * value);
};

class CDictionary_Obj_Double : public CObject {
public:
    CDictionary_Obj_Double(void);
    ~CDictionary_Obj_Double();
    void Key(CObject * key);
    double Value();
    void Value(const double value);
    void SetAll(CObject * key, const double value);
};

class ICondition : public CObject {
public:
    virtual bool IsTypeOf(EnCondition type);
};

class CSingleCondition : public ICondition {
public:
    CSingleCondition(void);
    CSingleCondition(INamedVariable * var, INamedValue * term);
    CSingleCondition(INamedVariable * var, INamedValue * term, bool not);
    ~CSingleCondition();
    void Var(INamedVariable * value);
    bool Not(void);
    void Not(bool not);
    void Term(INamedValue * value);
    virtual bool IsTypeOf(EnCondition type);
};

class CFuzzyCondition : public CSingleCondition {
public:
    CFuzzyCondition(CFuzzyVariable * var, CFuzzyTerm * term, bool not);
    CFuzzyCondition(CFuzzyVariable * var, CFuzzyTerm * term, bool not, HedgeType hedge);
    CFuzzyCondition(CFuzzyVariable * var, CFuzzyTerm * term);
    ~CFuzzyCondition();
    HedgeType Hedge(void);
    void Hedge(HedgeType value);
    virtual bool IsTypeOf(EnCondition type);
};

class CConditions : public ICondition {
public:
    CConditions(void);
    ~CConditions();
    bool Not(void);
    void Not(bool value);
    OperatorType Op(void);
    void Op(OperatorType value);
    virtual bool IsTypeOf(EnCondition type);
};

class IParsableRule : public CObject {
public:
    virtual void Condition(CConditions * value);
    virtual void Conclusion(CSingleCondition * value);
    virtual bool IsTypeOf(EnRule type);
};

class CGenericFuzzyRule : public IParsableRule {
public:
    CGenericFuzzyRule(void);
    ~CGenericFuzzyRule();
    void Condition(CConditions * value);
    virtual void Conclusion(CSingleCondition * value);
    virtual bool IsTypeOf(EnRule type);
};

class CMamdaniFuzzyRule : public CGenericFuzzyRule {
public:
    CMamdaniFuzzyRule(void);
    ~CMamdaniFuzzyRule();
    void Conclusion(CSingleCondition * value);
    double Weight(void);
    void Weight(const double value);
    virtual bool IsTypeOf(EnRule type);
};

class CSugenoFuzzyRule : public CGenericFuzzyRule {
public:
    CSugenoFuzzyRule(void);
    ~CSugenoFuzzyRule();
    void Conclusion(CSingleCondition * value);
    virtual bool IsTypeOf(EnRule type);
};

class INamedValue : public CObject {
public:
    virtual bool IsTypeOf(EnType type);
    virtual string Name(void);
    virtual void Name(const string name);
};

class CNamedValueImpl : public INamedValue {
public:
    virtual bool IsTypeOf(EnType type);
    virtual void Name(const string name);
    virtual string Name(void);
};

class CFuzzyTerm : public CNamedValueImpl {
public:
    CFuzzyTerm(const string name, IMembershipFunction * mf);
    ~CFuzzyTerm();
    virtual bool IsTypeOf(EnType type);
};

class INamedVariable : public INamedValue {
public:
    virtual bool IsTypeOf(EnType type);
};

class CNamedVariableImpl : public INamedVariable {
public:
    virtual bool IsTypeOf(EnType type);
    virtual void Name(const string name);
    virtual string Name(void);
};

class CFuzzyVariable : public CNamedVariableImpl {
public:
    CFuzzyVariable(const string name, const double min, const double max);
    ~CFuzzyVariable();
    virtual bool IsTypeOf(EnType type);
    void Max(const double max);
    double Max(void);
    void Min(const double min);
    double Min(void);
    void Terms(CList * terms);
    void AddTerm(CFuzzyTerm * term);
};

class CGenericFuzzySystem {
public:
    void AndMethod(EnAndMethod value);
    EnAndMethod AndMethod(void) const;
    void OrMethod(EnOrMethod value);
    EnOrMethod OrMethod(void) const;
protected:
    CGenericFuzzySystem(void);
    ~CGenericFuzzySystem();
    double EvaluateCondition(ICondition * condition, CList * fuzzifiedInput);
    double EvaluateConditionPair(const double cond1, const double cond2, OperatorType op);
};

class CNameHelper {
public:
    static bool IsValidName(const string name);
};

class CMamdaniFuzzySystem : public CGenericFuzzySystem {
public:
    CMamdaniFuzzySystem(void);
    ~CMamdaniFuzzySystem();
    ImplicationMethod GetImplicationMethod(void) const;
    void SetImplicationMethod(ImplicationMethod value);
    AggregationMethod GetAggregationMethod(void) const;
    void SetAggregationMethod(AggregationMethod value);
    DefuzzificationMethod GetDefuzzificationMethod(void) const;
    void SetDefuzzificationMethod(DefuzzificationMethod value);
    double Defuzzify(IMembershipFunction * mf, const double min, const double max);
};

class IMembershipFunction : public CObject {
public:
    virtual double GetValue(const double x);
};

class CNormalCombinationMembershipFunction : public IMembershipFunction {
public:
    CNormalCombinationMembershipFunction(void);
    CNormalCombinationMembershipFunction(const double b1, const double sigma1, const double b2, const double sigma2);
    ~CNormalCombinationMembershipFunction();
    void B1(const double b1);
    double B1(void);
    void Sigma1(const double sigma1);
    double Sigma1(void);
    void B2(const double b2);
    double B2(void);
    void Sigma2(const double sigma2);
    double Sigma2(void);
    double GetValue(const double x);
};

class CGeneralizedBellShapedMembershipFunction : public IMembershipFunction {
public:
    CGeneralizedBellShapedMembershipFunction(void);
    CGeneralizedBellShapedMembershipFunction(const double a, const double b, const double c);
    ~CGeneralizedBellShapedMembershipFunction();
    void A(const double a);
    double A(void);
    void B(const double b);
    double B(void);
    void C(const double c);
    double C(void);
    double GetValue(const double x);
};

class CS_ShapedMembershipFunction : public IMembershipFunction {
public:
    CS_ShapedMembershipFunction(void);
    CS_ShapedMembershipFunction(const double a, const double b);
    ~CS_ShapedMembershipFunction();
    void A(const double a);
    double A(void);
    void B(const double b);
    double B(void);
    double GetValue(const double x);
};

class CZ_ShapedMembershipFunction : public IMembershipFunction {
public:
    CZ_ShapedMembershipFunction(void);
    CZ_ShapedMembershipFunction(const double a, const double b);
    ~CZ_ShapedMembershipFunction();
    void A(const double a);
    double A(void);
    void B(const double b);
    double B(void);
    double GetValue(const double x);
};

class CP_ShapedMembershipFunction : public IMembershipFunction {
public:
    CP_ShapedMembershipFunction(void);
    CP_ShapedMembershipFunction(const double a, const double b, const double c, const double d);
    ~CP_ShapedMembershipFunction();
    void A(const double a);
    double A(void);
    void D(const double d);
    double D(void);
    void B(const double b);
    double B(void);
    void C(const double c);
    double C(void);
    double GetValue(const double x);
};

class CSigmoidalMembershipFunction : public IMembershipFunction {
public:
    CSigmoidalMembershipFunction(void);
    CSigmoidalMembershipFunction(const double a, const double c);
    ~CSigmoidalMembershipFunction();
    void A(const double a);
    double A(void);
    void C(const double c);
    double C(void);
    double GetValue(const double x);
};

class CProductTwoSigmoidalMembershipFunctions : public IMembershipFunction {
public:
    CProductTwoSigmoidalMembershipFunctions(void);
    CProductTwoSigmoidalMembershipFunctions(const double a1, const double c1, const double a2, const double c2);
    ~CProductTwoSigmoidalMembershipFunctions();
    void A1(const double a1);
    double A1(void);
    void C1(const double c1);
    double C1(void);
    void A2(const double a2);
    double A2(void);
    void C2(const double c2);
    double C2(void);
    double GetValue(const double x);
};

class CDifferencTwoSigmoidalMembershipFunction : public IMembershipFunction {
public:
    CDifferencTwoSigmoidalMembershipFunction(void);
    CDifferencTwoSigmoidalMembershipFunction(const double a1, const double c1, const double a2, const double c2);
    ~CDifferencTwoSigmoidalMembershipFunction();
    void A1(const double a1);
    double A1(void);
    void C1(const double c1);
    double C1(void);
    void A2(const double a2);
    double A2(void);
    void C2(const double c2);
    double C2(void);
    double GetValue(const double x);
};

class CTrapezoidMembershipFunction : public IMembershipFunction {
public:
    CTrapezoidMembershipFunction(void);
    CTrapezoidMembershipFunction(const double x1, const double x2, const double x3, const double x4);
    ~CTrapezoidMembershipFunction();
    void X1(const double x);
    double X1(void);
    void X2(const double x);
    double X2(void);
    void X3(const double x);
    double X3(void);
    void X4(const double x);
    double X4(void);
    double GetValue(const double x);
};

class CNormalMembershipFunction : public IMembershipFunction {
public:
    CNormalMembershipFunction(void);
    CNormalMembershipFunction(const double b, const double sigma);
    ~CNormalMembershipFunction();
    void B(const double b);
    double B(void);
    void Sigma(const double sigma);
    double Sigma(void);
    double GetValue(const double x);
};

class CTriangularMembershipFunction : public IMembershipFunction {
public:
    CTriangularMembershipFunction(void);
    CTriangularMembershipFunction(const double x1, const double x2, const double x3);
    ~CTriangularMembershipFunction();
    void X1(const double x);
    double X1(void);
    void X2(const double x);
    double X2(void);
    void X3(const double x);
    double X3(void);
    double GetValue(const double x);
};

class CConstantMembershipFunction : public IMembershipFunction {
public:
    CConstantMembershipFunction();
    CConstantMembershipFunction(const double constValue);
    ~CConstantMembershipFunction();
    double GetValue(const double x);
};

class CCompositeMembershipFunction : public IMembershipFunction {
public:
    CCompositeMembershipFunction(MfCompositionType composType);
    CCompositeMembershipFunction(MfCompositionType composType, IMembershipFunction * mf1, IMembershipFunction * mf2);
    CCompositeMembershipFunction(MfCompositionType composType, CList * mfs);
    ~CCompositeMembershipFunction();
    MfCompositionType CompositionType(void);
    void CompositionType(MfCompositionType value);
    double GetValue(double const);
};

class IExpression : public CObject {
public:
    virtual string Text(void);
    virtual bool IsTypeOf(EnLexem type);
};

class CLexem : public IExpression {
public:
    virtual string Text(void);
    virtual bool IsTypeOf(EnLexem type);
};

class CConditionExpression : public IExpression {
public:
    CConditionExpression(CArrayObj * expressions, CFuzzyCondition * condition);
    ~CConditionExpression();
    void Expressions(CArrayObj * value);
    void Condition(CFuzzyCondition * value);
    string Text(void);
    virtual bool IsTypeOf(EnLexem type);
};

class CKeywordLexem : public CLexem {
public:
    CKeywordLexem(const string name);
    ~CKeywordLexem();
    string Text(void);
    virtual bool IsTypeOf(EnLexem type);
};

class CVarLexem : public CLexem {
public:
    CVarLexem(INamedVariable * var, bool in);
    ~CVarLexem();
    void Var(INamedVariable * var);
    string Text(void);
    bool Input(void);
    void Input(bool value);
    virtual bool IsTypeOf(EnLexem type);
};

class IAltLexem : public CLexem {
public:
    virtual void Alternative(IAltLexem * value);
    virtual bool IsTypeOf(EnLexem type);
};

class CTermLexem : public IAltLexem {
public:
    CTermLexem(INamedValue * term, bool in);
    ~CTermLexem();
    void Term(INamedValue * value);
    string Text(void);
    void Alternative(IAltLexem * value);
    virtual bool IsTypeOf(EnLexem type);
};

class CRuleParser : public INamedVariable {
};

class CSugenoFuzzySystem : public CGenericFuzzySystem {
public:
    CSugenoFuzzySystem(void);
    ~CSugenoFuzzySystem();
};

class ISugenoFunction : public CNamedValueImpl {
public:
    virtual bool IsTypeOf(EnType type);
};

class CLinearSugenoFunction : public ISugenoFunction {
public:
    CLinearSugenoFunction(const string name, CList * in);
    CLinearSugenoFunction(const string name, CList * in, CList * coeffs, const double constValue);
    CLinearSugenoFunction(const string name, CList * in, const double  & coeffs);
    ~CLinearSugenoFunction();
    virtual bool IsTypeOf(EnType type);
    double ConstValue();
    void ConstValue(const double value);
    double GetCoefficient(CFuzzyVariable * var);
    void SetCoefficient(CFuzzyVariable * var, const double coeff);
    double Evaluate(CList * inputValues);
};

class CSugenoVariable : public CNamedVariableImpl {
public:
    CSugenoVariable(const string name);
    ~CSugenoVariable();
    virtual bool IsTypeOf(EnType type);
};

class COpenCL {
public:
    COpenCL(void);
    ~COpenCL();
    int GetContext(void) const;
    int GetProgram(void) const;
    int GetKernel(const int kernel_index) const;
    string GetKernelName(const int kernel_index) const;
    bool GetGlobalMemorySize(long & global_memory_size);
    bool GetLocalMemorySize(long & local_memory_size);
    bool GetMaxWorkgroupSize(long & max_workgroup_size);
    bool SupportDouble(void) const;
    bool Initialize(const string program, const bool show_log = true);
    void Shutdown(void);
    bool ContextCreate(const int device = CL_USE_ANY);
    void ContextClean(void);
    bool ProgramCreate(const string program, const bool show_log = true);
    void ProgramDelete(void);
    bool SetBuffersCount(const int total_buffers);
    bool SetKernelsCount(const int total_kernels);
    bool KernelCreate(const int kernel_index, const string kernel_name);
    bool KernelFree(const int kernel_index);
    long GetDeviceInfo(const int prop);
    long GetDeviceInfoInteger(ENUM_OPENCL_PROPERTY_INTEGER prop);
    long GetKernelInfoInteger(const int kernel_index, ENUM_OPENCL_PROPERTY_INTEGER prop);
    bool BufferCreate(const int buffer_index, const uint size_in_bytes, const uint flags);
    bool BufferFree(const int buffer_index);
    bool SetArgumentBuffer(const int kernel_index, const int arg_index, const int buffer_index);
    bool SetArgumentLocalMemory(const int kernel_index, const int arg_index, const int local_memory_size);
    bool Execute(const int kernel_index, const int work_dim, const uint & work_offset, const uint & work_size);
    bool Execute(const int kernel_index, const int work_dim, const uint & work_offset, const uint & work_size, const uint & local_work_size);
    ENUM_OPENCL_EXECUTION_STATUS ExecutionStatus(const int kernel_index);
protected:
    int m_context;
    int m_program;
    string m_kernel_names;
    int m_kernels;
    int m_kernels_total;
    int m_buffers;
    int m_buffers_total;
    string m_device_extensions;
    bool m_support_cl_khr_fp64;
};

class CString : public CObject {
public:
    CString(void);
    ~CString();
    string Str(void) const;
    uint Len(void) const;
    void Copy(string & copy) const;
    void Copy(CString * copy) const;
    bool Fill(const short character);
    void Assign(const string str);
    void Assign(const CString * str);
    void Append(const string str);
    void Append(const CString * str);
    uint Insert(const uint pos, const string substring);
    uint Insert(const uint pos, const CString * substring);
    int Compare(const string str) const;
    int Compare(const CString * str) const;
    int CompareNoCase(const string str) const;
    int CompareNoCase(const CString * str) const;
    string Left(const uint count) const;
    string Right(const uint count) const;
    string Mid(const uint pos, const uint count) const;
    int Trim(const string targets);
    int TrimLeft(const string targets);
    int TrimRight(const string targets);
    bool Clear(void);
    bool ToUpper(void);
    bool ToLower(void);
    void Reverse(void);
    int Find(const uint start, const string substring) const;
    int FindRev(const string substring) const;
    uint Remove(const string substring);
    uint Replace(const string substring, const string newstring);
protected:
    string m_string;
    virtual int Compare(const CObject * node, const int mode = 0) const;
};

class CAccountInfo : public CObject {
public:
    CAccountInfo(void);
    ~CAccountInfo();
    long Login(void) const;
    ENUM_ACCOUNT_TRADE_MODE TradeMode(void) const;
    string TradeModeDescription(void) const;
    long Leverage(void) const;
    ENUM_ACCOUNT_STOPOUT_MODE StopoutMode(void) const;
    string StopoutModeDescription(void) const;
    ENUM_ACCOUNT_MARGIN_MODE MarginMode(void) const;
    string MarginModeDescription(void) const;
    bool TradeAllowed(void) const;
    bool TradeExpert(void) const;
    int LimitOrders(void) const;
    double Balance(void) const;
    double Credit(void) const;
    double Profit(void) const;
    double Equity(void) const;
    double Margin(void) const;
    double FreeMargin(void) const;
    double MarginLevel(void) const;
    double MarginCall(void) const;
    double MarginStopOut(void) const;
    string Name(void) const;
    string Server(void) const;
    string Currency(void) const;
    string Company(void) const;
    long InfoInteger(const ENUM_ACCOUNT_INFO_INTEGER prop_id) const;
    double InfoDouble(const ENUM_ACCOUNT_INFO_DOUBLE prop_id) const;
    string InfoString(const ENUM_ACCOUNT_INFO_STRING prop_id) const;
    double OrderProfitCheck(const string symbol, const ENUM_ORDER_TYPE trade_operation, const double volume, const double price_open, const double price_close) const;
    double MarginCheck(const string symbol, const ENUM_ORDER_TYPE trade_operation, const double volume, const double price) const;
    double FreeMarginCheck(const string symbol, const ENUM_ORDER_TYPE trade_operation, const double volume, const double price) const;
    double MaxLotCheck(const string symbol, const ENUM_ORDER_TYPE trade_operation, const double price, const double percent = 100) const;
};

class CDealInfo : public CObject {
public:
    CDealInfo(void);
    ~CDealInfo();
    void Ticket(const ulong ticket);
    ulong Ticket(void) const;
    long Order(void) const;
    datetime Time(void) const;
    ulong TimeMsc(void) const;
    ENUM_DEAL_TYPE DealType(void) const;
    string TypeDescription(void) const;
    ENUM_DEAL_ENTRY Entry(void) const;
    string EntryDescription(void) const;
    long Magic(void) const;
    long PositionId(void) const;
    double Volume(void) const;
    double Price(void) const;
    double Commission(void) const;
    double Swap(void) const;
    double Profit(void) const;
    string Symbol(void) const;
    string Comment(void) const;
    string ExternalId(void) const;
    bool InfoInteger(ENUM_DEAL_PROPERTY_INTEGER prop_id, long & var) const;
    bool InfoDouble(ENUM_DEAL_PROPERTY_DOUBLE prop_id, double & var) const;
    bool InfoString(ENUM_DEAL_PROPERTY_STRING prop_id, string & var) const;
    string FormatAction(string & str, const uint action) const;
    string FormatEntry(string & str, const uint entry) const;
    string FormatDeal(string & str) const;
    bool SelectByIndex(const int index);
protected:
    ulong m_ticket;
};

class CHistoryOrderInfo : public CObject {
public:
    CHistoryOrderInfo(void);
    ~CHistoryOrderInfo();
    void Ticket(const ulong ticket);
    ulong Ticket(void) const;
    datetime TimeSetup(void) const;
    ulong TimeSetupMsc(void) const;
    datetime TimeDone(void) const;
    ulong TimeDoneMsc(void) const;
    ENUM_ORDER_TYPE OrderType(void) const;
    string TypeDescription(void) const;
    ENUM_ORDER_STATE State(void) const;
    string StateDescription(void) const;
    datetime TimeExpiration(void) const;
    ENUM_ORDER_TYPE_FILLING TypeFilling(void) const;
    string TypeFillingDescription(void) const;
    ENUM_ORDER_TYPE_TIME TypeTime(void) const;
    string TypeTimeDescription(void) const;
    long Magic(void) const;
    long PositionId(void) const;
    long PositionById(void) const;
    double VolumeInitial(void) const;
    double VolumeCurrent(void) const;
    double PriceOpen(void) const;
    double StopLoss(void) const;
    double TakeProfit(void) const;
    double PriceCurrent(void) const;
    double PriceStopLimit(void) const;
    string Symbol(void) const;
    string Comment(void) const;
    string ExternalId(void) const;
    bool InfoInteger(const ENUM_ORDER_PROPERTY_INTEGER prop_id, long & var) const;
    bool InfoDouble(const ENUM_ORDER_PROPERTY_DOUBLE prop_id, double & var) const;
    bool InfoString(const ENUM_ORDER_PROPERTY_STRING prop_id, string & var) const;
    string FormatType(string & str, const uint type) const;
    string FormatStatus(string & str, const uint status) const;
    string FormatTypeFilling(string & str, const uint type) const;
    string FormatTypeTime(string & str, const uint type) const;
    string FormatOrder(string & str) const;
    string FormatPrice(string & str, const double price_order, const double price_trigger, const uint digits) const;
    bool SelectByIndex(const int index);
protected:
    ulong m_ticket;
};

class COrderInfo : public CObject {
public:
    COrderInfo(void);
    ~COrderInfo();
    ulong Ticket(void) const;
    datetime TimeSetup(void) const;
    ulong TimeSetupMsc(void) const;
    datetime TimeDone(void) const;
    ulong TimeDoneMsc(void) const;
    ENUM_ORDER_TYPE OrderType(void) const;
    string TypeDescription(void) const;
    ENUM_ORDER_STATE State(void) const;
    string StateDescription(void) const;
    datetime TimeExpiration(void) const;
    ENUM_ORDER_TYPE_FILLING TypeFilling(void) const;
    string TypeFillingDescription(void) const;
    ENUM_ORDER_TYPE_TIME TypeTime(void) const;
    string TypeTimeDescription(void) const;
    long Magic(void) const;
    long PositionId(void) const;
    long PositionById(void) const;
    double VolumeInitial(void) const;
    double VolumeCurrent(void) const;
    double PriceOpen(void) const;
    double StopLoss(void) const;
    double TakeProfit(void) const;
    double PriceCurrent(void) const;
    double PriceStopLimit(void) const;
    string Symbol(void) const;
    string Comment(void) const;
    string ExternalId(void) const;
    bool InfoInteger(const ENUM_ORDER_PROPERTY_INTEGER prop_id, long & var) const;
    bool InfoDouble(const ENUM_ORDER_PROPERTY_DOUBLE prop_id, double & var) const;
    bool InfoString(const ENUM_ORDER_PROPERTY_STRING prop_id, string & var) const;
    string FormatType(string & str, const uint type) const;
    string FormatStatus(string & str, const uint status) const;
    string FormatTypeFilling(string & str, const uint type) const;
    string FormatTypeTime(string & str, const uint type) const;
    string FormatOrder(string & str) const;
    string FormatPrice(string & str, const double price_order, const double price_trigger, const uint digits) const;
    bool Select(void);
    bool Select(const ulong ticket);
    bool SelectByIndex(const int index);
    void StoreState(void);
    bool CheckState(void);
protected:
    ulong m_ticket;
    ENUM_ORDER_TYPE m_type;
    ENUM_ORDER_STATE m_state;
    datetime m_expiration;
    double m_volume_curr;
    double m_price_open;
    double m_stop_loss;
    double m_take_profit;
};

class CPositionInfo : public CObject {
public:
    CPositionInfo(void);
    ~CPositionInfo();
    ulong Ticket(void) const;
    datetime Time(void) const;
    ulong TimeMsc(void) const;
    datetime TimeUpdate(void) const;
    ulong TimeUpdateMsc(void) const;
    ENUM_POSITION_TYPE PositionType(void) const;
    string TypeDescription(void) const;
    long Magic(void) const;
    long Identifier(void) const;
    double Volume(void) const;
    double PriceOpen(void) const;
    double StopLoss(void) const;
    double TakeProfit(void) const;
    double PriceCurrent(void) const;
    double Commission(void) const;
    double Swap(void) const;
    double Profit(void) const;
    string Symbol(void) const;
    string Comment(void) const;
    bool InfoInteger(const ENUM_POSITION_PROPERTY_INTEGER prop_id, long & var) const;
    bool InfoDouble(const ENUM_POSITION_PROPERTY_DOUBLE prop_id, double & var) const;
    bool InfoString(const ENUM_POSITION_PROPERTY_STRING prop_id, string & var) const;
    string FormatType(string & str, const uint type) const;
    string FormatPosition(string & str) const;
    bool Select(const string symbol);
    bool SelectByMagic(const string symbol, const ulong magic);
    bool SelectByTicket(const ulong ticket);
    bool SelectByIndex(const int index);
    void StoreState(void);
    bool CheckState(void);
protected:
    ENUM_POSITION_TYPE m_type;
    double m_volume;
    double m_price;
    double m_stop_loss;
    double m_take_profit;
};

class CSymbolInfo : public CObject {
public:
    CSymbolInfo(void);
    ~CSymbolInfo();
    string Name(void) const;
    bool Name(const string name);
    bool Refresh(void);
    bool RefreshRates(void);
    bool Select(void) const;
    bool Select(const bool select);
    bool IsSynchronized(void) const;
    ulong Volume(void) const;
    ulong VolumeHigh(void) const;
    ulong VolumeLow(void) const;
    datetime Time(void) const;
    int Spread(void) const;
    bool SpreadFloat(void) const;
    int TicksBookDepth(void) const;
    int StopsLevel(void) const;
    int FreezeLevel(void) const;
    double Bid(void) const;
    double BidHigh(void) const;
    double BidLow(void) const;
    double Ask(void) const;
    double AskHigh(void) const;
    double AskLow(void) const;
    double Last(void) const;
    double LastHigh(void) const;
    double LastLow(void) const;
    int OrderMode(void) const;
    ENUM_SYMBOL_CALC_MODE TradeCalcMode(void) const;
    string TradeCalcModeDescription(void) const;
    ENUM_SYMBOL_TRADE_MODE TradeMode(void) const;
    string TradeModeDescription(void) const;
    ENUM_SYMBOL_TRADE_EXECUTION TradeExecution(void) const;
    string TradeExecutionDescription(void) const;
    ENUM_SYMBOL_SWAP_MODE SwapMode(void) const;
    string SwapModeDescription(void) const;
    ENUM_DAY_OF_WEEK SwapRollover3days(void) const;
    string SwapRollover3daysDescription(void) const;
    datetime StartTime(void) const;
    datetime ExpirationTime(void) const;
    double MarginInitial(void) const;
    double MarginMaintenance(void) const;
    bool MarginHedgedUseLeg(void) const;
    double MarginHedged(void) const;
    double MarginLong(void) const;
    double MarginShort(void) const;
    double MarginLimit(void) const;
    double MarginStop(void) const;
    double MarginStopLimit(void) const;
    int TradeTimeFlags(void) const;
    int TradeFillFlags(void) const;
    int Digits(void) const;
    double Point(void) const;
    double TickValue(void) const;
    double TickValueProfit(void) const;
    double TickValueLoss(void) const;
    double TickSize(void) const;
    double ContractSize(void) const;
    double LotsMin(void) const;
    double LotsMax(void) const;
    double LotsStep(void) const;
    double LotsLimit(void) const;
    double SwapLong(void) const;
    double SwapShort(void) const;
    string CurrencyBase(void) const;
    string CurrencyProfit(void) const;
    string CurrencyMargin(void) const;
    string Bank(void) const;
    string Description(void) const;
    string Path(void) const;
    long SessionDeals(void) const;
    long SessionBuyOrders(void) const;
    long SessionSellOrders(void) const;
    double SessionTurnover(void) const;
    double SessionInterest(void) const;
    double SessionBuyOrdersVolume(void) const;
    double SessionSellOrdersVolume(void) const;
    double SessionOpen(void) const;
    double SessionClose(void) const;
    double SessionAW(void) const;
    double SessionPriceSettlement(void) const;
    double SessionPriceLimitMin(void) const;
    double SessionPriceLimitMax(void) const;
    bool InfoInteger(const ENUM_SYMBOL_INFO_INTEGER prop_id, long& var) const;
    bool InfoDouble(const ENUM_SYMBOL_INFO_DOUBLE prop_id, double& var) const;
    bool InfoString(const ENUM_SYMBOL_INFO_STRING prop_id, string& var) const;
    bool InfoMarginRate(const ENUM_ORDER_TYPE order_type, double& initial_margin_rate, double& maintenance_margin_rate) const;
    double NormalizePrice(const double price) const;
    bool CheckMarketWatch(void);
protected:
    string m_name;
    MqlTick m_tick;
    double m_point;
    double m_tick_value;
    double m_tick_value_profit;
    double m_tick_value_loss;
    double m_tick_size;
    double m_contract_size;
    double m_lots_min;
    double m_lots_max;
    double m_lots_step;
    double m_lots_limit;
    double m_swap_long;
    double m_swap_short;
    int m_digits;
    int m_order_mode;
    ENUM_SYMBOL_TRADE_EXECUTION m_trade_execution;
    ENUM_SYMBOL_CALC_MODE m_trade_calcmode;
    ENUM_SYMBOL_TRADE_MODE m_trade_mode;
    ENUM_SYMBOL_SWAP_MODE m_swap_mode;
    ENUM_DAY_OF_WEEK m_swap3;
    double m_margin_initial;
    double m_margin_maintenance;
    bool m_margin_hedged_use_leg;
    double m_margin_hedged;
    int m_trade_time_flags;
    int m_trade_fill_flags;
};

class CTerminalInfo : public CObject {
public:
    CTerminalInfo(void);
    ~CTerminalInfo();
    int Build(void) const;
    bool IsConnected(void) const;
    bool IsDLLsAllowed(void) const;
    bool IsTradeAllowed(void) const;
    bool IsEmailEnabled(void) const;
    bool IsFtpEnabled(void) const;
    int MaxBars(void) const;
    int CodePage(void) const;
    int CPUCores(void) const;
    int MemoryPhysical(void) const;
    int MemoryTotal(void) const;
    int MemoryAvailable(void) const;
    int MemoryUsed(void) const;
    bool IsX64(void) const;
    int OpenCLSupport(void) const;
    int DiskSpace(void) const;
    string Language(void) const;
    string Name(void) const;
    string Company(void) const;
    string Path(void) const;
    string DataPath(void) const;
    string CommonDataPath(void) const;
    long InfoInteger(const ENUM_TERMINAL_INFO_INTEGER prop_id) const;
    string InfoString(const ENUM_TERMINAL_INFO_STRING prop_id) const;
};

struct BY_HANDLE_FILE_INFORMATION {
public:
    uint dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    uint dwVolumeSerialNumber;
    uint nFileSizeHigh;
    uint nFileSizeLow;
    uint nNumberOfLinks;
    uint nFileIndexHigh;
    uint nFileIndexLow;
};

struct CREATEFILE2_EXTENDED_PARAMETERS {
public:
    uint dwSize;
    uint dwFileAttributes;
    uint dwFileFlags;
    uint dwSecurityQosFlags;
    PVOID lpSecurityAttributes;
    HANDLE hTemplateFile;
};

struct FILE_ATTRIBUTE_DATA {
public:
    uint dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    uint nFileSizeHigh;
    uint nFileSizeLow;
};

struct FIND_STREAM_DATA {
public:
    long StreamSize;
    short cStreamName;
};

struct FIND_DATAW {
public:
    uint dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    uint nFileSizeHigh;
    uint nFileSizeLow;
    uint dwReserved0;
    uint dwReserved1;
    short cFileName;
    short cAlternateFileName;
};

struct ENUMUILANG {
public:
    uint NumOfEnumUILang;
    uint SizeOfEnumUIBuffer;
    PVOID EnumUIBuffer;
};

struct WIN32_MEMORY_RANGE_ENTRY {
public:
    PVOID VirtualAddress;
    ulong NumberOfBytes;
};

struct PROCESS_INFORMATION {
public:
    HANDLE hProcess;
    HANDLE hThread;
    uint dwProcessId;
    uint dwThreadId;
};

struct STARTUPINFOW {
public:
    uint cb;
    string lpReserved;
    string lpDesktop;
    string lpTitle;
    uint dwX;
    uint dwY;
    uint dwXSize;
    uint dwYSize;
    uint dwXCountChars;
    uint dwYCountChars;
    uint dwFillAttribute;
    uint dwFlags;
    ushort wShowWindow;
    ushort cbReserved2;
    PVOID lpReserved2;
    HANDLE hStdInput;
    HANDLE hStdOutput;
    HANDLE hStdError;
};

struct MEMORY_PRIORITY_INFORMATION {
public:
    uint MemoryPriority;
};

struct THREAD_POWER_THROTTLING_STATE {
public:
    uint Version;
    uint ControlMask;
    uint StateMask;
};

struct APP_MEMORY_INFORMATION {
public:
    ulong AvailableCommit;
    ulong PrivateCommitUsage;
    ulong PeakPrivateCommitUsage;
    ulong TotalCommitUsage;
};

struct PROCESS_MEMORY_EXHAUSTION_INFO {
public:
    ushort Version;
    ushort Reserved;
    PROCESS_MEMORY_EXHAUSTION_TYPE Type;
    ulong Value;
};

struct PROCESS_POWER_THROTTLING_STATE {
public:
    uint Version;
    uint ControlMask;
    uint StateMask;
};

struct PROCESS_PROTECTION_LEVEL_INFORMATION {
public:
    uint ProtectionLevel;
};

struct DUMMYSTRUCTNAME {
public:
    uint dwOemId;
    ushort wProcessorArchitecture;
    ushort wReserved;
};

struct MEMORYSTATUSEX {
public:
    uint dwLength;
    uint dwMemoryLoad;
    ulong ullTotalPhys;
    ulong ullAvailPhys;
    ulong ullTotalPageFile;
    ulong ullAvailPageFile;
    ulong ullTotalVirtual;
    ulong ullAvailVirtual;
    ulong ullAvailExtendedVirtual;
};

struct SYSTEM_INFO {
public:
    uint dwOemId;
    uint dwPageSize;
    PVOID lpMinimumApplicationAddress;
    PVOID lpMaximumApplicationAddress;
    ulong dwActiveProcessorMask;
    uint dwNumberOfProcessors;
    uint dwProcessorType;
    uint dwAllocationGranularity;
    ushort wProcessorLevel;
    ushort wProcessorRevision;
};

struct ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA {
public:
    PVOID lpInformation;
    PVOID lpSectionBase;
    uint ulSectionLength;
    PVOID lpSectionGlobalDataBase;
    uint ulSectionGlobalDataLength;
};

struct ACTCTX_SECTION_KEYED_DATA {
public:
    uint cbSize;
    uint ulDataFormatVersion;
    PVOID lpData;
    uint ulLength;
    PVOID lpSectionGlobalData;
    uint ulSectionGlobalDataLength;
    PVOID lpSectionBase;
    uint ulSectionTotalLength;
    HANDLE hActCtx;
    uint ulAssemblyRosterIndex;
    uint ulFlags;
    ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA AssemblyMetadata;
};

struct ACTCTX_SECTION_KEYED_DATA_2600 {
public:
    uint cbSize;
    uint ulDataFormatVersion;
    PVOID lpData;
    uint ulLength;
    PVOID lpSectionGlobalData;
    uint ulSectionGlobalDataLength;
    PVOID lpSectionBase;
    uint ulSectionTotalLength;
    HANDLE hActCtx;
    uint ulAssemblyRosterIndex;
};

struct ACTCTXW {
public:
    uint cbSize;
    uint dwFlags;
    PVOID lpSource;
    ushort wProcessorArchitecture;
    ushort wLangId;
    PVOID lpAssemblyDirectory;
    PVOID lpResourceName;
    PVOID lpApplicationName;
    HANDLE hModule;
};

struct ACTIVATION_CONTEXT_BASIC_INFORMATION {
public:
    HANDLE hActCtx;
    uint dwFlags;
};

struct DCB {
public:
    uint DCBlength;
    uint BaudRate;
    uint Flags;
    ushort wReserved;
    ushort XonLim;
    ushort XoffLim;
    uchar ByteSize;
    uchar Parity;
    uchar StopBits;
    char XonChar;
    char XoffChar;
    char ErrorChar;
    char EofChar;
    char EvtChar;
    ushort wReserved1;
};

struct COMMCONFIG {
public:
    uint dwSize;
    ushort wVersion;
    ushort wReserved;
    DCB dcb;
    uint dwProviderSubType;
    uint dwProviderOffset;
    uint dwProviderSize;
    short wcProviderData;
};

struct COMMPROP {
public:
    ushort wPacketLength;
    ushort wPacketVersion;
    uint dwServiceMask;
    uint dwReserved1;
    uint dwMaxTxQueue;
    uint dwMaxRxQueue;
    uint dwMaxBaud;
    uint dwProvSubType;
    uint dwProvCapabilities;
    uint dwSettableParams;
    uint dwSettableBaud;
    ushort wSettableData;
    ushort wSettableStopParity;
    uint dwCurrentTxQueue;
    uint dwCurrentRxQueue;
    uint dwProvSpec1;
    uint dwProvSpec2;
    short wcProvChar;
};

struct COMMTIMEOUTS {
public:
    uint ReadIntervalTimeout;
    uint ReadTotalTimeoutMultiplier;
    uint ReadTotalTimeoutConstant;
    uint WriteTotalTimeoutMultiplier;
    uint WriteTotalTimeoutConstant;
};

struct COMSTAT {
public:
    uint cbInQue;
    uint cbOutQue;
};

struct COPYFILE2_EXTENDED_PARAMETERS {
public:
    uint dwSize;
    uint dwCopyFlags;
    PVOID pfCancel;
    PVOID pProgressRoutine;
    PVOID pvCallbackContext;
};

struct EVENTLOG_FULL_INFORMATION {
public:
    uint dwFull;
};

struct FILE_INFO {
};

struct FILE_ALIGNMENT_INFO : public FILE_INFO {
public:
    uint AlignmentRequirement;
};

struct FILE_ALLOCATION_INFO : public FILE_INFO {
public:
    long AllocationSize;
};

struct FILE_ATTRIBUTE_TAG_INFO : public FILE_INFO {
public:
    uint FileAttributes;
    uint ReparseTag;
};

struct FILE_BASIC_INFO : public FILE_INFO {
public:
    long CreationTime;
    long LastAccessTime;
    long LastWriteTime;
    long ChangeTime;
    uint FileAttributes;
};

struct FILE_COMPRESSION_INFO : public FILE_INFO {
public:
    long CompressedFileSize;
    ushort CompressionFormat;
    uchar CompressionUnitShift;
    uchar ChunkShift;
    uchar ClusterShift;
    uchar Reserved;
};

struct FILE_DISPOSITION_INFO : public FILE_INFO {
public:
    uchar DeleteFile;
};

struct FILE_DISPOSITION_INFO_EX : public FILE_INFO {
public:
    uint Flags;
};

struct FILE_END_OF_FILE_INFO : public FILE_INFO {
public:
    long EndOfFile;
};

struct FILE_FULL_DIR_INFO : public FILE_INFO {
public:
    uint NextEntryOffset;
    uint FileIndex;
    long CreationTime;
    long LastAccessTime;
    long LastWriteTime;
    long ChangeTime;
    long EndOfFile;
    long AllocationSize;
    uint FileAttributes;
    uint FileNameLength;
    uint EaSize;
    short FileName;
};

struct FILE_ID_BOTH_DIR_INFO : public FILE_INFO {
public:
    uint NextEntryOffset;
    uint FileIndex;
    long CreationTime;
    long LastAccessTime;
    long LastWriteTime;
    long ChangeTime;
    long EndOfFile;
    long AllocationSize;
    uint FileAttributes;
    uint FileNameLength;
    uint EaSize;
    char ShortNameLength;
    short ShortName;
    long FileId;
    short FileName;
};

struct FILE_ID_EXTD_DIR_INFO : public FILE_INFO {
public:
    uint NextEntryOffset;
    uint FileIndex;
    long CreationTime;
    long LastAccessTime;
    long LastWriteTime;
    long ChangeTime;
    long EndOfFile;
    long AllocationSize;
    uint FileAttributes;
    uint FileNameLength;
    uint EaSize;
    uint ReparsePointTag;
    FILE_ID_128 FileId;
    short FileName;
};

struct FILE_ID_INFO : public FILE_INFO {
public:
    ulong VolumeSerialNumber;
    FILE_ID_128 FileId;
};

struct FILE_IO_PRIORITY_HINT_INFO : public FILE_INFO {
public:
    PRIORITY_HINT PriorityHint;
};

struct FILE_NAME_INFO {
public:
    uint FileNameLength;
    short FileName;
};

struct FILE_STANDARD_INFO : public FILE_INFO {
public:
    long AllocationSize;
    long EndOfFile;
    uint NumberOfLinks;
    uchar DeletePending;
    uchar Directory;
};

struct FILE_STORAGE_INFO : public FILE_INFO {
public:
    uint LogicalBytesPerSector;
    uint PhysicalBytesPerSectorForAtomicity;
    uint PhysicalBytesPerSectorForPerformance;
    uint FileSystemEffectivePhysicalBytesPerSectorForAtomicity;
    uint Flags;
    uint ByteOffsetForSectorAlignment;
    uint ByteOffsetForPartitionAlignment;
};

struct FILE_STREAM_INFO : public FILE_INFO {
public:
    uint NextEntryOffset;
    uint StreamNameLength;
    long StreamSize;
    long StreamAllocationSize;
    short StreamName;
};

struct HW_PROFILE_INFOW {
public:
    uint dwDockInfo;
    short szHwProfileGuid;
    short szHwProfileName;
};

struct JIT_DEBUG_INFO {
public:
    uint dwSize;
    uint dwProcessorArchitecture;
    uint dwThreadID;
    uint dwReserved0;
    ulong lpExceptionAddress;
    ulong lpExceptionRecord;
    ulong lpContextRecord;
};

struct MEMORYSTATUS {
public:
    uint dwLength;
    uint dwMemoryLoad;
    ulong dwTotalPhys;
    ulong dwAvailPhys;
    ulong dwTotalPageFile;
    ulong dwAvailPageFile;
    ulong dwTotalVirtual;
    ulong dwAvailVirtual;
};

struct OFSTRUCT {
public:
    uchar cBytes;
    uchar fFixedDisk;
    ushort nErrCode;
    ushort Reserved1;
    ushort Reserved2;
    char szPathName;
};

struct OPERATION_END_PARAMETERS {
public:
    uint Version;
    uint OperationId;
    uint Flags;
};

struct OPERATION_START_PARAMETERS {
public:
    uint Version;
    uint OperationId;
    uint Flags;
};

struct SYSTEM_POWER_STATUS {
public:
    uchar ACLineStatus;
    uchar BatteryFlag;
    uchar BatteryLifePercent;
    uchar SystemStatusFlag;
    uint BatteryLifeTime;
    uint BatteryFullLifeTime;
};

struct UMS_SCHEDULER_STARTUP_INFO {
public:
    uint UmsVersion;
    PVOID CompletionList;
    PVOID SchedulerProc;
    PVOID SchedulerParam;
};

struct WIN32_STREAM_ID {
public:
    uint dwStreamId;
    uint dwStreamAttributes;
    long Size;
    uint dwStreamNameSize;
};

struct UMS_SYSTEM_THREAD_INFORMATION {
public:
    uint UmsVersion;
    uint ThreadUmsFlags;
};

struct FILE_ID_DESCRIPTOR {
public:
    uint dwSize;
    FILE_ID_TYPE Type;
    long FileId;
};

struct SYSTEMTIME {
public:
    ushort wYear;
    ushort wMonth;
    ushort wDayOfWeek;
    ushort wDay;
    ushort wHour;
    ushort wMinute;
    ushort wSecond;
    ushort wMilliseconds;
};

struct REASON_CONTEXT {
public:
    uint Version;
    uint Flags;
    PVOID Reason;
};

struct OVERLAPPED {
public:
    PVOID Internal;
    PVOID InternalHigh;
    uint Offset;
    uint OffsetHigh;
    HANDLE hEvent;
};

struct LDT_ENTRY {
public:
    ushort LimitLow;
    ushort BaseLow;
    uchar BaseMid;
    uchar Flags1;
    uchar Flags2;
    uchar BaseHi;
};

struct GUID {
public:
    ulong Data1;
    ushort Data2;
    ushort Data3;
    uchar Data4;
};

struct FILETIME {
public:
    uint dwLowDateTime;
    uint dwHighDateTime;
};

struct POINT {
public:
    int x;
    int y;
};

struct POINTL {
public:
    int x;
    int y;
};

struct POINTS {
public:
    short x;
    short y;
};

struct RECT {
public:
    int left;
    int top;
    int right;
    int bottom;
};

struct RECTL {
public:
    int left;
    int top;
    int right;
    int bottom;
};

struct SIZE {
public:
    int cx;
    int cy;
};

struct CLAIM_SECURITY_ATTRIBUTE_V1 {
public:
    PVOID Name;
    ushort ValueType;
    ushort Reserved;
    uint Flags;
    uint ValueCount;
    PVOID Values;
};

struct CLAIM_SECURITY_ATTRIBUTES_INFORMATION {
public:
    ushort Version;
    ushort Reserved;
    uint AttributeCount;
    PVOID Attribute;
};

struct ABC {
public:
    int abcA;
    uint abcB;
    int abcC;
};

struct ABCFLOAT {
public:
    float abcfA;
    float abcfB;
    float abcfC;
};

struct AXISINFOW {
public:
    int axMinValue;
    int axMaxValue;
    short axAxisName;
};

struct AXESLISTW {
public:
    uint axlReserved;
    uint axlNumAxes;
    AXISINFOW axlAxisInfo;
};

struct BITMAP {
public:
    int bmType;
    int bmWidth;
    int bmHeight;
    int bmWidthBytes;
    ushort bmPlanes;
    ushort bmBitsPixel;
    PVOID bmBits;
};

struct BITMAPCOREHEADER {
public:
    uint bcSize;
    ushort bcWidth;
    ushort bcHeight;
    ushort bcPlanes;
    ushort bcBitCount;
};

struct RGBTRIPLE {
public:
    uchar rgbtBlue;
    uchar rgbtGreen;
    uchar rgbtRed;
};

struct BITMAPCOREINFO {
public:
    BITMAPCOREHEADER bmciHeader;
    RGBTRIPLE bmciColors;
};

struct RGBQUAD {
public:
    uchar rgbBlue;
    uchar rgbGreen;
    uchar rgbRed;
    uchar rgbReserved;
};

struct BITMAPINFO {
public:
    BITMAPINFOHEADER bmiHeader;
    RGBQUAD bmiColors;
};

struct CIEXYZ {
public:
    int ciexyzX;
    int ciexyzY;
    int ciexyzZ;
};

struct CIEXYZTRIPLE {
public:
    CIEXYZ ciexyzRed;
    CIEXYZ ciexyzGreen;
    CIEXYZ ciexyzBlue;
};

struct BITMAPV4HEADER {
public:
    uint bV4Size;
    int bV4Width;
    int bV4Height;
    ushort bV4Planes;
    ushort bV4BitCount;
    uint bV4V4Compression;
    uint bV4SizeImage;
    int bV4XPelsPerMeter;
    int bV4YPelsPerMeter;
    uint bV4ClrUsed;
    uint bV4ClrImportant;
    uint bV4RedMask;
    uint bV4GreenMask;
    uint bV4BlueMask;
    uint bV4AlphaMask;
    uint bV4CSType;
    CIEXYZTRIPLE bV4Endpoints;
    uint bV4GammaRed;
    uint bV4GammaGreen;
    uint bV4GammaBlue;
};

struct BITMAPV5HEADER {
public:
    uint bV5Size;
    int bV5Width;
    int bV5Height;
    ushort bV5Planes;
    ushort bV5BitCount;
    uint bV5Compression;
    uint bV5SizeImage;
    int bV5XPelsPerMeter;
    int bV5YPelsPerMeter;
    uint bV5ClrUsed;
    uint bV5ClrImportant;
    uint bV5RedMask;
    uint bV5GreenMask;
    uint bV5BlueMask;
    uint bV5AlphaMask;
    uint bV5CSType;
    CIEXYZTRIPLE bV5Endpoints;
    uint bV5GammaRed;
    uint bV5GammaGreen;
    uint bV5GammaBlue;
    uint bV5Intent;
    uint bV5ProfileData;
    uint bV5ProfileSize;
    uint bV5Reserved;
};

struct BLENDFUNCTION {
public:
    uchar BlendOp;
    uchar BlendFlags;
    uchar SourceConstantAlpha;
    uchar AlphaFormat;
};

struct FONTSIGNATURE {
public:
    uint fsUsb;
    uint fsCsb;
};

struct CHARSETINFO {
public:
    uint ciCharset;
    uint ciACP;
    FONTSIGNATURE fs;
};

struct COLORADJUSTMENT {
public:
    ushort caSize;
    ushort caFlags;
    ushort caIlluminantIndex;
    ushort caRedGamma;
    ushort caGreenGamma;
    ushort caBlueGamma;
    ushort caReferenceBlack;
    ushort caReferenceWhite;
    short caContrast;
    short caBrightness;
    short caColorfulness;
    short caRedGreenTint;
};

struct DESIGNVECTOR {
public:
    uint dvReserved;
    uint dvNumAxes;
    int dvValues;
};

struct DIBSECTION {
public:
    BITMAP dsBm;
    BITMAPINFOHEADER dsBmih;
    uint dsBitfields;
    HANDLE dshSection;
    uint dsOffset;
};

struct DISPLAY_DEVICEA {
public:
    uint cb;
    char DeviceName;
    char DeviceString;
    uint StateFlags;
    char DeviceID;
    char DeviceKey;
};

struct DISPLAY_DEVICEW {
public:
    uint cb;
    short DeviceName;
    short DeviceString;
    uint StateFlags;
    short DeviceID;
    short DeviceKey;
};

struct DISPLAYCONFIG_2DREGION {
public:
    uint cx;
    uint cy;
};

struct DISPLAYCONFIG_DEVICE_INFO_HEADER {
public:
    DISPLAYCONFIG_DEVICE_INFO_TYPE type;
    uint size;
    LUID adapterId;
    uint id;
};

struct DISPLAYCONFIG_ADAPTER_NAME {
public:
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    short adapterDevicePath;
};

struct DISPLAYCONFIG_DESKTOP_IMAGE_INFO {
public:
    POINTL PathSourceSize;
    RECTL DesktopImageRegion;
    RECTL DesktopImageClip;
};

struct DISPLAYCONFIG_PATH_SOURCE_INFO {
public:
    LUID adapterId;
    uint id;
    uint modeInfoIdx;
    uint statusFlags;
};

struct DISPLAYCONFIG_RATIONAL {
public:
    uint Numerator;
    uint Denominator;
};

struct DISPLAYCONFIG_PATH_TARGET_INFO {
public:
    LUID adapterId;
    uint id;
    uint modeInfoIdx;
    DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY outputTechnology;
    DISPLAYCONFIG_ROTATION rotation;
    DISPLAYCONFIG_SCALING scaling;
    DISPLAYCONFIG_RATIONAL refreshRate;
    DISPLAYCONFIG_SCANLINE_ORDERING scanLineOrdering;
    int targetAvailable;
    uint statusFlags;
};

struct DISPLAYCONFIG_PATH_INFO {
public:
    DISPLAYCONFIG_PATH_SOURCE_INFO sourceInfo;
    DISPLAYCONFIG_PATH_TARGET_INFO targetInfo;
    uint flags;
};

struct DISPLAYCONFIG_SDR_WHITE_LEVEL {
public:
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    uint SDRWhiteLevel;
};

struct DISPLAYCONFIG_SOURCE_DEVICE_NAME {
public:
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    short viewGdiDeviceName;
};

struct DISPLAYCONFIG_SOURCE_MODE {
public:
    uint width;
    uint height;
    DISPLAYCONFIG_PIXELFORMAT pixelFormat;
    POINTL position;
};

struct DISPLAYCONFIG_TARGET_BASE_TYPE {
public:
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY baseOutputTechnology;
};

struct DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS {
public:
    uint value;
};

struct DISPLAYCONFIG_TARGET_DEVICE_NAME {
public:
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS flags;
    DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY outputTechnology;
    ushort edidManufactureId;
    ushort edidProductCodeId;
    uint connectorInstance;
    short monitorFriendlyDeviceName;
    short monitorDevicePath;
};

struct DISPLAYCONFIG_VIDEO_SIGNAL_INFO {
public:
    ulong pixelRate;
    DISPLAYCONFIG_RATIONAL hSyncFreq;
    DISPLAYCONFIG_RATIONAL vSyncFreq;
    DISPLAYCONFIG_2DREGION activeSize;
    DISPLAYCONFIG_2DREGION totalSize;
    uint videoStandard;
    DISPLAYCONFIG_SCANLINE_ORDERING scanLineOrdering;
};

struct DISPLAYCONFIG_TARGET_MODE {
public:
    DISPLAYCONFIG_VIDEO_SIGNAL_INFO targetVideoSignalInfo;
};

struct DISPLAYCONFIG_TARGET_PREFERRED_MODE {
public:
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    uint width;
    uint height;
    DISPLAYCONFIG_TARGET_MODE targetMode;
};

struct DOCINFOW {
public:
    int cbSize;
    const string lpszDocName;
    const string lpszOutput;
    const string lpszDatatype;
    uint fwType;
};

struct DRAWPATRECT {
public:
    POINT ptPosition;
    POINT ptSize;
    ushort wStyle;
    ushort wPattern;
};

struct EMR {
public:
    uint iType;
    uint nSize;
};

struct EMRABORTPATH {
public:
    EMR emr;
};

struct XFORM {
public:
    float eM11;
    float eM12;
    float eM21;
    float eM22;
    float eDx;
    float eDy;
};

struct EMRALPHABLEND {
public:
    EMR emr;
    RECTL rclBounds;
    int xDest;
    int yDest;
    int cxDest;
    int cyDest;
    uint dwRop;
    int xSrc;
    int ySrc;
    XFORM xformSrc;
    uint crBkColorSrc;
    uint iUsageSrc;
    uint offBmiSrc;
    uint cbBmiSrc;
    uint offBitsSrc;
    uint cbBitsSrc;
    int cxSrc;
    int cySrc;
};

struct EMRANGLEARC {
public:
    EMR emr;
    POINTL ptlCenter;
    uint nRadius;
    float eStartAngle;
    float eSweepAngle;
};

struct EMRARC {
public:
    EMR emr;
    RECTL rclBox;
    POINTL ptlStart;
    POINTL ptlEnd;
};

struct EMRBITBLT {
public:
    EMR emr;
    RECTL rclBounds;
    int xDest;
    int yDest;
    int cxDest;
    int cyDest;
    uint dwRop;
    int xSrc;
    int ySrc;
    XFORM xformSrc;
    uint crBkColorSrc;
    uint iUsageSrc;
    uint offBmiSrc;
    uint cbBmiSrc;
    uint offBitsSrc;
    uint cbBitsSrc;
};

struct EMRCOLORCORRECTPALETTE {
public:
    EMR emr;
    uint ihPalette;
    uint nFirstEntry;
    uint nPalEntries;
    uint nReserved;
};

struct EMRCOLORMATCHTOTARGET {
public:
    EMR emr;
    uint dwAction;
    uint dwFlags;
    uint cbName;
    uint cbData;
    uchar Data;
};

struct LOGBRUSH {
public:
    uint lbStyle;
    uint lbColor;
    ulong lbHatch;
};

struct EMRCREATEBRUSHINDIRECT {
public:
    EMR emr;
    uint ihBrush;
    LOGBRUSH lb;
};

struct LOGCOLORSPACEW {
public:
    uint lcsSignature;
    uint lcsVersion;
    uint lcsSize;
    int lcsCSType;
    int lcsIntent;
    CIEXYZTRIPLE lcsEndpoints;
    uint lcsGammaRed;
    uint lcsGammaGreen;
    uint lcsGammaBlue;
    short lcsFilename;
};

struct EMRCREATECOLORSPACEW {
public:
    EMR emr;
    uint ihCS;
    LOGCOLORSPACEW lcs;
    uint dwFlags;
    uint cbData;
    uchar Data;
};

struct EMRCREATEDIBPATTERNBRUSHPT {
public:
    EMR emr;
    uint ihBrush;
    uint iUsage;
    uint offBmi;
    uint cbBmi;
    uint offBits;
    uint cbBits;
};

struct EMRCREATEMONOBRUSH {
public:
    EMR emr;
    uint ihBrush;
    uint iUsage;
    uint offBmi;
    uint cbBmi;
    uint offBits;
    uint cbBits;
};

struct LOGPALETTE {
public:
    ushort palVersion;
    ushort palNumEntries;
};

struct LOGPEN {
public:
    uint lopnStyle;
    POINT lopnWidth;
    uint lopnColor;
};

struct EMRCREATEPALETTE {
public:
    EMR emr;
    uint ihPal;
    LOGPALETTE lgpl;
};

struct EMRCREATEPEN {
public:
    EMR emr;
    uint ihPen;
    LOGPEN lopn;
};

struct EMRELLIPSE {
public:
    EMR emr;
    RECTL rclBox;
};

struct EMREOF {
public:
    EMR emr;
    uint nPalEntries;
    uint offPalEntries;
    uint nSizeLast;
};

struct EMREXCLUDECLIPRECT {
public:
    EMR emr;
    RECTL rclClip;
};

struct LOGFONTW {
public:
    int lfHeight;
    int lfWidth;
    int lfEscapement;
    int lfOrientation;
    int lfWeight;
    uchar lfItalic;
    uchar lfUnderline;
    uchar lfStrikeOut;
    uchar lfCharSet;
    uchar lfOutPrecision;
    uchar lfClipPrecision;
    uchar lfQuality;
    uchar lfPitchAndFamily;
    short lfFaceName;
};

struct PANOSE {
public:
    uchar bFamilyType;
    uchar bSerifStyle;
    uchar bWeight;
    uchar bProportion;
    uchar bContrast;
    uchar bStrokeVariation;
    uchar bArmStyle;
    uchar bLetterform;
    uchar bMidline;
    uchar bXHeight;
};

struct EXTLOGFONTW {
public:
    LOGFONTW elfLogFont;
    short elfFullName;
    short elfStyle;
    uint elfVersion;
    uint elfStyleSize;
    uint elfMatch;
    uint elfReserved;
    uchar elfVendorId;
    uint elfCulture;
    PANOSE elfPanose;
};

struct EMREXTCREATEFONTINDIRECTW {
public:
    EMR emr;
    uint ihFont;
    EXTLOGFONTW elfw;
};

struct EXTLOGPEN {
public:
    uint elpPenStyle;
    uint elpWidth;
    uint elpBrushStyle;
    uint elpColor;
    ulong elpHatch;
    uint elpNumEntries;
    uint elpStyleEntry;
};

struct EMREXTCREATEPEN {
public:
    EMR emr;
    uint ihPen;
    uint offBmi;
    uint cbBmi;
    uint offBits;
    uint cbBits;
    EXTLOGPEN elp;
};

struct EMREXTESCAPE {
public:
    EMR emr;
    int iEscape;
    int cbEscData;
    uchar EscData;
};

struct EMREXTFLOODFILL {
public:
    EMR emr;
    POINTL ptlStart;
    uint crColor;
    uint iMode;
};

struct EMREXTSELECTCLIPRGN {
public:
    EMR emr;
    uint cbRgnData;
    uint iMode;
    uchar RgnData;
};

struct EMRTEXT {
public:
    POINTL ptlReference;
    uint nChars;
    uint offString;
    uint fOptions;
    RECTL rcl;
    uint offDx;
};

struct EMREXTTEXTOUTA {
public:
    EMR emr;
    RECTL rclBounds;
    uint iGraphicsMode;
    float exScale;
    float eyScale;
    EMRTEXT emrtext;
};

struct EMRFILLPATH {
public:
    EMR emr;
    RECTL rclBounds;
};

struct EMRFILLRGN {
public:
    EMR emr;
    RECTL rclBounds;
    uint cbRgnData;
    uint ihBrush;
    uchar RgnData;
};

struct EMRFORMAT {
public:
    uint dSignature;
    uint nVersion;
    uint cbData;
    uint offData;
};

struct EMRFRAMERGN {
public:
    EMR emr;
    RECTL rclBounds;
    uint cbRgnData;
    uint ihBrush;
    SIZE szlStroke;
    uchar RgnData;
};

struct EMRGDICOMMENT {
public:
    EMR emr;
    uint cbData;
    uchar Data;
};

struct EMRGLSBOUNDEDRECORD {
public:
    EMR emr;
    RECTL rclBounds;
    uint cbData;
    uchar Data;
};

struct EMRGLSRECORD {
public:
    EMR emr;
    uint cbData;
    uchar Data;
};

struct PIXELFORMATDESCRIPTOR {
public:
    ushort nSize;
    ushort nVersion;
    uint dwFlags;
    uchar iPixelType;
    uchar cColorBits;
    uchar cRedBits;
    uchar cRedShift;
    uchar cGreenBits;
    uchar cGreenShift;
    uchar cBlueBits;
    uchar cBlueShift;
    uchar cAlphaBits;
    uchar cAlphaShift;
    uchar cAccumBits;
    uchar cAccumRedBits;
    uchar cAccumGreenBits;
    uchar cAccumBlueBits;
    uchar cAccumAlphaBits;
    uchar cDepthBits;
    uchar cStencilBits;
    uchar cAuxBuffers;
    uchar iLayerType;
    uchar bReserved;
    uint dwLayerMask;
    uint dwVisibleMask;
    uint dwDamageMask;
};

struct TRIVERTEX {
public:
    int x;
    int y;
    ushort red;
    ushort green;
    ushort blue;
    ushort alpha;
};

struct EMRGRADIENTFILL {
public:
    EMR emr;
    RECTL rclBounds;
    uint nVer;
    uint nTri;
    uint ulMode;
    TRIVERTEX Ver;
};

struct EMRINVERTRGN {
public:
    EMR emr;
    RECTL rclBounds;
    uint cbRgnData;
    uchar RgnData;
};

struct EMRLINETO {
public:
    EMR emr;
    POINTL ptl;
};

struct EMRMASKBLT {
public:
    EMR emr;
    RECTL rclBounds;
    int xDest;
    int yDest;
    int cxDest;
    int cyDest;
    uint dwRop;
    int xSrc;
    int ySrc;
    XFORM xformSrc;
    uint crBkColorSrc;
    uint iUsageSrc;
    uint offBmiSrc;
    uint cbBmiSrc;
    uint offBitsSrc;
    uint cbBitsSrc;
    int xMask;
    int yMask;
    uint iUsageMask;
    uint offBmiMask;
    uint cbBmiMask;
    uint offBitsMask;
    uint cbBitsMask;
};

struct EMRMODIFYWORLDTRANSFORM {
public:
    EMR emr;
    XFORM xform;
    uint iMode;
};

struct EMRNAMEDESCAPE {
public:
    EMR emr;
    int iEscape;
    int cbDriver;
    int cbEscData;
    uchar EscData;
};

struct EMROFFSETCLIPRGN {
public:
    EMR emr;
    POINTL ptlOffset;
};

struct EMRPIXELFORMAT {
public:
    EMR emr;
    PIXELFORMATDESCRIPTOR pfd;
};

struct EMRPLGBLT {
public:
    EMR emr;
    RECTL rclBounds;
    POINTL aptlDest;
    int xSrc;
    int ySrc;
    int cxSrc;
    int cySrc;
    XFORM xformSrc;
    uint crBkColorSrc;
    uint iUsageSrc;
    uint offBmiSrc;
    uint cbBmiSrc;
    uint offBitsSrc;
    uint cbBitsSrc;
    int xMask;
    int yMask;
    uint iUsageMask;
    uint offBmiMask;
    uint cbBmiMask;
    uint offBitsMask;
    uint cbBitsMask;
};

struct EMRPOLYDRAW {
public:
    EMR emr;
    RECTL rclBounds;
    uint cptl;
    POINTL aptl;
    uchar abTypes;
};

struct EMRPOLYDRAW16 {
public:
    EMR emr;
    RECTL rclBounds;
    uint cpts;
    POINTS apts;
    uchar abTypes;
};

struct EMRPOLYLINE {
public:
    EMR emr;
    RECTL rclBounds;
    uint cptl;
    POINTL aptl;
};

struct EMRPOLYLINE16 {
public:
    EMR emr;
    RECTL rclBounds;
    uint cpts;
    POINTS apts;
};

struct EMRPOLYPOLYLINE {
public:
    EMR emr;
    RECTL rclBounds;
    uint nPolys;
    uint cptl;
    uint aPolyCounts;
    POINTL aptl;
};

struct EMRPOLYPOLYLINE16 {
public:
    EMR emr;
    RECTL rclBounds;
    uint nPolys;
    uint cpts;
    uint aPolyCounts;
    POINTS apts;
};

struct EMRPOLYTEXTOUTW {
public:
    EMR emr;
    RECTL rclBounds;
    uint iGraphicsMode;
    float exScale;
    float eyScale;
    int cStrings;
    EMRTEXT aemrtext;
};

struct EMRRESIZEPALETTE {
public:
    EMR emr;
    uint ihPal;
    uint cEntries;
};

struct EMRRESTOREDC {
public:
    EMR emr;
    int iRelative;
};

struct EMRROUNDRECT {
public:
    EMR emr;
    RECTL rclBox;
    SIZE szlCorner;
};

struct EMRSCALEVIEWPORTEXTEX {
public:
    EMR emr;
    int xNum;
    int xDenom;
    int yNum;
    int yDenom;
};

struct EMRSELECTCLIPPATH {
public:
    EMR emr;
    uint iMode;
};

struct EMRSELECTOBJECT {
public:
    EMR emr;
    uint ihObject;
};

struct EMRSELECTPALETTE {
public:
    EMR emr;
    uint ihPal;
};

struct EMRSETARCDIRECTION {
public:
    EMR emr;
    uint iArcDirection;
};

struct EMRSETBKCOLOR {
public:
    EMR emr;
    uint crColor;
};

struct EMRSETCOLORADJUSTMENT {
public:
    EMR emr;
    COLORADJUSTMENT ColorAdjustment;
};

struct EMRSETCOLORSPACE {
public:
    EMR emr;
    uint ihCS;
};

struct EMRSETDIBITSTODEVICE {
public:
    EMR emr;
    RECTL rclBounds;
    int xDest;
    int yDest;
    int xSrc;
    int ySrc;
    int cxSrc;
    int cySrc;
    uint offBmiSrc;
    uint cbBmiSrc;
    uint offBitsSrc;
    uint cbBitsSrc;
    uint iUsageSrc;
    uint iStartScan;
    uint cScans;
};

struct EMRSETICMPROFILE {
public:
    EMR emr;
    uint dwFlags;
    uint cbName;
    uint cbData;
    uchar Data;
};

struct EMRSETMAPPERFLAGS {
public:
    EMR emr;
    uint dwFlags;
};

struct EMRSETMITERLIMIT {
public:
    EMR emr;
    float eMiterLimit;
};

struct PALETTEENTRY {
public:
    uchar red;
    uchar green;
    uchar blue;
    uchar flags;
};

struct EMRSETPALETTEENTRIES {
public:
    EMR emr;
    uint ihPal;
    uint iStart;
    uint cEntries;
    PALETTEENTRY aPalEntries;
};

struct EMRSETPIXELV {
public:
    EMR emr;
    POINTL ptlPixel;
    uint crColor;
};

struct EMRSETVIEWPORTEXTEX {
public:
    EMR emr;
    SIZE szlExtent;
};

struct EMRSETVIEWPORTORGEX {
public:
    EMR emr;
    POINTL ptlOrigin;
};

struct EMRSETWORLDTRANSFORM {
public:
    EMR emr;
    XFORM xform;
};

struct EMRSTRETCHBLT {
public:
    EMR emr;
    RECTL rclBounds;
    int xDest;
    int yDest;
    int cxDest;
    int cyDest;
    uint dwRop;
    int xSrc;
    int ySrc;
    XFORM xformSrc;
    uint crBkColorSrc;
    uint iUsageSrc;
    uint offBmiSrc;
    uint cbBmiSrc;
    uint offBitsSrc;
    uint cbBitsSrc;
    int cxSrc;
    int cySrc;
};

struct EMRSTRETCHDIBITS {
public:
    EMR emr;
    RECTL rclBounds;
    int xDest;
    int yDest;
    int xSrc;
    int ySrc;
    int cxSrc;
    int cySrc;
    uint offBmiSrc;
    uint cbBmiSrc;
    uint offBitsSrc;
    uint cbBitsSrc;
    uint iUsageSrc;
    uint dwRop;
    int cxDest;
    int cyDest;
};

struct EMRTRANSPARENTBLT {
public:
    EMR emr;
    RECTL rclBounds;
    int xDest;
    int yDest;
    int cxDest;
    int cyDest;
    uint dwRop;
    int xSrc;
    int ySrc;
    XFORM xformSrc;
    uint crBkColorSrc;
    uint iUsageSrc;
    uint offBmiSrc;
    uint cbBmiSrc;
    uint offBitsSrc;
    uint cbBitsSrc;
    int cxSrc;
    int cySrc;
};

struct ENHMETAHEADER {
public:
    uint iType;
    uint nSize;
    RECTL rclBounds;
    RECTL rclFrame;
    uint dSignature;
    uint nVersion;
    uint nBytes;
    uint nRecords;
    ushort nHandles;
    ushort sReserved;
    uint nDescription;
    uint offDescription;
    uint nPalEntries;
    SIZE szlDevice;
    SIZE szlMillimeters;
    uint cbPixelFormat;
    uint offPixelFormat;
    uint bOpenGL;
    SIZE szlMicrometers;
};

struct ENHMETARECORD {
public:
    uint iType;
    uint nSize;
    uint dParm;
};

struct ENUMLOGFONTEXW {
public:
    LOGFONTW elfLogFont;
    short elfFullName;
    short elfStyle;
    short elfScript;
};

struct ENUMLOGFONTEXDVW {
public:
    ENUMLOGFONTEXW elfEnumLogfontEx;
    DESIGNVECTOR elfDesignVector;
};

struct ENUMLOGFONTW {
public:
    LOGFONTW elfLogFont;
    short elfFullName;
    short elfStyle;
};

struct NEWTEXTMETRICW {
public:
    int tmHeight;
    int tmAscent;
    int tmDescent;
    int tmInternalLeading;
    int tmExternalLeading;
    int tmAveCharWidth;
    int tmMaxCharWidth;
    int tmWeight;
    int tmOverhang;
    int tmDigitizedAspectX;
    int tmDigitizedAspectY;
    short tmFirstChar;
    short tmLastChar;
    short tmDefaultChar;
    short tmBreakChar;
    uchar tmItalic;
    uchar tmUnderlined;
    uchar tmStruckOut;
    uchar tmPitchAndFamily;
    uchar tmCharSet;
    uint ntmFlags;
    uint ntmSizeEM;
    uint ntmCellHeight;
    uint ntmAvgWidth;
};

struct NEWTEXTMETRICEXW {
public:
    NEWTEXTMETRICW ntmTm;
    FONTSIGNATURE ntmFontSig;
};

struct ENUMTEXTMETRICW {
public:
    NEWTEXTMETRICEXW etmNewTextMetricEx;
    AXESLISTW etmAxesList;
};

struct FIXED {
public:
    ushort fract;
    short value;
};

struct POINTFLOAT {
public:
    float x;
    float y;
};

struct GCP_RESULTSW {
public:
    uint lStructSize;
    string lpOutString;
    PVOID lpOrder;
    PVOID lpDx;
    PVOID lpCaretPos;
    PVOID lpClass;
    PVOID lpGlyphs;
    uint nGlyphs;
    int nMaxFit;
};

struct GLYPHMETRICS {
public:
    uint gmBlackBoxX;
    uint gmBlackBoxY;
    POINT gmptGlyphOrigin;
    short gmCellIncX;
    short gmCellIncY;
};

struct GLYPHMETRICSFLOAT {
public:
    float gmfBlackBoxX;
    float gmfBlackBoxY;
    POINTFLOAT gmfptGlyphOrigin;
    float gmfCellIncX;
    float gmfCellIncY;
};

struct WCRANGE {
public:
    short wcLow;
    ushort cGlyphs;
};

struct GLYPHSET {
public:
    uint cbThis;
    uint flAccel;
    uint cGlyphsSupported;
    uint cRanges;
    WCRANGE ranges;
};

struct GRADIENT_RECT {
public:
    uint UpperLeft;
    uint LowerRight;
};

struct GRADIENT_TRIANGLE {
public:
    uint Vertex1;
    uint Vertex2;
    uint Vertex3;
};

struct HANDLETABLE {
public:
    PVOID objectHandle;
};

struct KERNINGPAIR {
public:
    ushort wFirst;
    ushort wSecond;
    int iKernAmount;
};

struct LAYERPLANEDESCRIPTOR {
public:
    ushort nSize;
    ushort nVersion;
    uint dwFlags;
    uchar iPixelType;
    uchar cColorBits;
    uchar cRedBits;
    uchar cRedShift;
    uchar cGreenBits;
    uchar cGreenShift;
    uchar cBlueBits;
    uchar cBlueShift;
    uchar cAlphaBits;
    uchar cAlphaShift;
    uchar cAccumBits;
    uchar cAccumRedBits;
    uchar cAccumGreenBits;
    uchar cAccumBlueBits;
    uchar cAccumAlphaBits;
    uchar cDepthBits;
    uchar cStencilBits;
    uchar cAuxBuffers;
    uchar iLayerPlane;
    uchar bReserved;
    uint crTransparent;
};

struct LOCALESIGNATURE {
public:
    uint lsUsb;
    uint lsCsbDefault;
    uint lsCsbSupported;
};

struct MAT2 {
public:
    FIXED eM11;
    FIXED eM12;
    FIXED eM21;
    FIXED eM22;
};

struct METAFILEPICT {
public:
    int mm;
    int xExt;
    int yExt;
    HANDLE hMF;
};

struct METAHEADER {
public:
    ushort mtType;
    ushort mtHeaderSize;
    ushort mtVersion;
    uint mtSize;
    ushort mtNoObjects;
    uint mtMaxRecord;
    ushort mtNoParameters;
};

struct METARECORD {
public:
    uint rdSize;
    ushort rdFunction;
    ushort rdParm;
};

struct TEXTMETRICW {
public:
    int tmHeight;
    int tmAscent;
    int tmDescent;
    int tmInternalLeading;
    int tmExternalLeading;
    int tmAveCharWidth;
    int tmMaxCharWidth;
    int tmWeight;
    int tmOverhang;
    int tmDigitizedAspectX;
    int tmDigitizedAspectY;
    short tmFirstChar;
    short tmLastChar;
    short tmDefaultChar;
    short tmBreakChar;
    uchar tmItalic;
    uchar tmUnderlined;
    uchar tmStruckOut;
    uchar tmPitchAndFamily;
    uchar tmCharSet;
};

struct OUTLINETEXTMETRICW {
public:
    uint otmSize;
    TEXTMETRICW otmTextMetrics;
    uchar otmFiller;
    PANOSE otmPanoseNumber;
    uint otmfsSelection;
    uint otmfsType;
    int otmsCharSlopeRise;
    int otmsCharSlopeRun;
    int otmItalicAngle;
    uint otmEMSquare;
    int otmAscent;
    int otmDescent;
    uint otmLineGap;
    uint otmsCapEmHeight;
    uint otmsXHeight;
    RECT otmrcFontBox;
    int otmMacAscent;
    int otmMacDescent;
    uint otmMacLineGap;
    uint otmusMinimumPPEM;
    POINT otmptSubscriptSize;
    POINT otmptSubscriptOffset;
    POINT otmptSuperscriptSize;
    POINT otmptSuperscriptOffset;
    uint otmsStrikeoutSize;
    int otmsStrikeoutPosition;
    int otmsUnderscoreSize;
    int otmsUnderscorePosition;
    PVOID otmpFamilyName;
    PVOID otmpFaceName;
    PVOID otmpStyleName;
    PVOID otmpFullName;
};

struct PELARRAY {
public:
    int paXCount;
    int paYCount;
    int paXExt;
    int paYExt;
    uchar paRGBs;
};

struct POINTFX {
public:
    FIXED x;
    FIXED y;
};

struct POLYTEXTW {
public:
    int x;
    int y;
    uint n;
    const string lpstr;
    uint uiFlags;
    RECT rcl;
    PVOID pdx;
};

struct PSFEATURE_CUSTPAPER {
public:
    int lOrientation;
    int lWidth;
    int lHeight;
    int lWidthOffset;
    int lHeightOffset;
};

struct PSFEATURE_OUTPUT {
public:
    int bPageIndependent;
    int bSetPageDevice;
};

struct PSINJECTDATA {
public:
    uint DataBytes;
    ushort InjectionPoint;
    ushort PageNumber;
};

struct RASTERIZER_STATUS {
public:
    short nSize;
    short wFlags;
    short nLanguageID;
};

struct RGNDATAHEADER {
public:
    uint dwSize;
    uint iType;
    uint nCount;
    uint nRgnSize;
    RECT rcBound;
};

struct RGNDATA {
public:
    RGNDATAHEADER rdh;
    char Buffer;
};

struct TTPOLYCURVE {
public:
    ushort wType;
    ushort cpfx;
    POINTFX apfx;
};

struct TTPOLYGONHEADER {
public:
    uint cb;
    uint dwType;
    POINTFX pfxStart;
};

struct DEVMODEW {
public:
    short dmDeviceName;
    ushort dmSpecVersion;
    ushort dmDriverVersion;
    ushort dmSize;
    ushort dmDriverExtra;
    uint dmFields;
    short dmOrientation;
    short dmPaperSize;
    short dmPaperLength;
    short dmPaperWidth;
    short dmScale;
    short dmCopies;
    short dmDefaultSource;
    short dmPrintQuality;
    short dmColor;
    short dmDuplex;
    short dmYResolution;
    short dmTTOption;
    short dmCollate;
    short dmFormName;
    ushort dmLogPixels;
    uint dmBitsPerPel;
    uint dmPelsWidth;
    uint dmPelsHeight;
    uint dmDisplayFlags;
    uint dmDisplayFrequency;
    uint dmICMMethod;
    uint dmICMIntent;
    uint dmMediaType;
    uint dmDitherType;
    uint dmReserved1;
    uint dmReserved2;
    uint dmPanningWidth;
    uint dmPanningHeight;
};

struct WGLSWAP {
public:
    HANDLE hdc;
    uint uiFlags;
};

struct DISPLAYCONFIG_MODE_INFO {
public:
    DISPLAYCONFIG_MODE_INFO_TYPE infoType;
    uint id;
    LUID adapterId;
    DISPLAYCONFIG_MODE mode;
};

struct PROCESSOR_NUMBER {
public:
    ushort Group;
    uchar Number;
    uchar Reserved;
};

struct GROUP_AFFINITY {
public:
    ulong Mask;
    ushort Group;
    ushort Reserved;
};

struct FLOAT128 {
public:
    long LowPart;
    long HighPart;
};

struct LARGE_INTEGER {
public:
    long QuadPart;
};

struct ULARGE_INTEGER {
public:
    ulong QuadPart;
};

struct LUID {
public:
    uint LowPart;
    int HighPart;
};

struct LIST_ENTRY {
public:
    PVOID Flink;
    PVOID Blink;
};

struct SINGLE_LIST_ENTRY {
public:
    PVOID Next;
};

struct LIST_ENTRY32 {
public:
    uint Flink;
    uint Blink;
};

struct LIST_ENTRY64 {
public:
    ulong Flink;
    ulong Blink;
};

struct OBJECTID {
public:
    GUID Lineage;
    uint Uniquifier;
};

struct M128A {
public:
    ulong Low;
    long High;
};

struct XSAVE_FORMAT {
public:
    ushort Controlushort;
    ushort Statusushort;
    uchar Tagushort;
    uchar Reserved1;
    ushort ErrorOpcode;
    uint ErrorOffset;
    ushort ErrorSelector;
    ushort Reserved2;
    uint DataOffset;
    ushort DataSelector;
    ushort Reserved3;
    uint MxCsr;
    uint MxCsr_Mask;
    M128A FloatRegisters;
    M128A XmmRegisters;
    uchar Reserved4;
};

struct XSAVE_AREA_HEADER {
public:
    ulong Mask;
    ulong CompactionMask;
    ulong Reserved2;
};

struct XSAVE_AREA {
public:
    XSAVE_FORMAT LegacyState;
    XSAVE_AREA_HEADER Header;
};

struct XSTATE_CONTEXT {
public:
    ulong Mask;
    uint Length;
    uint Reserved1;
    PVOID Area;
    uint Reserved2;
    PVOID Buffer;
    uint Reserved3;
};

struct SCOPE_TABLE_AMD64 {
public:
    uint Count;
    uint BeginAddress;
    uint EndAddress;
    uint HandlerAddress;
    uint JumpTarget;
};

struct UNWIND_HISTORY_TABLE_ENTRY {
public:
    ulong ImageBase;
    PVOID FunctionEntry;
};

struct UNWIND_HISTORY_TABLE {
public:
    uint Count;
    uchar LocalHint;
    uchar GlobalHint;
    uchar Search;
    uchar Once;
    ulong LowAddress;
    ulong HighAddress;
    UNWIND_HISTORY_TABLE_ENTRY Entry;
};

struct SCOPE_TABLE_ARM64 {
public:
    uint Count;
    uint BeginAddress;
    uint EndAddress;
    uint HandlerAddress;
    uint JumpTarget;
};

struct NEON128 {
public:
    ulong Low;
    long High;
};

struct DISPATCHER_CONTEXT {
public:
    uint ControlPc;
    uint ImageBase;
    PVOID FunctionEntry;
    uint EstablisherFrame;
    uint TargetPc;
    PVOID ContextRecord;
    PVOID LanguageHandler;
    PVOID HandlerData;
    PVOID HistoryTable;
    uint ScopeIndex;
    uchar ControlPcIsUnwound;
    PVOID NonVolatileRegisters;
    uint Reserved;
};

struct KNONVOLATILE_CONTEXT_POINTERS {
public:
    PVOID FloatingContext;
    PVOID IntegerContext;
};

struct SCOPE_TABLE_ARM {
public:
    uint Count;
    uint BeginAddress;
    uint EndAddress;
    uint HandlerAddress;
    uint JumpTarget;
};

struct DISPATCHER_CONTEXT_ARM64 {
public:
    ulong ControlPc;
    ulong ImageBase;
    PVOID FunctionEntry;
    ulong EstablisherFrame;
    ulong TargetPc;
    PVOID ContextRecord;
    PVOID LanguageHandler;
    PVOID HandlerData;
    PVOID HistoryTable;
    uint ScopeIndex;
    uchar ControlPcIsUnwound;
    PVOID NonVolatileRegisters;
};

struct KNONVOLATILE_CONTEXT_POINTERS_ARM64 {
public:
    PVOID X19;
    PVOID X20;
    PVOID X21;
    PVOID X22;
    PVOID X23;
    PVOID X24;
    PVOID X25;
    PVOID X26;
    PVOID X27;
    PVOID X28;
    PVOID Fp;
    PVOID Lr;
    PVOID D8;
    PVOID D9;
    PVOID D10;
    PVOID D11;
    PVOID D12;
    PVOID D13;
    PVOID D14;
    PVOID D15;
};

struct FLOATING_SAVE_AREA {
public:
    uint Controlushort;
    uint Statusushort;
    uint Tagushort;
    uint ErrorOffset;
    uint ErrorSelector;
    uint DataOffset;
    uint DataSelector;
    uchar RegisterArea;
    uint Spare0;
};

struct CONTEXT {
public:
    ulong P1Home;
    ulong P2Home;
    ulong P3Home;
    ulong P4Home;
    ulong P5Home;
    ulong P6Home;
    uint ContextFlags;
    uint MxCsr;
    ushort SegCs;
    ushort SegDs;
    ushort SegEs;
    ushort SegFs;
    ushort SegGs;
    ushort SegSs;
    uint EFlags;
    ulong Dr0;
    ulong Dr1;
    ulong Dr2;
    ulong Dr3;
    ulong Dr6;
    ulong Dr7;
    ulong Rax;
    ulong Rcx;
    ulong Rdx;
    ulong Rbx;
    ulong Rsp;
    ulong Rbp;
    ulong Rsi;
    ulong Rdi;
    ulong R8;
    ulong R9;
    ulong R10;
    ulong R11;
    ulong R12;
    ulong R13;
    ulong R14;
    ulong R15;
    ulong Rip;
    M128A Header;
    M128A Legacy;
    M128A Xmm0;
    M128A Xmm1;
    M128A Xmm2;
    M128A Xmm3;
    M128A Xmm4;
    M128A Xmm5;
    M128A Xmm6;
    M128A Xmm7;
    M128A Xmm8;
    M128A Xmm9;
    M128A Xmm10;
    M128A Xmm11;
    M128A Xmm12;
    M128A Xmm13;
    M128A Xmm14;
    M128A Xmm15;
    M128A VectorRegister;
    ulong VectorControl;
    ulong DebugControl;
    ulong LastBranchToRip;
    ulong LastBranchFromRip;
    ulong LastExceptionToRip;
    ulong LastExceptionFromRip;
};

struct WOW64_FLOATING_SAVE_AREA {
public:
    uint Controlushort;
    uint Statusushort;
    uint Tagushort;
    uint ErrorOffset;
    uint ErrorSelector;
    uint DataOffset;
    uint DataSelector;
    uchar RegisterArea;
    uint Cr0NpxState;
};

struct WOW64_CONTEXT {
public:
    uint ContextFlags;
    uint Dr0;
    uint Dr1;
    uint Dr2;
    uint Dr3;
    uint Dr6;
    uint Dr7;
    WOW64_FLOATING_SAVE_AREA FloatSave;
    uint SegGs;
    uint SegFs;
    uint SegEs;
    uint SegDs;
    uint Edi;
    uint Esi;
    uint Ebx;
    uint Edx;
    uint Ecx;
    uint Eax;
    uint Ebp;
    uint Eip;
    uint SegCs;
    uint EFlags;
    uint Esp;
    uint SegSs;
    uchar ExtendedRegisters;
};

struct WOW64_LDT_ENTRY {
public:
    uint LimitLow;
    uint BaseLow;
    uchar BaseMid;
    uchar Flags1;
    uchar Flags2;
    uchar BaseHi;
};

struct WOW64_DESCRIPTOR_TABLE_ENTRY {
public:
    uint Selector;
    WOW64_LDT_ENTRY Descriptor;
};

struct EXCEPTION_RECORD {
public:
    uint ExceptionCode;
    uint ExceptionFlags;
    PVOID ExceptionRecord;
    PVOID ExceptionAddress;
    uint NumberParameters;
    PVOID ExceptionInformation;
};

struct EXCEPTION_RECORD32 {
public:
    uint ExceptionCode;
    uint ExceptionFlags;
    uint ExceptionRecord;
    uint ExceptionAddress;
    uint NumberParameters;
    uint ExceptionInformation;
};

struct EXCEPTION_RECORD64 {
public:
    uint ExceptionCode;
    uint ExceptionFlags;
    ulong ExceptionRecord;
    ulong ExceptionAddress;
    uint NumberParameters;
    uint __unusedAlignment;
    ulong ExceptionInformation;
};

struct EXCEPTION_POINTERS {
public:
    PVOID ExceptionRecord;
    PVOID ContextRecord;
};

struct GENERIC_MAPPING {
public:
    uint GenericRead;
    uint GenericWrite;
    uint GenericExecute;
    uint GenericAll;
};

struct LUID_AND_ATTRIBUTES {
public:
    LUID Luid;
    uint Attributes;
};

struct SID_IDENTIFIER_AUTHORITY {
public:
    uchar Value;
};

struct SID {
public:
    uchar Revision;
    uchar SubAuthorityCount;
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
    uint SubAuthority;
};

struct SID_AND_ATTRIBUTES {
public:
    SID Sid;
    uint Attributes;
};

struct SID_AND_ATTRIBUTES_HASH {
public:
    uint SidCount;
    PVOID SidAttr;
    ulong Hash;
};

struct ACL {
public:
    uchar AclRevision;
    uchar Sbz1;
    ushort AclSize;
    ushort AceCount;
    ushort Sbz2;
};

struct ACE_HEADER {
public:
    uchar AceType;
    uchar AceFlags;
    ushort AceSize;
};

struct ACCESS_ALLOWED_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint SidStart;
};

struct ACCESS_DENIED_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint SidStart;
};

struct SYSTEM_AUDIT_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint SidStart;
};

struct SYSTEM_ALARM_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint SidStart;
};

struct SYSTEM_RESOURCE_ATTRIBUTE_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint SidStart;
};

struct SYSTEM_SCOPED_POLICY_ID_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint SidStart;
};

struct SYSTEM_MANDATORY_LABEL_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint SidStart;
};

struct SYSTEM_PROCESS_TRUST_LABEL_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint SidStart;
};

struct SYSTEM_ACCESS_FILTER_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint SidStart;
};

struct ACCESS_ALLOWED_OBJECT_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    uint SidStart;
};

struct ACCESS_DENIED_OBJECT_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    uint SidStart;
};

struct SYSTEM_AUDIT_OBJECT_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    uint SidStart;
};

struct SYSTEM_ALARM_OBJECT_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    uint SidStart;
};

struct ACCESS_ALLOWED_CALLBACK_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint SidStart;
};

struct ACCESS_DENIED_CALLBACK_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint SidStart;
};

struct SYSTEM_AUDIT_CALLBACK_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint SidStart;
};

struct SYSTEM_ALARM_CALLBACK_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint SidStart;
};

struct ACCESS_ALLOWED_CALLBACK_OBJECT_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    uint SidStart;
};

struct ACCESS_DENIED_CALLBACK_OBJECT_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    uint SidStart;
};

struct SYSTEM_AUDIT_CALLBACK_OBJECT_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    uint SidStart;
};

struct SYSTEM_ALARM_CALLBACK_OBJECT_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    uint SidStart;
};

struct ACL_REVISION_INFORMATION {
public:
    uint AclRevision;
};

struct ACL_SIZE_INFORMATION {
public:
    uint AceCount;
    uint AclBytesInUse;
    uint AclBytesFree;
};

struct SECURITY_DESCRIPTOR_RELATIVE {
public:
    uchar Revision;
    uchar Sbz1;
    ushort Control;
    uint Owner;
    uint Group;
    uint Sacl;
    uint Dacl;
};

struct SECURITY_DESCRIPTOR {
public:
    uchar Revision;
    uchar Sbz1;
    ushort Control;
    uchar offset;
    PVOID Owner;
    PVOID Group;
    PVOID Sacl;
    PVOID Dacl;
};

struct SECURITY_OBJECT_AI_PARAMS {
public:
    uint Size;
    uint ConstraintMask;
};

struct OBJECT_TYPE_LIST {
public:
    ushort Level;
    ushort Sbz;
    GUID ObjectType;
};

struct PRIVILEGE_SET {
public:
    uint PrivilegeCount;
    uint Control;
    LUID_AND_ATTRIBUTES Privilege;
};

struct ACCESS_REASONS {
public:
    uint Data;
};

struct SE_SECURITY_DESCRIPTOR {
public:
    uint Size;
    uint Flags;
    PVOID SecurityDescriptor;
};

struct SE_ACCESS_REQUEST {
public:
    uint Size;
    PVOID SeSecurityDescriptor;
    uint DesiredAccess;
    uint PreviouslyGrantedAccess;
    PVOID PrincipalSelfSid;
    PVOID GenericMapping;
    uint ObjectTypeListCount;
    PVOID ObjectTypeList;
};

struct SE_ACCESS_REPLY {
public:
    uint Size;
    uint ResultListCount;
    PVOID GrantedAccess;
    uint AccessStatus;
    PVOID AccessReason;
    PVOID Privileges;
};

struct TOKEN_USER {
public:
    SID_AND_ATTRIBUTES User;
};

struct SE_TOKEN_USER {
public:
    TOKEN_USER TokenUser;
    SID Sid;
};

struct TOKEN_GROUPS {
public:
    uint GroupCount;
    SID_AND_ATTRIBUTES Groups;
};

struct TOKEN_PRIVILEGES {
public:
    uint PrivilegeCount;
    LUID_AND_ATTRIBUTES Privileges;
};

struct TOKEN_OWNER {
public:
    PVOID Owner;
};

struct TOKEN_PRIMARY_GROUP {
public:
    PVOID PrimaryGroup;
};

struct TOKEN_DEFAULT_DACL {
public:
    PVOID DefaultDacl;
};

struct TOKEN_USER_CLAIMS {
public:
    PVOID UserClaims;
};

struct TOKEN_DEVICE_CLAIMS {
public:
    PVOID DeviceClaims;
};

struct TOKEN_GROUPS_AND_PRIVILEGES {
public:
    uint SidCount;
    uint SidLength;
    PVOID Sids;
    uint RestrictedSidCount;
    uint RestrictedSidLength;
    PVOID RestrictedSids;
    uint PrivilegeCount;
    uint PrivilegeLength;
    PVOID Privileges;
    LUID AuthenticationId;
};

struct TOKEN_LINKED_TOKEN {
public:
    HANDLE LinkedToken;
};

struct TOKEN_ELEVATION {
public:
    uint TokenIsElevated;
};

struct TOKEN_MANDATORY_LABEL {
public:
    SID_AND_ATTRIBUTES Label;
};

struct TOKEN_MANDATORY_POLICY {
public:
    uint Policy;
};

struct TOKEN_ACCESS_INFORMATION {
public:
    PVOID SidHash;
    PVOID RestrictedSidHash;
    PVOID Privileges;
    LUID AuthenticationId;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    TOKEN_MANDATORY_POLICY MandatoryPolicy;
    uint Flags;
    uint AppContainerNumber;
    PVOID PackageSid;
    PVOID CapabilitiesHash;
    PVOID TrustLevelSid;
    PVOID SecurityAttributes;
};

struct TOKEN_AUDIT_POLICY {
};

struct TOKEN_SOURCE {
public:
    char SourceName;
    LUID SourceIdentifier;
};

struct TOKEN_STATISTICS {
public:
    LUID TokenId;
    LUID AuthenticationId;
    long ExpirationTime;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    uint DynamicCharged;
    uint DynamicAvailable;
    uint GroupCount;
    uint PrivilegeCount;
    LUID ModifiedId;
};

struct TOKEN_CONTROL {
public:
    LUID TokenId;
    LUID AuthenticationId;
    LUID ModifiedId;
    TOKEN_SOURCE TokenSource;
};

struct TOKEN_ORIGIN {
public:
    LUID OriginatingLogonSession;
};

struct TOKEN_APPCONTAINER_INFORMATION {
public:
    PVOID TokenAppContainer;
};

struct TOKEN_SID_INFORMATION {
public:
    PVOID Sid;
};

struct TOKEN_BNO_ISOLATION_INFORMATION {
public:
    string IsolationPrefix;
    uchar IsolationEnabled;
};

struct CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE {
public:
    ulong Version;
    string Name;
};

struct CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {
public:
    PVOID pValue;
    uint ValueLength;
};

struct CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 {
public:
    uint Name;
    ushort ValueType;
    ushort Reserved;
    uint Flags;
    uint ValueCount;
    uint pInt64;
};

struct Attribute {
public:
    ushort Version;
    ushort Reserved;
    uint AttributeCount;
    PVOID pAttributeV1;
};

struct SECURITY_QUALITY_OF_SERVICE {
public:
    uint Length;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    uchar ContextTrackingMode;
    uchar EffectiveOnly;
};

struct SE_IMPERSONATION_STATE {
public:
    PVOID Token;
    uchar CopyOnOpen;
    uchar EffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL Level;
};

struct SECURITY_CAPABILITIES {
public:
    PVOID AppContainerSid;
    PVOID Capabilities;
    uint CapabilityCount;
    uint Reserved;
};

struct JOB_SET_ARRAY {
public:
    HANDLE JobHandle;
    uint MemberLevel;
    uint Flags;
};

struct EXCEPTION_REGISTRATION_RECORD {
public:
    PVOID Next;
    PVOID Handler;
};

struct NT_TIB {
public:
    PVOID ExceptionList;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID SubSystemTib;
    PVOID FiberData;
    PVOID ArbitraryUserPointer;
    PVOID Self;
};

struct UMS_CREATE_THREAD_ATTRIBUTES {
public:
    uint UmsVersion;
    PVOID UmsContext;
    PVOID UmsCompletionList;
};

struct WOW64_ARCHITECTURE_INFORMATION {
public:
    uint Info;
};

struct QUOTA_LIMITS {
public:
    ulong PagedPoolLimit;
    ulong NonPagedPoolLimit;
    ulong MinimumWorkingSetSize;
    ulong MaximumWorkingSetSize;
    ulong PagefileLimit;
    long TimeLimit;
};

struct QUOTA_LIMITS_EX {
public:
    ulong PagedPoolLimit;
    ulong NonPagedPoolLimit;
    ulong MinimumWorkingSetSize;
    ulong MaximumWorkingSetSize;
    ulong PagefileLimit;
    long TimeLimit;
    ulong WorkingSetLimit;
    ulong Reserved2;
    ulong Reserved3;
    ulong Reserved4;
    uint Flags;
    uint CpuRateLimit;
};

struct IO_COUNTERS {
public:
    ulong ReadOperationCount;
    ulong WriteOperationCount;
    ulong OtherOperationCount;
    ulong ReadTransferCount;
    ulong WriteTransferCount;
    ulong OtherTransferCount;
};

struct JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
public:
    long TotalUserTime;
    long TotalKernelTime;
    long ThisPeriodTotalUserTime;
    long ThisPeriodTotalKernelTime;
    uint TotalPageFaultCount;
    uint TotalProcesses;
    uint ActiveProcesses;
    uint TotalTerminatedProcesses;
};

struct JOBOBJECT_BASIC_LIMIT_INFORMATION {
public:
    long PerProcessUserTimeLimit;
    long PerJobUserTimeLimit;
    uint LimitFlags;
    ulong MinimumWorkingSetSize;
    ulong MaximumWorkingSetSize;
    uint ActiveProcessLimit;
    ulong Affinity;
    uint PriorityClass;
    uint SchedulingClass;
};

struct JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
public:
    JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;
    IO_COUNTERS IoInfo;
    ulong ProcessMemoryLimit;
    ulong JobMemoryLimit;
    ulong PeakProcessMemoryUsed;
    ulong PeakJobMemoryUsed;
};

struct JOBOBJECT_BASIC_PROCESS_ID_LIST {
public:
    uint NumberOfAssignedProcesses;
    uint NumberOfProcessIdsInList;
    ulong ProcessIdList;
};

struct JOBOBJECT_BASIC_UI_RESTRICTIONS {
public:
    uint UIRestrictionsClass;
};

struct JOBOBJECT_SECURITY_LIMIT_INFORMATION {
public:
    uint SecurityLimitFlags;
    HANDLE JobToken;
    PVOID SidsToDisable;
    PVOID PrivilegesToDelete;
    PVOID RestrictedSids;
};

struct JOBOBJECT_END_OF_JOB_TIME_INFORMATION {
public:
    uint EndOfJobTimeAction;
};

struct JOBOBJECT_ASSOCIATE_COMPLETION_PORT {
public:
    PVOID CompletionKey;
    HANDLE CompletionPort;
};

struct JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
public:
    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo;
    IO_COUNTERS IoInfo;
};

struct JOBOBJECT_JOBSET_INFORMATION {
public:
    uint MemberLevel;
};

struct JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION {
public:
    ulong IoReadBytesLimit;
    ulong IoWriteBytesLimit;
    long PerJobUserTimeLimit;
    ulong JobMemoryLimit;
    JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
    JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL RateControlToleranceInterval;
    uint LimitFlags;
};

struct JOBOBJECT_LIMIT_VIOLATION_INFORMATION {
public:
    uint LimitFlags;
    uint ViolationLimitFlags;
    ulong IoReadBytes;
    ulong IoReadBytesLimit;
    ulong IoWriteBytes;
    ulong IoWriteBytesLimit;
    long PerJobUserTime;
    long PerJobUserTimeLimit;
    ulong JobMemory;
    ulong JobMemoryLimit;
    JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
    JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlToleranceLimit;
};

struct JOBOBJECT_NET_RATE_CONTROL_INFORMATION {
public:
    ulong MaxBandwidth;
    JOB_OBJECT_NET_RATE_CONTROL_FLAGS ControlFlags;
    uchar DscpTag;
};

struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE {
public:
    long MaxIops;
    long MaxBandwidth;
    long ReservationIops;
    string VolumeName;
    uint BaseIoSize;
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS ControlFlags;
    ushort VolumeNameLength;
};

struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2 {
public:
    long MaxIops;
    long MaxBandwidth;
    long ReservationIops;
    string VolumeName;
    uint BaseIoSize;
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS ControlFlags;
    ushort VolumeNameLength;
    long CriticalReservationIops;
    long ReservationBandwidth;
    long CriticalReservationBandwidth;
    long MaxTimePercent;
    long ReservationTimePercent;
    long CriticalReservationTimePercent;
};

struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3 {
public:
    long MaxIops;
    long MaxBandwidth;
    long ReservationIops;
    string VolumeName;
    uint BaseIoSize;
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS ControlFlags;
    ushort VolumeNameLength;
    long CriticalReservationIops;
    long ReservationBandwidth;
    long CriticalReservationBandwidth;
    long MaxTimePercent;
    long ReservationTimePercent;
    long CriticalReservationTimePercent;
    long SoftMaxIops;
    long SoftMaxBandwidth;
    long SoftMaxTimePercent;
    long LimitExcessNotifyIops;
    long LimitExcessNotifyBandwidth;
    long LimitExcessNotifyTimePercent;
};

struct JOBOBJECT_IO_ATTRIBUTION_STATS {
public:
    ulong IoCount;
    ulong TotalNonOverlappedQueueTime;
    ulong TotalNonOverlappedServiceTime;
    ulong TotalSize;
};

struct JOBOBJECT_IO_ATTRIBUTION_INFORMATION {
public:
    uint ControlFlags;
    JOBOBJECT_IO_ATTRIBUTION_STATS ReadStats;
    JOBOBJECT_IO_ATTRIBUTION_STATS WriteStats;
};

struct SILOOBJECT_BASIC_INFORMATION {
public:
    uint SiloId;
    uint SiloParentId;
    uint NumberOfProcesses;
    uchar IsInServerSilo;
    uchar Reserved;
};

struct SERVERSILO_BASIC_INFORMATION {
public:
    uint ServiceSessionId;
    SERVERSILO_STATE State;
    uint ExitStatus;
};

struct CACHE_DESCRIPTOR {
public:
    uchar Level;
    uchar Associativity;
    ushort LineSize;
    uint Size;
    PROCESSOR_CACHE_TYPE Type;
};

struct ProcessorCore {
public:
    ulong ProcessorMask;
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    uchar Flags;
};

struct PROCESSOR_RELATIONSHIP {
public:
    uchar Flags;
    uchar EfficiencyClass;
    uchar Reserved;
    ushort GroupCount;
    GROUP_AFFINITY GroupMask;
};

struct NUMA_NODE_RELATIONSHIP {
public:
    uint NodeNumber;
    uchar Reserved;
    GROUP_AFFINITY GroupMask;
};

struct CACHE_RELATIONSHIP {
public:
    uchar Level;
    uchar Associativity;
    ushort LineSize;
    uint CacheSize;
    PROCESSOR_CACHE_TYPE Type;
    uchar Reserved;
    GROUP_AFFINITY GroupMask;
};

struct PROCESSOR_GROUP_INFO {
public:
    uchar MaximumProcessorCount;
    uchar ActiveProcessorCount;
    uchar Reserved;
    ulong ActiveProcessorMask;
};

struct GROUP_RELATIONSHIP {
public:
    ushort MaximumGroupCount;
    ushort ActiveGroupCount;
    uchar Reserved;
    PROCESSOR_GROUP_INFO GroupInfo;
};

struct SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION {
public:
    ulong CycleTime;
};

struct XSTATE_FEATURE {
public:
    uint Offset;
    uint Size;
};

struct XSTATE_CONFIGURATION {
public:
    ulong EnabledFeatures;
    ulong EnabledVolatileFeatures;
    uint Size;
    uint ControlFlags;
    XSTATE_FEATURE Features;
    ulong EnabledSupervisorFeatures;
    ulong AlignedFeatures;
    uint AllFeatureSize;
    uint AllFeatures;
};

struct MEMORY_BASIC_INFORMATION {
public:
    PVOID BaseAddress;
    PVOID AllocationBase;
    uint AllocationProtect;
    ulong RegionSize;
    uint State;
    uint Protect;
    uint Type;
};

struct MEMORY_BASIC_INFORMATION32 {
public:
    uint BaseAddress;
    uint AllocationBase;
    uint AllocationProtect;
    uint RegionSize;
    uint State;
    uint Protect;
    uint Type;
};

struct MEMORY_BASIC_INFORMATION64 {
public:
    ulong BaseAddress;
    ulong AllocationBase;
    uint AllocationProtect;
    uint __alignment1;
    ulong RegionSize;
    uint State;
    uint Protect;
    uint Type;
    uint __alignment2;
};

struct CFG_CALL_TARGET_INFO {
public:
    ulong Offset;
    ulong Flags;
};

struct MEM_ADDRESS_REQUIREMENTS {
public:
    PVOID LowestStartingAddress;
    PVOID HighestEndingAddress;
    ulong Alignment;
};

struct ENCLAVE_CREATE_INFO_SGX {
public:
    uchar Secs;
};

struct ENCLAVE_INIT_INFO_SGX {
public:
    uchar SigStruct;
    uchar Reserved1;
    uchar EInitToken;
    uchar Reserved2;
};

struct ENCLAVE_CREATE_INFO_VBS {
public:
    uint Flags;
    uchar OwnerID;
};

struct ENCLAVE_INIT_INFO_VBS {
public:
    uint Length;
    uint ThreadCount;
};

struct FILE_ID_128 {
public:
    uchar Identifier;
};

struct FILE_NOTIFY_INFORMATION {
public:
    uint NextEntryOffset;
    uint Action;
    uint FileNameLength;
    short FileName;
};

struct FILE_NOTIFY_EXTENDED_INFORMATION {
public:
    uint NextEntryOffset;
    uint Action;
    long CreationTime;
    long LastModificationTime;
    long LastChangeTime;
    long LastAccessTime;
    long AllocatedLength;
    long FileSize;
    uint FileAttributes;
    uint ReparsePointTag;
    long FileId;
    long ParentFileId;
    uint FileNameLength;
    short FileName;
};

struct GenericReparseBuffer {
public:
    uint ReparseTag;
    ushort ReparseDataLength;
    ushort Reserved;
    GUID ReparseGuid;
    uchar DataBuffer;
};

struct SCRUB_DATA_INPUT {
public:
    uint Size;
    uint Flags;
    uint MaximumIos;
    uint ObjectId;
    uint Reserved;
    uchar ResumeContext;
};

struct SCRUB_PARITY_EXTENT {
public:
    long Offset;
    ulong Length;
};

struct SCRUB_PARITY_EXTENT_DATA {
public:
    ushort Size;
    ushort Flags;
    ushort NumberOfParityExtents;
    ushort MaximumNumberOfParityExtents;
    SCRUB_PARITY_EXTENT ParityExtents;
};

struct SCRUB_DATA_OUTPUT {
public:
    uint Size;
    uint Flags;
    uint Status;
    ulong ErrorFileOffset;
    ulong ErrorLength;
    ulong NumberOfBytesRepaired;
    ulong NumberOfBytesFailed;
    ulong InternalFileReference;
    ushort ResumeContextLength;
    ushort ParityExtentDataOffset;
    uint Reserved;
    uchar ResumeContext;
};

struct SHARED_VIRTUAL_DISK_SUPPORT {
public:
    SharedVirtualDiskSupportType SharedVirtualDiskSupport;
    SharedVirtualDiskHandleState HandleState;
};

struct NETWORK_APP_INSTANCE_EA {
public:
    GUID AppInstanceID;
    uint CsvFlags;
};

struct CM_POWER_DATA {
public:
    uint PD_Size;
    DEVICE_POWER_STATE PD_MostRecentPowerState;
    uint PD_Capabilities;
    uint PD_D1Latency;
    uint PD_D2Latency;
    uint PD_D3Latency;
    DEVICE_POWER_STATE PD_PowerStateMapping;
    SYSTEM_POWER_STATE PD_DeepestSystemWake;
};

struct POWER_USER_PRESENCE {
public:
    POWER_USER_PRESENCE_TYPE UserPresence;
};

struct POWER_SESSION_CONNECT {
public:
    uchar Connected;
    uchar Console;
};

struct POWER_SESSION_TIMEOUTS {
public:
    uint InputTimeout;
    uint DisplayTimeout;
};

struct POWER_SESSION_RIT_STATE {
public:
    uchar Active;
    uint LastInputTime;
};

struct POWER_SESSION_WINLOGON {
public:
    uint SessionId;
    uchar Console;
    uchar Locked;
};

struct POWER_IDLE_RESILIENCY {
public:
    uint CoalescingTimeout;
    uint IdleResiliencyPeriod;
};

struct POWER_MONITOR_INVOCATION {
public:
    uchar Console;
    POWER_MONITOR_REQUEST_REASON RequestReason;
};

struct RESUME_PERFORMANCE {
public:
    uint PostTimeMs;
    ulong TotalResumeTimeMs;
    ulong ResumeCompleteTimestamp;
};

struct APPLICATIONLAUNCH_SETTING_VALUE {
public:
    long ActivationTime;
    uint Flags;
    uint ButtonInstanceID;
};

struct POWER_PLATFORM_INFORMATION {
public:
    uchar AoAc;
};

struct POWER_ACTION_POLICY {
public:
    POWER_ACTION Action;
    uint Flags;
    uint EventCode;
};

struct SYSTEM_POWER_LEVEL {
public:
    uchar Enable;
    uchar Spare;
    uint BatteryLevel;
    POWER_ACTION_POLICY PowerPolicy;
    SYSTEM_POWER_STATE MinSystemState;
};

struct SYSTEM_POWER_POLICY {
public:
    uint Revision;
    POWER_ACTION_POLICY PowerButton;
    POWER_ACTION_POLICY SleepButton;
    POWER_ACTION_POLICY LidClose;
    SYSTEM_POWER_STATE LidOpenWake;
    uint Reserved;
    POWER_ACTION_POLICY Idle;
    uint IdleTimeout;
    uchar IdleSensitivity;
    uchar DynamicThrottle;
    uchar Spare2;
    SYSTEM_POWER_STATE MinSleep;
    SYSTEM_POWER_STATE MaxSleep;
    SYSTEM_POWER_STATE ReducedLatencySleep;
    uint WinLogonFlags;
    uint Spare3;
    uint DozeS4Timeout;
    uint BroadcastCapacityResolution;
    SYSTEM_POWER_LEVEL DischargePolicy;
    uint VideoTimeout;
    uchar VideoDimDisplay;
    uint VideoReserved;
    uint SpindownTimeout;
    uchar OptimizeForPower;
    uchar FanThrottleTolerance;
    uchar ForcedThrottle;
    uchar MinThrottle;
    POWER_ACTION_POLICY OverThrottled;
};

struct PROCESSOR_POWER_POLICY_INFO {
public:
    uint TimeCheck;
    uint DemoteLimit;
    uint PromoteLimit;
    uchar DemotePercent;
    uchar PromotePercent;
    uchar Spare;
    uint Flags;
};

struct PROCESSOR_POWER_POLICY {
public:
    uint Revision;
    uchar DynamicThrottle;
    uchar Spare;
    uint Flags;
    uint PolicyCount;
    PROCESSOR_POWER_POLICY_INFO Policy;
};

struct ADMINISTRATOR_POWER_POLICY {
public:
    SYSTEM_POWER_STATE MinSleep;
    SYSTEM_POWER_STATE MaxSleep;
    uint MinVideoTimeout;
    uint MaxVideoTimeout;
    uint MinSpindownTimeout;
    uint MaxSpindownTimeout;
};

struct HIBERFILE_BUCKET {
public:
    ulong MaxPhysicalMemory;
    uint PhysicalMemoryPercent;
};

struct IMAGE_DOS_HEADER {
public:
    ushort e_magic;
    ushort e_cblp;
    ushort e_cp;
    ushort e_crlc;
    ushort e_cparhdr;
    ushort e_minalloc;
    ushort e_maxalloc;
    ushort e_ss;
    ushort e_sp;
    ushort e_csum;
    ushort e_ip;
    ushort e_cs;
    ushort e_lfarlc;
    ushort e_ovno;
    ushort e_res;
    ushort e_oemid;
    ushort e_oeminfo;
    ushort e_res2;
    int e_lfanew;
};

struct IMAGE_OS2_HEADER {
public:
    ushort ne_magic;
    char ne_ver;
    char ne_rev;
    ushort ne_enttab;
    ushort ne_cbenttab;
    int ne_crc;
    ushort ne_flags;
    ushort ne_autodata;
    ushort ne_heap;
    ushort ne_stack;
    int ne_csip;
    int ne_sssp;
    ushort ne_cseg;
    ushort ne_cmod;
    ushort ne_cbnrestab;
    ushort ne_segtab;
    ushort ne_rsrctab;
    ushort ne_restab;
    ushort ne_modtab;
    ushort ne_imptab;
    int ne_nrestab;
    ushort ne_cmovent;
    ushort ne_align;
    ushort ne_cres;
    uchar ne_exetyp;
    uchar ne_flagsothers;
    ushort ne_pretthunks;
    ushort ne_psegrefbytes;
    ushort ne_swaparea;
    ushort ne_expver;
};

struct IMAGE_VXD_HEADER {
public:
    ushort e32_magic;
    uchar e32_border;
    uchar e32_ushorter;
    uint e32_level;
    ushort e32_cpu;
    ushort e32_os;
    uint e32_ver;
    uint e32_mflags;
    uint e32_mpages;
    uint e32_startobj;
    uint e32_eip;
    uint e32_stackobj;
    uint e32_esp;
    uint e32_pagesize;
    uint e32_lastpagesize;
    uint e32_fixupsize;
    uint e32_fixupsum;
    uint e32_ldrsize;
    uint e32_ldrsum;
    uint e32_objtab;
    uint e32_objcnt;
    uint e32_objmap;
    uint e32_itermap;
    uint e32_rsrctab;
    uint e32_rsrccnt;
    uint e32_restab;
    uint e32_enttab;
    uint e32_dirtab;
    uint e32_dircnt;
    uint e32_fpagetab;
    uint e32_frectab;
    uint e32_impmod;
    uint e32_impmodcnt;
    uint e32_impproc;
    uint e32_pagesum;
    uint e32_datapage;
    uint e32_preload;
    uint e32_nrestab;
    uint e32_cbnrestab;
    uint e32_nressum;
    uint e32_autodata;
    uint e32_debuginfo;
    uint e32_debuglen;
    uint e32_instpreload;
    uint e32_instdemand;
    uint e32_heapsize;
    uchar e32_res3;
    uint e32_winresoff;
    uint e32_winreslen;
    ushort e32_devid;
    ushort e32_ddkver;
};

struct IMAGE_FILE_HEADER {
public:
    ushort Machine;
    ushort NumberOfSections;
    uint TimeDateStamp;
    uint PointerToSymbolTable;
    uint NumberOfSymbols;
    ushort SizeOfOptionalHeader;
    ushort Characteristics;
};

struct IMAGE_DATA_DIRECTORY {
public:
    uint VirtualAddress;
    uint Size;
};

struct IMAGE_OPTIONAL_HEADER32 {
public:
    ushort Magic;
    uchar MajorLinkerVersion;
    uchar MinorLinkerVersion;
    uint SizeOfCode;
    uint SizeOfInitializedData;
    uint SizeOfUninitializedData;
    uint AddressOfEntryPoint;
    uint BaseOfCode;
    uint BaseOfData;
    uint ImageBase;
    uint SectionAlignment;
    uint FileAlignment;
    ushort MajorOperatingSystemVersion;
    ushort MinorOperatingSystemVersion;
    ushort MajorImageVersion;
    ushort MinorImageVersion;
    ushort MajorSubsystemVersion;
    ushort MinorSubsystemVersion;
    uint Win32VersionValue;
    uint SizeOfImage;
    uint SizeOfHeaders;
    uint CheckSum;
    ushort Subsystem;
    ushort DllCharacteristics;
    uint SizeOfStackReserve;
    uint SizeOfStackCommit;
    uint SizeOfHeapReserve;
    uint SizeOfHeapCommit;
    uint LoaderFlags;
    uint NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory;
};

struct IMAGE_ROM_OPTIONAL_HEADER {
public:
    ushort Magic;
    uchar MajorLinkerVersion;
    uchar MinorLinkerVersion;
    uint SizeOfCode;
    uint SizeOfInitializedData;
    uint SizeOfUninitializedData;
    uint AddressOfEntryPoint;
    uint BaseOfCode;
    uint BaseOfData;
    uint BaseOfBss;
    uint GprMask;
    uint CprMask;
    uint GpValue;
};

struct IMAGE_OPTIONAL_HEADER64 {
public:
    ushort Magic;
    uchar MajorLinkerVersion;
    uchar MinorLinkerVersion;
    uint SizeOfCode;
    uint SizeOfInitializedData;
    uint SizeOfUninitializedData;
    uint AddressOfEntryPoint;
    uint BaseOfCode;
    ulong ImageBase;
    uint SectionAlignment;
    uint FileAlignment;
    ushort MajorOperatingSystemVersion;
    ushort MinorOperatingSystemVersion;
    ushort MajorImageVersion;
    ushort MinorImageVersion;
    ushort MajorSubsystemVersion;
    ushort MinorSubsystemVersion;
    uint Win32VersionValue;
    uint SizeOfImage;
    uint SizeOfHeaders;
    uint CheckSum;
    ushort Subsystem;
    ushort DllCharacteristics;
    ulong SizeOfStackReserve;
    ulong SizeOfStackCommit;
    ulong SizeOfHeapReserve;
    ulong SizeOfHeapCommit;
    uint LoaderFlags;
    uint NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory;
};

struct IMAGE_NT_HEADERS64 {
public:
    uint Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
};

struct IMAGE_NT_HEADERS32 {
public:
    uint Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
};

struct IMAGE_ROM_HEADERS {
public:
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
};

struct ANON_OBJECT_HEADER {
public:
    ushort Sig1;
    ushort Sig2;
    ushort Version;
    ushort Machine;
    uint TimeDateStamp;
    GUID ClassID;
    uint SizeOfData;
};

struct ANON_OBJECT_HEADER_V2 {
public:
    ushort Sig1;
    ushort Sig2;
    ushort Version;
    ushort Machine;
    uint TimeDateStamp;
    GUID ClassID;
    uint SizeOfData;
    uint Flags;
    uint MetaDataSize;
    uint MetaDataOffset;
};

struct ANON_OBJECT_HEADER_BIGOBJ {
public:
    ushort Sig1;
    ushort Sig2;
    ushort Version;
    ushort Machine;
    uint TimeDateStamp;
    GUID ClassID;
    uint SizeOfData;
    uint Flags;
    uint MetaDataSize;
    uint MetaDataOffset;
    uint NumberOfSections;
    uint PointerToSymbolTable;
    uint NumberOfSymbols;
};

struct IMAGE_SECTION_HEADER {
public:
    uchar Name;
    uint PhysicalAddress;
    uint VirtualAddress;
    uint SizeOfRawData;
    uint PointerToRawData;
    uint PointerToRelocations;
    uint PointerToLinenumbers;
    ushort NumberOfRelocations;
    ushort NumberOfLinenumbers;
    uint Characteristics;
};

struct IMAGE_SYMBOL {
public:
    uchar ShortName;
    uint Value;
    short SectionNumber;
    ushort Type;
    uchar StorageClass;
    uchar NumberOfAuxSymbols;
};

struct IMAGE_SYMBOL_EX {
public:
    uchar ShortName;
    uint Value;
    int SectionNumber;
    ushort Type;
    uchar StorageClass;
    uchar NumberOfAuxSymbols;
};

struct IMAGE_AUX_SYMBOL_TOKEN_DEF {
public:
    uchar bAuxType;
    uchar bReserved;
    uint SymbolTableIndex;
    uchar rgbReserved;
};

struct IMAGE_LINENUMBER {
public:
    uint VirtualAddress;
    ushort Linenumber;
};

struct IMAGE_BASE_RELOCATION {
public:
    uint VirtualAddress;
    uint SizeOfBlock;
};

struct IMAGE_ARCHIVE_MEMBER_HEADER {
public:
    uchar Name;
    uchar Date;
    uchar UserID;
    uchar GroupID;
    uchar Mode;
    uchar Size;
    uchar EndHeader;
};

struct IMAGE_EXPORT_DIRECTORY {
public:
    uint Characteristics;
    uint TimeDateStamp;
    ushort MajorVersion;
    ushort MinorVersion;
    uint Name;
    uint Base;
    uint NumberOfFunctions;
    uint NumberOfNames;
    uint AddressOfFunctions;
    uint AddressOfNames;
    uint AddressOfNameOrdinals;
};

struct IMAGE_IMPORT_BY_NAME {
public:
    ushort Hint;
    char Name;
};

struct IMAGE_THUNK_DATA64 {
public:
    ulong Data;
};

struct IMAGE_THUNK_DATA32 {
public:
    uint Data;
};

struct IMAGE_BOUND_IMPORT_DESCRIPTOR {
public:
    uint TimeDateStamp;
    ushort OffsetModuleName;
    ushort NumberOfModuleForwarderRefs;
};

struct IMAGE_BOUND_FORWARDER_REF {
public:
    uint TimeDateStamp;
    ushort OffsetModuleName;
    ushort Reserved;
};

struct IMAGE_RESOURCE_DIRECTORY {
public:
    uint Characteristics;
    uint TimeDateStamp;
    ushort MajorVersion;
    ushort MinorVersion;
    ushort NumberOfNamedEntries;
    ushort NumberOfIdEntries;
};

struct IMAGE_RESOURCE_DIRECTORY_STRING {
public:
    ushort Length;
    char NameString;
};

struct IMAGE_RESOURCE_DIR_STRING_U {
public:
    ushort Length;
    short NameString;
};

struct IMAGE_RESOURCE_DATA_ENTRY {
public:
    uint OffsetToData;
    uint Size;
    uint CodePage;
    uint Reserved;
};

struct IMAGE_LOAD_CONFIG_CODE_INTEGRITY {
public:
    ushort Flags;
    ushort Catalog;
    uint CatalogOffset;
    uint Reserved;
};

struct IMAGE_DYNAMIC_RELOCATION_TABLE {
public:
    uint Version;
    uint Size;
};

struct IMAGE_DYNAMIC_RELOCATION32 {
public:
    uint Symbol;
    uint BaseRelocSize;
};

struct IMAGE_DYNAMIC_RELOCATION64 {
public:
    ulong Symbol;
    uint BaseRelocSize;
};

struct IMAGE_DYNAMIC_RELOCATION32_V2 {
public:
    uint HeaderSize;
    uint FixupInfoSize;
    uint Symbol;
    uint SymbolGroup;
    uint Flags;
};

struct IMAGE_DYNAMIC_RELOCATION64_V2 {
public:
    uint HeaderSize;
    uint FixupInfoSize;
    ulong Symbol;
    uint SymbolGroup;
    uint Flags;
};

struct IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER {
public:
    uchar PrologueByteCount;
};

struct IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER {
public:
    uint EpilogueCount;
    uchar EpilogueByteCount;
    uchar BranchDescriptorElementSize;
    ushort BranchDescriptorCount;
};

struct IMAGE_LOAD_CONFIG_DIRECTORY32 {
public:
    uint Size;
    uint TimeDateStamp;
    ushort MajorVersion;
    ushort MinorVersion;
    uint GlobalFlagsClear;
    uint GlobalFlagsSet;
    uint CriticalSectionDefaultTimeout;
    uint DeCommitFreeBlockThreshold;
    uint DeCommitTotalFreeThreshold;
    uint LockPrefixTable;
    uint MaximumAllocationSize;
    uint VirtualMemoryThreshold;
    uint ProcessHeapFlags;
    uint ProcessAffinityMask;
    ushort CSDVersion;
    ushort DependentLoadFlags;
    uint EditList;
    uint SecurityCookie;
    uint SEHandlerTable;
    uint SEHandlerCount;
    uint GuardCFCheckFunctionPointer;
    uint GuardCFDispatchFunctionPointer;
    uint GuardCFFunctionTable;
    uint GuardCFFunctionCount;
    uint GuardFlags;
    IMAGE_LOAD_CONFIG_CODE_INTEGRITY CodeIntegrity;
    uint GuardAddressTakenIatEntryTable;
    uint GuardAddressTakenIatEntryCount;
    uint GuardLongJumpTargetTable;
    uint GuardLongJumpTargetCount;
    uint DynamicValueRelocTable;
    uint CHPEMetadataPointer;
    uint GuardRFFailureRoutine;
    uint GuardRFFailureRoutineFunctionPointer;
    uint DynamicValueRelocTableOffset;
    ushort DynamicValueRelocTableSection;
    ushort Reserved2;
    uint GuardRFVerifyStackPointerFunctionPointer;
    uint HotPatchTableOffset;
    uint Reserved3;
    uint EnclaveConfigurationPointer;
};

struct IMAGE_LOAD_CONFIG_DIRECTORY64 {
public:
    uint Size;
    uint TimeDateStamp;
    ushort MajorVersion;
    ushort MinorVersion;
    uint GlobalFlagsClear;
    uint GlobalFlagsSet;
    uint CriticalSectionDefaultTimeout;
    ulong DeCommitFreeBlockThreshold;
    ulong DeCommitTotalFreeThreshold;
    ulong LockPrefixTable;
    ulong MaximumAllocationSize;
    ulong VirtualMemoryThreshold;
    ulong ProcessAffinityMask;
    uint ProcessHeapFlags;
    ushort CSDVersion;
    ushort DependentLoadFlags;
    ulong EditList;
    ulong SecurityCookie;
    ulong SEHandlerTable;
    ulong SEHandlerCount;
    ulong GuardCFCheckFunctionPointer;
    ulong GuardCFDispatchFunctionPointer;
    ulong GuardCFFunctionTable;
    ulong GuardCFFunctionCount;
    uint GuardFlags;
    IMAGE_LOAD_CONFIG_CODE_INTEGRITY CodeIntegrity;
    ulong GuardAddressTakenIatEntryTable;
    ulong GuardAddressTakenIatEntryCount;
    ulong GuardLongJumpTargetTable;
    ulong GuardLongJumpTargetCount;
    ulong DynamicValueRelocTable;
    ulong CHPEMetadataPointer;
    ulong GuardRFFailureRoutine;
    ulong GuardRFFailureRoutineFunctionPointer;
    uint DynamicValueRelocTableOffset;
    ushort DynamicValueRelocTableSection;
    ushort Reserved2;
    ulong GuardRFVerifyStackPointerFunctionPointer;
    uint HotPatchTableOffset;
    uint Reserved3;
    ulong EnclaveConfigurationPointer;
};

struct IMAGE_HOT_PATCH_INFO {
public:
    uint Version;
    uint Size;
    uint SequenceNumber;
    uint BaseImageList;
    uint BaseImageCount;
    uint BufferOffset;
};

struct IMAGE_HOT_PATCH_BASE {
public:
    uint SequenceNumber;
    uint Flags;
    uint OriginalTimeDateStamp;
    uint OriginalCheckSum;
    uint CodeIntegrityInfo;
    uint CodeIntegritySize;
    uint PatchTable;
    uint BufferOffset;
};

struct IMAGE_HOT_PATCH_HASHES {
public:
    uchar SHA256;
    uchar SHA1;
};

struct IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
public:
    uint FuncStart;
    uint Flags;
};

struct IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY {
public:
    ulong BeginAddress;
    ulong EndAddress;
    ulong ExceptionHandler;
    ulong HandlerData;
    ulong PrologEndAddress;
};

struct IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY {
public:
    uint BeginAddress;
    uint EndAddress;
    uint ExceptionHandler;
    uint HandlerData;
    uint PrologEndAddress;
};

struct IMAGE_ENCLAVE_CONFIG32 {
public:
    uint Size;
    uint MinimumRequiredConfigSize;
    uint PolicyFlags;
    uint NumberOfImports;
    uint ImportList;
    uint ImportEntrySize;
    uchar FamilyID;
    uchar ImageID;
    uint ImageVersion;
    uint SecurityVersion;
    uint EnclaveSize;
    uint NumberOfThreads;
    uint EnclaveFlags;
};

struct IMAGE_ENCLAVE_CONFIG64 {
public:
    uint Size;
    uint MinimumRequiredConfigSize;
    uint PolicyFlags;
    uint NumberOfImports;
    uint ImportList;
    uint ImportEntrySize;
    uchar FamilyID;
    uchar ImageID;
    uint ImageVersion;
    uint SecurityVersion;
    ulong EnclaveSize;
    uint NumberOfThreads;
    uint EnclaveFlags;
};

struct IMAGE_ENCLAVE_IMPORT {
public:
    uint MatchType;
    uint MinimumSecurityVersion;
    uchar UniqueOrAuthorID;
    uchar FamilyID;
    uchar ImageID;
    uint ImportName;
    uint Reserved;
};

struct IMAGE_DEBUG_DIRECTORY {
public:
    uint Characteristics;
    uint TimeDateStamp;
    ushort MajorVersion;
    ushort MinorVersion;
    uint Type;
    uint SizeOfData;
    uint AddressOfRawData;
    uint PointerToRawData;
};

struct IMAGE_COFF_SYMBOLS_HEADER {
public:
    uint NumberOfSymbols;
    uint LvaToFirstSymbol;
    uint NumberOfLinenumbers;
    uint LvaToFirstLinenumber;
    uint RvaToFirstByteOfCode;
    uint RvaToLastByteOfCode;
    uint RvaToFirstByteOfData;
    uint RvaToLastByteOfData;
};

struct FPO_DATA {
public:
    uint ulOffStart;
    uint cbProcSize;
    uint cdwLocals;
    ushort cdwParams;
    ushort data;
};

struct IMAGE_DEBUG_MISC {
public:
    uint DataType;
    uint Length;
    uchar Unicode;
    uchar Reserved;
    uchar Data;
};

struct IMAGE_FUNCTION_ENTRY {
public:
    uint StartingAddress;
    uint EndingAddress;
    uint EndOfPrologue;
};

struct IMAGE_SEPARATE_DEBUG_HEADER {
public:
    ushort Signature;
    ushort Flags;
    ushort Machine;
    ushort Characteristics;
    uint TimeDateStamp;
    uint CheckSum;
    uint ImageBase;
    uint SizeOfImage;
    uint NumberOfSections;
    uint ExportedNamesSize;
    uint DebugDirectorySize;
    uint SectionAlignment;
    uint Reserved;
};

struct NON_PAGED_DEBUG_INFO {
public:
    ushort Signature;
    ushort Flags;
    uint Size;
    ushort Machine;
    ushort Characteristics;
    uint TimeDateStamp;
    uint CheckSum;
    uint SizeOfImage;
    ulong ImageBase;
};

struct IMAGE_ARCHITECTURE_HEADER {
public:
    int mask;
    uint FirstEntryRVA;
};

struct IMAGE_ARCHITECTURE_ENTRY {
public:
    uint FixupInstRVA;
    uint NewInst;
};

struct SLIST_ENTRY {
public:
    PVOID Next;
};

struct RTL_BARRIER {
public:
    uint Reserved1;
    uint Reserved2;
    ulong Reserved3;
    uint Reserved4;
    uint Reserved5;
};

struct MESSAGE_RESOURCE_ENTRY {
public:
    ushort Length;
    ushort Flags;
    uchar Text;
};

struct MESSAGE_RESOURCE_BLOCK {
public:
    uint LowId;
    uint HighId;
    uint OffsetToEntries;
};

struct MESSAGE_RESOURCE_DATA {
public:
    uint NumberOfBlocks;
    MESSAGE_RESOURCE_BLOCK Blocks;
};

struct OSVERSIONINFOW {
public:
    uint dwOSVersionInfoSize;
    uint dwMajorVersion;
    uint dwMinorVersion;
    uint dwBuildNumber;
    uint dwPlatformId;
    ushort szCSDVersion;
};

struct OSVERSIONINFOEXW {
public:
    uint dwOSVersionInfoSize;
    uint dwMajorVersion;
    uint dwMinorVersion;
    uint dwBuildNumber;
    uint dwPlatformId;
    short szCSDVersion;
    ushort wServicePackMajor;
    ushort wServicePackMinor;
    ushort wSuiteMask;
    uchar wProductType;
    uchar wReserved;
};

struct NV_MEMORY_RANGE {
public:
    PVOID BaseAddress;
    ulong Length;
};

struct CORRELATION_VECTOR {
public:
    char Version;
    char Vector;
};

struct CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG {
public:
    uint Size;
    const string TriggerId;
};

struct IMAGE_POLICY_ENTRY {
public:
    IMAGE_POLICY_ENTRY_TYPE Type;
    IMAGE_POLICY_ID PolicyId;
    PVOID Value;
};

struct IMAGE_POLICY_METADATA {
public:
    uchar Version;
    uchar Reserved0;
    ulong ApplicationId;
    IMAGE_POLICY_ENTRY Policies;
};

struct RTL_CRITICAL_SECTION_DEBUG {
public:
    ushort Type;
    ushort CreatorBackTraceIndex;
    PVOID CriticalSection;
    LIST_ENTRY ProcessLocksList;
    uint EntryCount;
    uint ContentionCount;
    uint Flags;
    ushort CreatorBackTraceIndexHigh;
    ushort Spareushort;
};

struct RTL_CRITICAL_SECTION {
public:
    PVOID DebugInfo;
    int LockCount;
    int RecursionCount;
    HANDLE OwningThread;
    HANDLE LockSemaphore;
    ulong SpinCount;
};

struct RTL_SRWLOCK {
public:
    PVOID Ptr;
};

struct RTL_CONDITION_VARIABLE {
public:
    PVOID Ptr;
};

struct HEAP_OPTIMIZE_RESOURCES_INFORMATION {
public:
    uint Version;
    uint Flags;
};

struct ACTIVATION_CONTEXT_QUERY_INDEX {
public:
    uint ulAssemblyIndex;
    uint ulFileIndexInAssembly;
};

struct ASSEMBLY_FILE_DETAILED_INFORMATION {
public:
    uint ulFlags;
    uint ulFilenameLength;
    uint ulPathLength;
    const string lpFileName;
    const string lpFilePath;
};

struct ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION {
public:
    uint ulFlags;
    uint ulEncodedAssemblyIdentityLength;
    uint ulManifestPathType;
    uint ulManifestPathLength;
    long liManifestLastWriteTime;
    uint ulPolicyPathType;
    uint ulPolicyPathLength;
    long liPolicyLastWriteTime;
    uint ulMetadataSatelliteRosterIndex;
    uint ulManifestVersionMajor;
    uint ulManifestVersionMinor;
    uint ulPolicyVersionMajor;
    uint ulPolicyVersionMinor;
    uint ulAssemblyDirectoryNameLength;
    const string lpAssemblyEncodedAssemblyIdentity;
    const string lpAssemblyManifestPath;
    const string lpAssemblyPolicyPath;
    const string lpAssemblyDirectoryName;
    uint ulFileCount;
};

struct ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION {
public:
    uint ulFlags;
    ACTCTX_REQUESTED_RUN_LEVEL RunLevel;
    uint UiAccess;
};

struct COMPATIBILITY_CONTEXT_ELEMENT {
public:
    GUID Id;
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE Type;
};

struct ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION {
public:
    uint ElementCount;
    COMPATIBILITY_CONTEXT_ELEMENT Elements;
};

struct SUPPORTED_OS_INFO {
public:
    ushort MajorVersion;
    ushort MinorVersion;
};

struct ACTIVATION_CONTEXT_DETAILED_INFORMATION {
public:
    uint dwFlags;
    uint ulFormatVersion;
    uint ulAssemblyCount;
    uint ulRootManifestPathType;
    uint ulRootManifestPathChars;
    uint ulRootConfigurationPathType;
    uint ulRootConfigurationPathChars;
    uint ulAppDirPathType;
    uint ulAppDirPathChars;
    const string lpRootManifestPath;
    const string lpRootConfigurationPath;
    const string lpAppDirPath;
};

struct HARDWARE_COUNTER_DATA {
public:
    HARDWARE_COUNTER_TYPE Type;
    uint Reserved;
    ulong Value;
};

struct PERFORMANCE_DATA {
public:
    ushort Size;
    uchar Version;
    uchar HwCountersCount;
    uint ContextSwitchCount;
    ulong WaitReasonBitMap;
    ulong CycleTime;
    uint RetryCount;
    uint Reserved;
    HARDWARE_COUNTER_DATA HwCounters;
};

struct EVENTLOGRECORD {
public:
    uint Length;
    uint Reserved;
    uint RecordNumber;
    uint TimeGenerated;
    uint TimeWritten;
    uint EventID;
    ushort EventType;
    ushort NumStrings;
    ushort EventCategory;
    ushort ReservedFlags;
    uint ClosingRecordNumber;
    uint StringOffset;
    uint UserSidLength;
    uint UserSidOffset;
    uint DataLength;
    uint DataOffset;
};

struct TAPE_ERASE {
public:
    uint Type;
    uchar Immediate;
};

struct TAPE_PREPARE {
public:
    uint Operation;
    uchar Immediate;
};

struct TAPE_WRITE_MARKS {
public:
    uint Type;
    uint Count;
    uchar Immediate;
};

struct TAPE_GET_POSITION {
public:
    uint Type;
    uint Partition;
    long Offset;
};

struct TAPE_SET_POSITION {
public:
    uint Method;
    uint Partition;
    long Offset;
    uchar Immediate;
};

struct TAPE_GET_DRIVE_PARAMETERS {
public:
    uchar ECC;
    uchar Compression;
    uchar DataPadding;
    uchar ReportSetmarks;
    uint DefaultBlockSize;
    uint MaximumBlockSize;
    uint MinimumBlockSize;
    uint MaximumPartitionCount;
    uint FeaturesLow;
    uint FeaturesHigh;
    uint EOTWarningZoneSize;
};

struct TAPE_SET_DRIVE_PARAMETERS {
public:
    uchar ECC;
    uchar Compression;
    uchar DataPadding;
    uchar ReportSetmarks;
    uint EOTWarningZoneSize;
};

struct TAPE_GET_MEDIA_PARAMETERS {
public:
    long Capacity;
    long Remaining;
    uint BlockSize;
    uint PartitionCount;
    uchar WriteProtected;
};

struct TAPE_SET_MEDIA_PARAMETERS {
public:
    uint BlockSize;
};

struct TAPE_CREATE_PARTITION {
public:
    uint Method;
    uint Count;
    uint Size;
};

struct TAPE_WMI_OPERATIONS {
public:
    uint Method;
    uint DataBufferSize;
    PVOID DataBuffer;
};

struct TRANSACTION_BASIC_INFORMATION {
public:
    GUID TransactionId;
    uint State;
    uint Outcome;
};

struct TRANSACTIONMANAGER_BASIC_INFORMATION {
public:
    GUID TmIdentity;
    long VirtualClock;
};

struct TRANSACTIONMANAGER_LOG_INFORMATION {
public:
    GUID LogIdentity;
};

struct TRANSACTIONMANAGER_LOGPATH_INFORMATION {
public:
    uint LogPathLength;
    short LogPath;
};

struct TRANSACTIONMANAGER_RECOVERY_INFORMATION {
public:
    ulong LastRecoveredLsn;
};

struct TRANSACTIONMANAGER_OLDEST_INFORMATION {
public:
    GUID OldestTransactionGuid;
};

struct TRANSACTION_PROPERTIES_INFORMATION {
public:
    uint IsolationLevel;
    uint IsolationFlags;
    long Timeout;
    uint Outcome;
    uint DescriptionLength;
    short Description;
};

struct TRANSACTION_BIND_INFORMATION {
public:
    HANDLE TmHandle;
};

struct TRANSACTION_ENLISTMENT_PAIR {
public:
    GUID EnlistmentId;
    GUID ResourceManagerId;
};

struct TRANSACTION_ENLISTMENTS_INFORMATION {
public:
    uint NumberOfEnlistments;
    TRANSACTION_ENLISTMENT_PAIR EnlistmentPair;
};

struct TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {
public:
    TRANSACTION_ENLISTMENT_PAIR SuperiorEnlistmentPair;
};

struct RESOURCEMANAGER_BASIC_INFORMATION {
public:
    GUID ResourceManagerId;
    uint DescriptionLength;
    short Description;
};

struct RESOURCEMANAGER_COMPLETION_INFORMATION {
public:
    HANDLE IoCompletionPortHandle;
    ulong CompletionKey;
};

struct ENLISTMENT_BASIC_INFORMATION {
public:
    GUID EnlistmentId;
    GUID TransactionId;
    GUID ResourceManagerId;
};

struct ENLISTMENT_CRM_INFORMATION {
public:
    GUID CrmTransactionManagerId;
    GUID CrmResourceManagerId;
    GUID CrmEnlistmentId;
};

struct TRANSACTION_LIST_ENTRY {
public:
    GUID UOW;
};

struct TRANSACTION_LIST_INFORMATION {
public:
    uint NumberOfTransactions;
    TRANSACTION_LIST_ENTRY TransactionInformation;
};

struct KTMOBJECT_CURSOR {
public:
    GUID LastQuery;
    uint ObjectIdCount;
    GUID ObjectIds;
};

struct TP_POOL_STACK_INFORMATION {
public:
    ulong StackReserve;
    ulong StackCommit;
};

struct TP_CALLBACK_ENVIRON_V3 {
public:
    uint Version;
    PVOID Pool;
    PVOID CleanupGroup;
    PVOID CleanupGroupCancelCallback;
    PVOID RaceDll;
    PVOID ActivationContext;
    PVOID FinalizationCallback;
    uint Flags;
    TP_CALLBACK_PRIORITY CallbackPriority;
    uint Size;
};

struct SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
public:
    ulong ProcessorMask;
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    uchar offset;
    ulong Reserved;
};

struct SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
public:
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    uint Size;
    uchar info;
};

struct SYSTEM_CPU_SET_INFORMATION {
public:
    uint Size;
    CPU_SET_INFORMATION_TYPE Type;
    uint Id;
    ushort Group;
    uchar LogicalProcessorIndex;
    uchar CoreIndex;
    uchar LastLevelCacheIndex;
    uchar NumaNodeIndex;
    uchar EfficiencyClass;
    uchar AllFlags;
    uint Reserved;
    ulong AllocationTag;
};

struct VALENTW {
public:
    PVOID ve_valuename;
    uint ve_valuelen;
    uchar offset1;
    PVOID ve_valueptr;
    uint ve_type;
    uchar offset2;
};

struct ACCEL {
public:
    uchar fVirt;
    ushort key;
    ushort cmd;
};

struct ACCESSTIMEOUT {
public:
    uint cbSize;
    uint dwFlags;
    uint iTimeOutMSec;
};

struct ALTTABINFO {
public:
    uint cbSize;
    int cItems;
    int cColumns;
    int cRows;
    int iColFocus;
    int iRowFocus;
    int cxItem;
    int cyItem;
    POINT ptStart;
};

struct ANIMATIONINFO {
public:
    uint cbSize;
    int iMinAnimate;
};

struct AUDIODESCRIPTION {
public:
    uint cbSize;
    int Enabled;
    uint Locale;
};

struct BSMINFO {
public:
    uint cbSize;
    HANDLE hdesk;
    HANDLE hwnd;
    LUID luid;
};

struct CBT_CREATEWNDA {
public:
    HANDLE hwndInsertAfter;
};

struct CBT_CREATEWNDW {
public:
    HANDLE hwndInsertAfter;
};

struct CBTACTIVATESTRUCT {
public:
    int fMouse;
    HANDLE hWndActive;
};

struct CHANGEFILTERSTRUCT {
public:
    uint cbSize;
    uint ExtStatus;
};

struct CLIENTCREATESTRUCT {
public:
    HANDLE hWindowMenu;
    uint idFirstChild;
};

struct COMBOBOXINFO {
public:
    uint cbSize;
    RECT rcItem;
    RECT rcButton;
    uint stateButton;
    HANDLE hwndCombo;
    HANDLE hwndItem;
    HANDLE hwndList;
};

struct COMPAREITEMSTRUCT {
public:
    uint CtlType;
    uint CtlID;
    HANDLE hwndItem;
    uint itemID1;
    ulong itemData1;
    uint itemID2;
    ulong itemData2;
    uint dwLocaleId;
};

struct COPYDATASTRUCT {
public:
    ulong dwData;
    uint cbData;
};

struct CURSORINFO {
public:
    uint cbSize;
    uint flags;
    HANDLE hCursor;
    POINT ptScreenPos;
};

struct CURSORSHAPE {
public:
    int xHotSpot;
    int yHotSpot;
    int cx;
    int cy;
    int cbWidth;
    uchar Planes;
    uchar BitsPixel;
};

struct CWPRETSTRUCT {
public:
    PVOID lResult;
    PVOID lParam;
    PVOID wParam;
    uint message;
    HANDLE hwnd;
};

struct CWPSTRUCT {
public:
    PVOID lParam;
    PVOID wParam;
    uint message;
    HANDLE hwnd;
};

struct DEBUGHOOKINFO {
public:
    uint idThread;
    uint idThreadInstaller;
    PVOID lParam;
    PVOID wParam;
    int code;
};

struct DELETEITEMSTRUCT {
public:
    uint CtlType;
    uint CtlID;
    uint itemID;
    HANDLE hwndItem;
    ulong itemData;
};

struct DLGITEMTEMPLATE {
public:
    uint style;
    uint dwExtendedStyle;
    short x;
    short y;
    short cx;
    short cy;
    ushort id;
};

struct DLGTEMPLATE {
public:
    uint style;
    uint dwExtendedStyle;
    ushort cdit;
    short x;
    short y;
    short cx;
    short cy;
};

struct DRAWITEMSTRUCT {
public:
    uint CtlType;
    uint CtlID;
    uint itemID;
    uint itemAction;
    uint itemState;
    HANDLE hwndItem;
    HANDLE hDC;
    RECT rcItem;
    ulong itemData;
};

struct DRAWTEXTPARAMS {
public:
    uint cbSize;
    int iTabLength;
    int iLeftMargin;
    int iRightMargin;
    uint uiLengthDrawn;
};

struct DROPSTRUCT {
public:
    HANDLE hwndSource;
    HANDLE hwndSink;
    uint wFmt;
    ulong dwData;
    POINT ptDrop;
    uint dwControlData;
};

struct EVENTMSG {
public:
    uint message;
    uint paramL;
    uint paramH;
    uint time;
    HANDLE hwnd;
};

struct FILTERKEYS {
public:
    uint cbSize;
    uint dwFlags;
    uint iWaitMSec;
    uint iDelayMSec;
    uint iRepeatMSec;
    uint iBounceMSec;
};

struct FLASHWINFO {
public:
    uint cbSize;
    HANDLE hwnd;
    uint dwFlags;
    uint uCount;
    uint dwTimeout;
};

struct GESTURECONFIG {
public:
    uint dwID;
    uint dwWant;
    uint dwBlock;
};

struct GESTUREINFO {
public:
    uint cbSize;
    uint dwFlags;
    uint dwID;
    HANDLE hwndTarget;
    POINTS ptsLocation;
    uint dwInstanceID;
    uint dwSequenceID;
    ulong ullArguments;
    uint cbExtraArgs;
};

struct GESTURENOTIFYSTRUCT {
public:
    uint cbSize;
    uint dwFlags;
    HANDLE hwndTarget;
    POINTS ptsLocation;
    uint dwInstanceID;
};

struct GUITHREADINFO {
public:
    uint cbSize;
    uint flags;
    HANDLE hwndActive;
    HANDLE hwndFocus;
    HANDLE hwndCapture;
    HANDLE hwndMenuOwner;
    HANDLE hwndMoveSize;
    HANDLE hwndCaret;
    RECT rcCaret;
};

struct HARDWAREHOOKSTRUCT {
public:
    HANDLE hwnd;
    uint message;
    PVOID wParam;
    PVOID lParam;
};

struct HARDWAREINPUT {
public:
    uint uMsg;
    ushort wParamL;
    ushort wParamH;
};

struct HELPINFO {
public:
    uint cbSize;
    int iContextType;
    int iCtrlId;
    HANDLE hItemHandle;
    uint dwContextId;
    POINT MousePos;
};

struct HELPWININFOA {
public:
    int wStructSize;
    int x;
    int y;
    int dx;
    int dy;
    int wMax;
    char rgchMember;
};

struct HELPWININFOW {
public:
    int wStructSize;
    int x;
    int y;
    int dx;
    int dy;
    int wMax;
    short rgchMember;
};

struct HIGHCONTRASTW {
public:
    uint cbSize;
    uint dwFlags;
    string lpszDefaultScheme;
};

struct ICONINFO {
public:
    int fIcon;
    uint xHotspot;
    uint yHotspot;
    HANDLE hbmMask;
    HANDLE hbmColor;
};

struct ICONINFOEXW {
public:
    uint cbSize;
    int fIcon;
    uint xHotspot;
    uint yHotspot;
    HANDLE hbmMask;
    HANDLE hbmColor;
    ushort wResID;
    short szModName;
    short szResName;
};

struct ICONMETRICSW {
public:
    uint cbSize;
    int iHorzSpacing;
    int iVertSpacing;
    int iTitleWrap;
    LOGFONTW lfFont;
};

struct INPUT_INJECTION_VALUE {
public:
    ushort page;
    ushort usage;
    int value;
    ushort index;
};

struct INPUT_MESSAGE_SOURCE {
public:
    INPUT_MESSAGE_DEVICE_TYPE deviceType;
    INPUT_MESSAGE_ORIGIN_ID originId;
};

struct KBDLLHOOKSTRUCT {
public:
    uint vkCode;
    uint scanCode;
    uint flags;
    uint time;
    ulong dwExtraInfo;
};

struct KEYBDINPUT {
public:
    ushort wVk;
    ushort wScan;
    uint dwFlags;
    uint time;
    ulong dwExtraInfo;
};

struct LASTINPUTINFO {
public:
    uint cbSize;
    uint dwTime;
};

struct MDICREATESTRUCTW {
public:
    PVOID szClass;
    PVOID szTitle;
    HANDLE hOwner;
    int x;
    int y;
    int cx;
    int cy;
    uint style;
    PVOID lParam;
};

struct MDINEXTMENU {
public:
    HANDLE hmenuIn;
    HANDLE hmenuNext;
    HANDLE hwndNext;
};

struct MEASUREITEMSTRUCT {
public:
    uint CtlType;
    uint CtlID;
    uint itemID;
    uint itemWidth;
    uint itemHeight;
    ulong itemData;
};

struct MENUBARINFO {
public:
    uint cbSize;
    RECT rcBar;
    HANDLE hMenu;
    HANDLE hwndMenu;
    int Focused;
};

struct MENUGETOBJECTINFO {
public:
    uint dwFlags;
    uint uPos;
    HANDLE hmenu;
    PVOID riid;
    PVOID pvObj;
};

struct MENUINFO {
public:
    uint cbSize;
    uint fMask;
    uint dwStyle;
    uint cyMax;
    HANDLE hbrBack;
    uint dwContextHelpID;
    ulong dwMenuData;
};

struct MENUITEMINFOW {
public:
    uint cbSize;
    uint fMask;
    uint fType;
    uint fState;
    uint wID;
    HANDLE hSubMenu;
    HANDLE hbmpChecked;
    HANDLE hbmpUnchecked;
    ulong dwItemData;
    string dwTypeData;
    uint cch;
    HANDLE hbmpItem;
};

struct MENUITEMTEMPLATE {
public:
    ushort mtOption;
    ushort mtID;
    short mtString;
};

struct MENUITEMTEMPLATEHEADER {
public:
    ushort versionNumber;
    ushort offset;
};

struct MINIMIZEDMETRICS {
public:
    uint cbSize;
    int iWidth;
    int iHorzGap;
    int iVertGap;
    int iArrange;
};

struct MINMAXINFO {
public:
    POINT ptReserved;
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
};

struct MONITORINFO {
public:
    uint cbSize;
    RECT rcMonitor;
    RECT rcWork;
    uint dwFlags;
};

struct MOUSEHOOKSTRUCT {
public:
    POINT pt;
    HANDLE hwnd;
    uint wHitTestCode;
    ulong dwExtraInfo;
};

struct MOUSEHOOKSTRUCTEX : public MONITORINFO {
public:
    uint mouseData;
};

struct MOUSEKEYS {
public:
    uint cbSize;
    uint dwFlags;
    uint iMaxSpeed;
    uint iTimeToMaxSpeed;
    uint iCtrlSpeed;
    uint dwReserved1;
    uint dwReserved2;
};

struct MOUSEMOVEPOINT {
public:
    int x;
    int y;
    uint time;
    ulong dwExtraInfo;
};

struct MSG {
public:
    HANDLE hwnd;
    uint message;
    PVOID wParam;
    PVOID lParam;
    uint time;
    POINT pt;
    uint lPrivate;
};

struct MSGBOXPARAMSW {
public:
    uint cbSize;
    HANDLE hwndOwner;
    HANDLE hInstance;
    PVOID lpszText;
    PVOID lpszCaption;
    uint dwStyle;
    PVOID lpszIcon;
    uint dwContextHelpId;
    PVOID lpfnMsgBoxCallback;
    uint dwLanguageId;
};

struct MSLLHOOKSTRUCT {
public:
    POINT pt;
    uint mouseData;
    uint flags;
    uint time;
    ulong dwExtraInfo;
};

struct MULTIKEYHELPW {
public:
    short mkKeylist;
    short szKeyphrase;
};

struct NCCALCSIZE_PARAMS {
public:
    RECT rgrc;
    PVOID lppos;
};

struct NMHDR {
public:
    HANDLE hwndFrom;
    ulong idFrom;
    uint code;
};

struct NONCLIENTMETRICSW {
public:
    uint cbSize;
    int iBorderWidth;
    int iScrollWidth;
    int iScrollHeight;
    int iCaptionWidth;
    int iCaptionHeight;
    LOGFONTW lfCaptionFont;
    int iSmCaptionWidth;
    int iSmCaptionHeight;
    LOGFONTW lfSmCaptionFont;
    int iMenuWidth;
    int iMenuHeight;
    LOGFONTW lfMenuFont;
    LOGFONTW lfStatusFont;
    LOGFONTW lfMessageFont;
    int iPaddedBorderWidth;
};

struct PAINTSTRUCT {
public:
    HANDLE hdc;
    int fErase;
    RECT rcPaint;
    int fRestore;
    int fIncUpdate;
    uchar rgbReserved;
};

struct POINTER_DEVICE_CURSOR_INFO {
public:
    uint cursorId;
    POINTER_DEVICE_CURSOR_TYPE cursor;
};

struct POINTER_DEVICE_PROPERTY {
public:
    int logicalMin;
    int logicalMax;
    int physicalMin;
    int physicalMax;
    uint unit;
    uint unitExponent;
    ushort usagePageId;
    ushort usageId;
};

struct POINTER_INFO {
public:
    uint pointerType;
    uint pointerId;
    uint frameId;
    uint pointerFlags;
    HANDLE sourceDevice;
    HANDLE hwndTarget;
    POINT ptPixelLocation;
    POINT ptHimetricLocation;
    POINT ptPixelLocationRaw;
    POINT ptHimetricLocationRaw;
    uint dwTime;
    uint historyCount;
    int InputData;
    uint dwKeyStates;
    ulong PerformanceCount;
    POINTER_BUTTON_CHANGE_TYPE ButtonChangeType;
};

struct POINTER_PEN_INFO {
public:
    POINTER_INFO pointerInfo;
    uint penFlags;
    uint penMask;
    uint pressure;
    uint rotation;
    int tiltX;
    int tiltY;
};

struct POINTER_TOUCH_INFO {
public:
    POINTER_INFO pointerInfo;
    uint touchFlags;
    uint touchMask;
    RECT rcContact;
    RECT rcContactRaw;
    uint orientation;
    uint pressure;
};

struct POWERBROADCAST_SETTING {
public:
    GUID PowerSetting;
    uint DataLength;
    uchar Data;
};

struct RAWINPUTDEVICE {
public:
    ushort usUsagePage;
    ushort usUsage;
    uint dwFlags;
    HANDLE hwndTarget;
};

struct RAWINPUTDEVICELIST {
public:
    HANDLE hDevice;
    uint dwType;
};

struct RAWINPUTHEADER {
public:
    uint dwType;
    uint dwSize;
    HANDLE hDevice;
    PVOID wParam;
};

struct RID_DEVICE_INFO_HID {
public:
    uint dwVendorId;
    uint dwProductId;
    uint dwVersionNumber;
    ushort usUsagePage;
    ushort usUsage;
};

struct RID_DEVICE_INFO_KEYBOARD {
public:
    uint dwType;
    uint dwSubType;
    uint dwKeyboardMode;
    uint dwNumberOfFunctionKeys;
    uint dwNumberOfIndicators;
    uint dwNumberOfKeysTotal;
};

struct RID_DEVICE_INFO_MOUSE {
public:
    uint dwId;
    uint dwNumberOfButtons;
    uint dwSampleRate;
    int fHasHorizontalWheel;
};

struct SCROLLBARINFO {
public:
    uint cbSize;
    RECT rcScrollBar;
    int dxyLineButton;
    int xyThumbTop;
    int xyThumbBottom;
    int reserved;
};

struct SCROLLINFO {
public:
    uint cbSize;
    uint fMask;
    int nMin;
    int nMax;
    uint nPage;
    int nPos;
    int nTrackPos;
};

struct SERIALKEYSW {
public:
    uint cbSize;
    uint dwFlags;
    string lpszActivePort;
    string lpszPort;
    uint iBaudRate;
    uint iPortState;
    uint iActive;
};

struct SHELLHOOKINFO {
public:
    HANDLE hwnd;
    RECT rc;
};

struct SOUNDSENTRYW {
public:
    uint cbSize;
    uint dwFlags;
    uint iFSTextEffect;
    uint iFSTextEffectMSec;
    uint iFSTextEffectColorBits;
    uint iFSGrafEffect;
    uint iFSGrafEffectMSec;
    uint iFSGrafEffectColor;
    uint iWindowsEffect;
    uint iWindowsEffectMSec;
    string lpszWindowsEffectDLL;
    uint iWindowsEffectOrdinal;
};

struct STICKYKEYS {
public:
    uint cbSize;
    uint dwFlags;
};

struct STYLESTRUCT {
public:
    uint styleOld;
    uint styleNew;
};

struct TITLEBARINFO {
public:
    uint cbSize;
    RECT rcTitleBar;
};

struct TITLEBARINFOEX {
public:
    uint cbSize;
    RECT rcTitleBar;
};

struct TOGGLEKEYS {
public:
    uint cbSize;
    uint dwFlags;
};

struct TOUCH_HIT_TESTING_INPUT {
public:
    uint pointerId;
    POINT point;
    RECT boundingBox;
    RECT nonOccludedBoundingBox;
    uint orientation;
};

struct TOUCH_HIT_TESTING_PROXIMITY_EVALUATION {
public:
    ushort score;
    POINT adjustedPoint;
};

struct TOUCHINPUT {
public:
    int x;
    int y;
    HANDLE hSource;
    uint dwID;
    uint dwFlags;
    uint dwMask;
    uint dwTime;
    ulong dwExtraInfo;
    uint cxContact;
    uint cyContact;
};

struct TOUCHPREDICTIONPARAMETERS {
public:
    uint cbSize;
    uint dwLatency;
    uint dwSampleTime;
    uint bUseHWTimeStamp;
};

struct TPMPARAMS {
public:
    uint cbSize;
    RECT rcExclude;
};

struct TRACKMOUSEEVENT {
public:
    uint cbSize;
    uint dwFlags;
    HANDLE hwndTrack;
    uint dwHoverTime;
};

struct UPDATELAYEREDWINDOWINFO {
public:
    uint cbSize;
    HANDLE hdcDst;
    HANDLE hdcSrc;
    uint crKey;
    uint dwFlags;
};

struct USAGE_PROPERTIES {
public:
    ushort level;
    ushort page;
    ushort usage;
    int logicalMinimum;
    int logicalMaximum;
    ushort unit;
    ushort exponent;
    uchar count;
    int physicalMinimum;
    int physicalMaximum;
};

struct USEROBJECTFLAGS {
public:
    int fInherit;
    int fReserved;
    uint dwFlags;
};

struct WINDOWINFO {
public:
    uint cbSize;
    RECT rcWindow;
    RECT rcClient;
    uint dwStyle;
    uint dwExStyle;
    uint dwWindowStatus;
    uint cxWindowBorders;
    uint cyWindowBorders;
    ushort atomWindowType;
    ushort wCreatorVersion;
};

struct WINDOWPLACEMENT {
public:
    uint length;
    uint flags;
    uint showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT rcNormalPosition;
    RECT rcDevice;
};

struct WINDOWPOS {
public:
    HANDLE hwnd;
    HANDLE hwndInsertAfter;
    int x;
    int y;
    int cx;
    int cy;
    uint flags;
};

struct WTSSESSION_NOTIFICATION {
public:
    uint cbSize;
    uint dwSessionId;
};

struct RAWKEYBOARD {
public:
    ushort MakeCode;
    ushort Flags;
    ushort Reserved;
    ushort VKey;
    uint Message;
    uint ExtraInformation;
};

struct RAWHID {
public:
    uint dwSizeHid;
    uint dwCount;
    uchar bRawData;
};

struct RAWINPUT {
public:
    RAWINPUTHEADER header;
    RAWFORMAT data;
};

struct INPUT_TRANSFORM {
public:
    float _11;
    float _12;
    float _13;
    float _14;
    float _21;
    float _22;
    float _23;
    float _24;
    float _31;
    float _32;
    float _33;
    float _34;
    float _41;
    float _42;
    float _43;
    float _44;
};

struct MENUITEMINFO {
public:
    uint cbSize;
    uint fMask;
    uint fType;
    uint fState;
    uint wID;
    HANDLE hSubMenu;
    HANDLE hbmpChecked;
    HANDLE hbmpUnchecked;
    uint dwItemData;
    string dwTypeData;
    uint cch;
};

struct INPUT {
public:
    uint type;
    INPUT_TYPE in;
};

#endif // __clang__
