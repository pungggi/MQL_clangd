/**
 * Auto-generated MQL5 Standard Library stubs for clangd
 * Header: generated_stubs
 * Generated: 2026-02-02T21:41:15.341Z
 * 
 * DO NOT EDIT - This file is auto-generated by mql-stub-generator
 */

#pragma once

#ifdef __clang__

// Forward declarations
class CArray;
class CArrayChar;
class CArrayColor;
class CArrayDatetime;
class CArrayDouble;
class CArrayFloat;
class CArrayInt;
class CArrayLong;
class CArrayObj;
class CArrayShort;
class CArrayString;
class CArrayUChar;
class CArrayUInt;
class CArrayULong;
class CArrayUShort;
class CList;
class CTree;
class CTreeNode;
class CCanvas;
struct BitmapHeader;
class CChartCanvas;
class CHistogramChart;
class CLineChart;
class CPieChart;
class CDXBox;
class CDXVertexBuffer;
class CDXIndexBuffer;
class CDXDispatcher;
struct DXColor;
struct DXPlane;
struct DXVector2;
struct DXVector3;
struct DXVector4;
struct DXMatrix;
struct DXQuaternion;
struct DViewport;
class CDXMesh;
class CDXSurface;
struct OBJFaceType;
struct GRADIENT_COLOR;
struct GRADIENT_SIZE;
class CFlameCanvas;
class CChartObject;
class CChartObjectPanel;
class CChartObjectArrow;
class CChartObjectArrowThumbUp;
class CChartObjectArrowThumbDown;
class CChartObjectArrowUp;
class CChartObjectArrowDown;
class CChartObjectArrowStop;
class CChartObjectArrowCheck;
class CChartObjectArrowLeftPrice;
class CChartObjectArrowRightPrice;
class CChartObjectBitmap;
class CChartObjectBmpLabel;
class CChartObjectChannel;
class CChartObjectStdDevChannel;
class CChartObjectRegression;
class CChartObjectPitchfork;
class CChartObjectElliottWave3;
class CChartObjectElliottWave5;
class CChartObjectFibo;
class CChartObjectFiboTimes;
class CChartObjectFiboFan;
class CChartObjectFiboArc;
class CChartObjectFiboChannel;
class CChartObjectFiboExpansion;
class CChartObjectGannLine;
class CChartObjectGannFan;
class CChartObjectGannGrid;
class CChartObjectVLine;
class CChartObjectHLine;
class CChartObjectTrend;
class CChartObjectTrendByAngle;
class CChartObjectCycles;
class CChartObjectRectangle;
class CChartObjectTriangle;
class CChartObjectEllipse;
class CChartObjectText;
class CChartObjectLabel;
class CChartObjectEdit;
class CChartObjectButton;
class CChartObjectRectLabel;
class CChartObjectSubChart;
class CChart;
class CBmpButton;
class CButton;
class CCheckBox;
class CCheckGroup;
class CComboBox;
class CDateDropList;
class CDatePicker;
class CDialog;
class CAppDialog;
class CEdit;
class CLabel;
class CListView;
class CPanel;
class CPicture;
class CRadioButton;
class CRadioGroup;
struct CPoint;
struct CSize;
struct CRect;
class CScroll;
class CScrollV;
class CScrollH;
class CSpinEdit;
class CWnd;
class CDragWnd;
class CWndClient;
class CWndContainer;
class CWndObj;
class CExpertBase;
class CExpertMoney;
class CExpertSignal;
class CExpertTrade;
class CExpertTrailing;
class CMoneyFixedLot;
class CMoneyFixedMargin;
class CMoneyFixedRisk;
class CMoneyNone;
class CMoneySizeOptimized;
class CSignalAC;
class CSignalAMA;
class CSignalAO;
class CSignalBearsPower;
class CSignalBullsPower;
class CSignalCCI;
class CSignalDEMA;
class CSignalDeM;
class CSignalEnvelopes;
class CSignalFrAMA;
class CSignalITF;
class CSignalMA;
class CSignalMACD;
class CSignalRSI;
class CSignalRVI;
class CSignalSAR;
class CSignalStoch;
class CSignalTEMA;
class CSignalTriX;
class CSignalWPR;
class CTrailingFixedPips;
class CTrailingMA;
class CTrailingNone;
class CTrailingPSAR;
class CFile;
class CFileBin;
struct BITMAPFILEHEADER;
struct BITMAPINFOHEADER;
class CFileBMP;
class CFilePipe;
class CFileTxt;
struct Slot;
struct Introsort;
class CPrimeGenerator;
class CLinkedListNode;
class CAxis;
class CColorGenerator;
struct CPoint2D;
class CCurve;
class CiAC;
class CiAlligator;
class CiAO;
class CiFractals;
class CiGator;
class CiBWMFI;
class CiCustom;
class CIndicatorBuffer;
class CIndicator;
class CIndicators;
class CiATR;
class CiBearsPower;
class CiBullsPower;
class CiCCI;
class CiChaikin;
class CiDeMarker;
class CiForce;
class CiMACD;
class CiMomentum;
class CiOsMA;
class CiRSI;
class CiRVI;
class CiStochastic;
class CiWPR;
class CiTriX;
class CSeries;
class CDoubleBuffer;
class CPriceSeries;
class COpenBuffer;
class CiOpen;
class CHighBuffer;
class CiHigh;
class CLowBuffer;
class CiLow;
class CCloseBuffer;
class CiClose;
class CSpreadBuffer;
class CiSpread;
class CTimeBuffer;
class CiTime;
class CTickVolumeBuffer;
class CiTickVolume;
class CRealVolumeBuffer;
class CiRealVolume;
class CiADX;
class CiADXWilder;
class CiBands;
class CiEnvelopes;
class CiIchimoku;
class CiMA;
class CiSAR;
class CiStdDev;
class CiDEMA;
class CiTEMA;
class CiFrAMA;
class CiAMA;
class CiVIDyA;
class CiAD;
class CiMFI;
class CiOBV;
class CiVolumes;
class CDictionary_Obj_Obj;
class CDictionary_String_Obj;
class CDictionary_Obj_Double;
class ICondition;
class CSingleCondition;
class CFuzzyCondition;
class CConditions;
class IParsableRule;
class CGenericFuzzyRule;
class CMamdaniFuzzyRule;
class CSugenoFuzzyRule;
class CFuzzyTerm;
class CFuzzyVariable;
class CGenericFuzzySystem;
class INamedValue;
class INamedVariable;
class CNamedVariableImpl;
class CNamedValueImpl;
class CNameHelper;
class CMamdaniFuzzySystem;
class IMembershipFunction;
class CNormalCombinationMembershipFunction;
class CGeneralizedBellShapedMembershipFunction;
class CS_ShapedMembershipFunction;
class CZ_ShapedMembershipFunction;
class CP_ShapedMembershipFunction;
class CSigmoidalMembershipFunction;
class CProductTwoSigmoidalMembershipFunctions;
class CDifferencTwoSigmoidalMembershipFunction;
class CTrapezoidMembershipFunction;
class CNormalMembershipFunction;
class CTriangularMembershipFunction;
class CConstantMembershipFunction;
class CCompositeMembershipFunction;
class IExpression;
class CLexem;
class CConditionExpression;
class CKeywordLexem;
class CVarLexem;
class IAltLexem;
class CTermLexem;
class CRuleParser;
class CSugenoFuzzySystem;
class ISugenoFunction;
class CLinearSugenoFunction;
class CSugenoVariable;
class COpenCL;
class CString;
class CAccountInfo;
class CDealInfo;
class CHistoryOrderInfo;
class COrderInfo;
class CPositionInfo;
class CSymbolInfo;
class CTerminalInfo;
class CTrade;
struct BY_HANDLE_FILE_INFORMATION;
struct CREATEFILE2_EXTENDED_PARAMETERS;
struct FILE_ATTRIBUTE_DATA;
struct FIND_STREAM_DATA;
struct FIND_DATAW;
struct ENUMUILANG;
struct WIN32_MEMORY_RANGE_ENTRY;
struct PROCESS_INFORMATION;
struct STARTUPINFOW;
struct MEMORY_PRIORITY_INFORMATION;
struct THREAD_POWER_THROTTLING_STATE;
struct APP_MEMORY_INFORMATION;
struct PROCESS_MEMORY_EXHAUSTION_INFO;
struct PROCESS_POWER_THROTTLING_STATE;
struct PROCESS_PROTECTION_LEVEL_INFORMATION;
struct DUMMYSTRUCTNAME;
struct MEMORYSTATUSEX;
struct SYSTEM_INFO;
struct ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
struct ACTCTX_SECTION_KEYED_DATA;
struct ACTCTX_SECTION_KEYED_DATA_2600;
struct ACTCTXW;
struct ACTIVATION_CONTEXT_BASIC_INFORMATION;
struct DCB;
struct COMMCONFIG;
struct COMMPROP;
struct COMMTIMEOUTS;
struct COMSTAT;
struct COPYFILE2_EXTENDED_PARAMETERS;
struct EVENTLOG_FULL_INFORMATION;
struct FILE_ALIGNMENT_INFO;
struct FILE_ALLOCATION_INFO;
struct FILE_ATTRIBUTE_TAG_INFO;
struct FILE_BASIC_INFO;
struct FILE_COMPRESSION_INFO;
struct FILE_DISPOSITION_INFO;
struct FILE_DISPOSITION_INFO_EX;
struct FILE_END_OF_FILE_INFO;
struct FILE_FULL_DIR_INFO;
struct FILE_ID_BOTH_DIR_INFO;
struct FILE_ID_EXTD_DIR_INFO;
struct FILE_ID_INFO;
struct FILE_IO_PRIORITY_HINT_INFO;
struct FILE_NAME_INFO;
struct FILE_STANDARD_INFO;
struct FILE_STORAGE_INFO;
struct FILE_STREAM_INFO;
struct HW_PROFILE_INFOW;
struct JIT_DEBUG_INFO;
struct MEMORYSTATUS;
struct OFSTRUCT;
struct OPERATION_END_PARAMETERS;
struct OPERATION_START_PARAMETERS;
struct SYSTEM_POWER_STATUS;
struct UMS_SCHEDULER_STARTUP_INFO;
struct WIN32_STREAM_ID;
struct UMS_SYSTEM_THREAD_INFORMATION;
struct FILE_ID_DESCRIPTOR;
struct SYSTEMTIME;
struct REASON_CONTEXT;
struct OVERLAPPED;
struct LDT_ENTRY;
struct GUID;
struct FILETIME;
struct POINT;
struct POINTL;
struct POINTS;
struct RECT;
struct RECTL;
struct SIZE;
struct FILE_INFO;
struct CLAIM_SECURITY_ATTRIBUTE_V1;
struct CLAIM_SECURITY_ATTRIBUTES_INFORMATION;
struct ABC;
struct ABCFLOAT;
struct AXISINFOW;
struct AXESLISTW;
struct BITMAP;
struct BITMAPCOREHEADER;
struct RGBTRIPLE;
struct BITMAPCOREINFO;
struct RGBQUAD;
struct BITMAPINFO;
struct CIEXYZ;
struct CIEXYZTRIPLE;
struct BITMAPV4HEADER;
struct BITMAPV5HEADER;
struct BLENDFUNCTION;
struct FONTSIGNATURE;
struct CHARSETINFO;
struct COLORADJUSTMENT;
struct DESIGNVECTOR;
struct DIBSECTION;
struct DISPLAY_DEVICEA;
struct DISPLAY_DEVICEW;
struct DISPLAYCONFIG_2DREGION;
struct DISPLAYCONFIG_DEVICE_INFO_HEADER;
struct DISPLAYCONFIG_ADAPTER_NAME;
struct DISPLAYCONFIG_DESKTOP_IMAGE_INFO;
struct DISPLAYCONFIG_PATH_SOURCE_INFO;
struct DISPLAYCONFIG_RATIONAL;
struct DISPLAYCONFIG_PATH_TARGET_INFO;
struct DISPLAYCONFIG_PATH_INFO;
struct DISPLAYCONFIG_SDR_WHITE_LEVEL;
struct DISPLAYCONFIG_SOURCE_DEVICE_NAME;
struct DISPLAYCONFIG_SOURCE_MODE;
struct DISPLAYCONFIG_TARGET_BASE_TYPE;
struct DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS;
struct DISPLAYCONFIG_TARGET_DEVICE_NAME;
struct DISPLAYCONFIG_VIDEO_SIGNAL_INFO;
struct DISPLAYCONFIG_TARGET_MODE;
struct DISPLAYCONFIG_TARGET_PREFERRED_MODE;
struct DOCINFOW;
struct DRAWPATRECT;
struct EMR;
struct EMRABORTPATH;
struct XFORM;
struct EMRALPHABLEND;
struct EMRANGLEARC;
struct EMRARC;
struct EMRBITBLT;
struct EMRCOLORCORRECTPALETTE;
struct EMRCOLORMATCHTOTARGET;
struct LOGBRUSH;
struct EMRCREATEBRUSHINDIRECT;
struct LOGCOLORSPACEW;
struct EMRCREATECOLORSPACEW;
struct EMRCREATEDIBPATTERNBRUSHPT;
struct EMRCREATEMONOBRUSH;
struct LOGPALETTE;
struct LOGPEN;
struct EMRCREATEPALETTE;
struct EMRCREATEPEN;
struct EMRELLIPSE;
struct EMREOF;
struct EMREXCLUDECLIPRECT;
struct LOGFONTW;
struct PANOSE;
struct EXTLOGFONTW;
struct EMREXTCREATEFONTINDIRECTW;
struct EXTLOGPEN;
struct EMREXTCREATEPEN;
struct EMREXTESCAPE;
struct EMREXTFLOODFILL;
struct EMREXTSELECTCLIPRGN;
struct EMRTEXT;
struct EMREXTTEXTOUTA;
struct EMRFILLPATH;
struct EMRFILLRGN;
struct EMRFORMAT;
struct EMRFRAMERGN;
struct EMRGDICOMMENT;
struct EMRGLSBOUNDEDRECORD;
struct EMRGLSRECORD;
struct PIXELFORMATDESCRIPTOR;
struct TRIVERTEX;
struct EMRGRADIENTFILL;
struct EMRINVERTRGN;
struct EMRLINETO;
struct EMRMASKBLT;
struct EMRMODIFYWORLDTRANSFORM;
struct EMRNAMEDESCAPE;
struct EMROFFSETCLIPRGN;
struct EMRPIXELFORMAT;
struct EMRPLGBLT;
struct EMRPOLYDRAW;
struct EMRPOLYDRAW16;
struct EMRPOLYLINE;
struct EMRPOLYLINE16;
struct EMRPOLYPOLYLINE;
struct EMRPOLYPOLYLINE16;
struct EMRPOLYTEXTOUTW;
struct EMRRESIZEPALETTE;
struct EMRRESTOREDC;
struct EMRROUNDRECT;
struct EMRSCALEVIEWPORTEXTEX;
struct EMRSELECTCLIPPATH;
struct EMRSELECTOBJECT;
struct EMRSELECTPALETTE;
struct EMRSETARCDIRECTION;
struct EMRSETBKCOLOR;
struct EMRSETCOLORADJUSTMENT;
struct EMRSETCOLORSPACE;
struct EMRSETDIBITSTODEVICE;
struct EMRSETICMPROFILE;
struct EMRSETMAPPERFLAGS;
struct EMRSETMITERLIMIT;
struct PALETTEENTRY;
struct EMRSETPALETTEENTRIES;
struct EMRSETPIXELV;
struct EMRSETVIEWPORTEXTEX;
struct EMRSETVIEWPORTORGEX;
struct EMRSETWORLDTRANSFORM;
struct EMRSTRETCHBLT;
struct EMRSTRETCHDIBITS;
struct EMRTRANSPARENTBLT;
struct ENHMETAHEADER;
struct ENHMETARECORD;
struct ENUMLOGFONTEXW;
struct ENUMLOGFONTEXDVW;
struct ENUMLOGFONTW;
struct NEWTEXTMETRICW;
struct NEWTEXTMETRICEXW;
struct ENUMTEXTMETRICW;
struct FIXED;
struct POINTFLOAT;
struct GCP_RESULTSW;
struct GLYPHMETRICS;
struct GLYPHMETRICSFLOAT;
struct WCRANGE;
struct GLYPHSET;
struct GRADIENT_RECT;
struct GRADIENT_TRIANGLE;
struct HANDLETABLE;
struct KERNINGPAIR;
struct LAYERPLANEDESCRIPTOR;
struct LOCALESIGNATURE;
struct MAT2;
struct METAFILEPICT;
struct METAHEADER;
struct METARECORD;
struct TEXTMETRICW;
struct OUTLINETEXTMETRICW;
struct PELARRAY;
struct POINTFX;
struct POLYTEXTW;
struct PSFEATURE_CUSTPAPER;
struct PSFEATURE_OUTPUT;
struct PSINJECTDATA;
struct RASTERIZER_STATUS;
struct RGNDATAHEADER;
struct RGNDATA;
struct TTPOLYCURVE;
struct TTPOLYGONHEADER;
struct DEVMODEW;
struct WGLSWAP;
struct DISPLAYCONFIG_MODE_INFO;
struct PROCESSOR_NUMBER;
struct GROUP_AFFINITY;
struct FLOAT128;
struct LARGE_INTEGER;
struct ULARGE_INTEGER;
struct LUID;
struct LIST_ENTRY;
struct SINGLE_LIST_ENTRY;
struct LIST_ENTRY32;
struct LIST_ENTRY64;
struct OBJECTID;
struct M128A;
struct XSAVE_FORMAT;
struct XSAVE_AREA_HEADER;
struct XSAVE_AREA;
struct XSTATE_CONTEXT;
struct SCOPE_TABLE_AMD64;
struct UNWIND_HISTORY_TABLE_ENTRY;
struct UNWIND_HISTORY_TABLE;
struct SCOPE_TABLE_ARM64;
struct NEON128;
struct DISPATCHER_CONTEXT;
struct KNONVOLATILE_CONTEXT_POINTERS;
struct SCOPE_TABLE_ARM;
struct DISPATCHER_CONTEXT_ARM64;
struct KNONVOLATILE_CONTEXT_POINTERS_ARM64;
struct FLOATING_SAVE_AREA;
struct CONTEXT;
struct WOW64_FLOATING_SAVE_AREA;
struct WOW64_CONTEXT;
struct WOW64_LDT_ENTRY;
struct WOW64_DESCRIPTOR_TABLE_ENTRY;
struct EXCEPTION_RECORD;
struct EXCEPTION_RECORD32;
struct EXCEPTION_RECORD64;
struct EXCEPTION_POINTERS;
struct GENERIC_MAPPING;
struct LUID_AND_ATTRIBUTES;
struct SID_IDENTIFIER_AUTHORITY;
struct SID;
struct SID_AND_ATTRIBUTES;
struct SID_AND_ATTRIBUTES_HASH;
struct ACL;
struct ACE_HEADER;
struct ACCESS_ALLOWED_ACE;
struct ACCESS_DENIED_ACE;
struct SYSTEM_AUDIT_ACE;
struct SYSTEM_ALARM_ACE;
struct SYSTEM_RESOURCE_ATTRIBUTE_ACE;
struct SYSTEM_SCOPED_POLICY_ID_ACE;
struct SYSTEM_MANDATORY_LABEL_ACE;
struct SYSTEM_PROCESS_TRUST_LABEL_ACE;
struct SYSTEM_ACCESS_FILTER_ACE;
struct ACCESS_ALLOWED_OBJECT_ACE;
struct ACCESS_DENIED_OBJECT_ACE;
struct SYSTEM_AUDIT_OBJECT_ACE;
struct SYSTEM_ALARM_OBJECT_ACE;
struct ACCESS_ALLOWED_CALLBACK_ACE;
struct ACCESS_DENIED_CALLBACK_ACE;
struct SYSTEM_AUDIT_CALLBACK_ACE;
struct SYSTEM_ALARM_CALLBACK_ACE;
struct ACCESS_ALLOWED_CALLBACK_OBJECT_ACE;
struct ACCESS_DENIED_CALLBACK_OBJECT_ACE;
struct SYSTEM_AUDIT_CALLBACK_OBJECT_ACE;
struct SYSTEM_ALARM_CALLBACK_OBJECT_ACE;
struct ACL_REVISION_INFORMATION;
struct ACL_SIZE_INFORMATION;
struct SECURITY_DESCRIPTOR_RELATIVE;
struct SECURITY_DESCRIPTOR;
struct SECURITY_OBJECT_AI_PARAMS;
struct OBJECT_TYPE_LIST;
struct PRIVILEGE_SET;
struct ACCESS_REASONS;
struct SE_SECURITY_DESCRIPTOR;
struct SE_ACCESS_REQUEST;
struct SE_ACCESS_REPLY;
struct TOKEN_USER;
struct SE_TOKEN_USER;
struct TOKEN_GROUPS;
struct TOKEN_PRIVILEGES;
struct TOKEN_OWNER;
struct TOKEN_PRIMARY_GROUP;
struct TOKEN_DEFAULT_DACL;
struct TOKEN_USER_CLAIMS;
struct TOKEN_DEVICE_CLAIMS;
struct TOKEN_GROUPS_AND_PRIVILEGES;
struct TOKEN_LINKED_TOKEN;
struct TOKEN_ELEVATION;
struct TOKEN_MANDATORY_LABEL;
struct TOKEN_MANDATORY_POLICY;
struct TOKEN_ACCESS_INFORMATION;
struct TOKEN_AUDIT_POLICY;
struct TOKEN_SOURCE;
struct TOKEN_STATISTICS;
struct TOKEN_CONTROL;
struct TOKEN_ORIGIN;
struct TOKEN_APPCONTAINER_INFORMATION;
struct TOKEN_SID_INFORMATION;
struct TOKEN_BNO_ISOLATION_INFORMATION;
struct CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE;
struct CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;
struct CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1;
struct Attribute;
struct SECURITY_QUALITY_OF_SERVICE;
struct SE_IMPERSONATION_STATE;
struct SECURITY_CAPABILITIES;
struct JOB_SET_ARRAY;
struct EXCEPTION_REGISTRATION_RECORD;
struct NT_TIB;
struct UMS_CREATE_THREAD_ATTRIBUTES;
struct WOW64_ARCHITECTURE_INFORMATION;
struct QUOTA_LIMITS;
struct QUOTA_LIMITS_EX;
struct IO_COUNTERS;
struct JOBOBJECT_BASIC_ACCOUNTING_INFORMATION;
struct JOBOBJECT_BASIC_LIMIT_INFORMATION;
struct JOBOBJECT_EXTENDED_LIMIT_INFORMATION;
struct JOBOBJECT_BASIC_PROCESS_ID_LIST;
struct JOBOBJECT_BASIC_UI_RESTRICTIONS;
struct JOBOBJECT_SECURITY_LIMIT_INFORMATION;
struct JOBOBJECT_END_OF_JOB_TIME_INFORMATION;
struct JOBOBJECT_ASSOCIATE_COMPLETION_PORT;
struct JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;
struct JOBOBJECT_JOBSET_INFORMATION;
struct JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION;
struct JOBOBJECT_LIMIT_VIOLATION_INFORMATION;
struct JOBOBJECT_NET_RATE_CONTROL_INFORMATION;
struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE;
struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2;
struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3;
struct JOBOBJECT_IO_ATTRIBUTION_STATS;
struct JOBOBJECT_IO_ATTRIBUTION_INFORMATION;
struct SILOOBJECT_BASIC_INFORMATION;
struct SERVERSILO_BASIC_INFORMATION;
struct CACHE_DESCRIPTOR;
struct ProcessorCore;
struct PROCESSOR_RELATIONSHIP;
struct NUMA_NODE_RELATIONSHIP;
struct CACHE_RELATIONSHIP;
struct PROCESSOR_GROUP_INFO;
struct GROUP_RELATIONSHIP;
struct SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION;
struct XSTATE_FEATURE;
struct XSTATE_CONFIGURATION;
struct MEMORY_BASIC_INFORMATION;
struct MEMORY_BASIC_INFORMATION32;
struct MEMORY_BASIC_INFORMATION64;
struct CFG_CALL_TARGET_INFO;
struct MEM_ADDRESS_REQUIREMENTS;
struct ENCLAVE_CREATE_INFO_SGX;
struct ENCLAVE_INIT_INFO_SGX;
struct ENCLAVE_CREATE_INFO_VBS;
struct ENCLAVE_INIT_INFO_VBS;
struct FILE_ID_128;
struct FILE_NOTIFY_INFORMATION;
struct FILE_NOTIFY_EXTENDED_INFORMATION;
struct GenericReparseBuffer;
struct SCRUB_DATA_INPUT;
struct SCRUB_PARITY_EXTENT;
struct SCRUB_PARITY_EXTENT_DATA;
struct SCRUB_DATA_OUTPUT;
struct SHARED_VIRTUAL_DISK_SUPPORT;
struct NETWORK_APP_INSTANCE_EA;
struct CM_POWER_DATA;
struct POWER_USER_PRESENCE;
struct POWER_SESSION_CONNECT;
struct POWER_SESSION_TIMEOUTS;
struct POWER_SESSION_RIT_STATE;
struct POWER_SESSION_WINLOGON;
struct POWER_IDLE_RESILIENCY;
struct POWER_MONITOR_INVOCATION;
struct RESUME_PERFORMANCE;
struct APPLICATIONLAUNCH_SETTING_VALUE;
struct POWER_PLATFORM_INFORMATION;
struct POWER_ACTION_POLICY;
struct SYSTEM_POWER_LEVEL;
struct SYSTEM_POWER_POLICY;
struct PROCESSOR_POWER_POLICY_INFO;
struct PROCESSOR_POWER_POLICY;
struct ADMINISTRATOR_POWER_POLICY;
struct HIBERFILE_BUCKET;
struct IMAGE_DOS_HEADER;
struct IMAGE_OS2_HEADER;
struct IMAGE_VXD_HEADER;
struct IMAGE_FILE_HEADER;
struct IMAGE_DATA_DIRECTORY;
struct IMAGE_OPTIONAL_HEADER32;
struct IMAGE_ROM_OPTIONAL_HEADER;
struct IMAGE_OPTIONAL_HEADER64;
struct IMAGE_NT_HEADERS64;
struct IMAGE_NT_HEADERS32;
struct IMAGE_ROM_HEADERS;
struct ANON_OBJECT_HEADER;
struct ANON_OBJECT_HEADER_V2;
struct ANON_OBJECT_HEADER_BIGOBJ;
struct IMAGE_SECTION_HEADER;
struct IMAGE_SYMBOL;
struct IMAGE_SYMBOL_EX;
struct IMAGE_AUX_SYMBOL_TOKEN_DEF;
struct IMAGE_LINENUMBER;
struct IMAGE_BASE_RELOCATION;
struct IMAGE_ARCHIVE_MEMBER_HEADER;
struct IMAGE_EXPORT_DIRECTORY;
struct IMAGE_IMPORT_BY_NAME;
struct IMAGE_THUNK_DATA64;
struct IMAGE_THUNK_DATA32;
struct IMAGE_BOUND_IMPORT_DESCRIPTOR;
struct IMAGE_BOUND_FORWARDER_REF;
struct IMAGE_RESOURCE_DIRECTORY;
struct IMAGE_RESOURCE_DIRECTORY_STRING;
struct IMAGE_RESOURCE_DIR_STRING_U;
struct IMAGE_RESOURCE_DATA_ENTRY;
struct IMAGE_LOAD_CONFIG_CODE_INTEGRITY;
struct IMAGE_DYNAMIC_RELOCATION_TABLE;
struct IMAGE_DYNAMIC_RELOCATION32;
struct IMAGE_DYNAMIC_RELOCATION64;
struct IMAGE_DYNAMIC_RELOCATION32_V2;
struct IMAGE_DYNAMIC_RELOCATION64_V2;
struct IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER;
struct IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER;
struct IMAGE_LOAD_CONFIG_DIRECTORY32;
struct IMAGE_LOAD_CONFIG_DIRECTORY64;
struct IMAGE_HOT_PATCH_INFO;
struct IMAGE_HOT_PATCH_BASE;
struct IMAGE_HOT_PATCH_HASHES;
struct IMAGE_CE_RUNTIME_FUNCTION_ENTRY;
struct IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY;
struct IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY;
struct IMAGE_ENCLAVE_CONFIG32;
struct IMAGE_ENCLAVE_CONFIG64;
struct IMAGE_ENCLAVE_IMPORT;
struct IMAGE_DEBUG_DIRECTORY;
struct IMAGE_COFF_SYMBOLS_HEADER;
struct FPO_DATA;
struct IMAGE_DEBUG_MISC;
struct IMAGE_FUNCTION_ENTRY;
struct IMAGE_SEPARATE_DEBUG_HEADER;
struct NON_PAGED_DEBUG_INFO;
struct IMAGE_ARCHITECTURE_HEADER;
struct IMAGE_ARCHITECTURE_ENTRY;
struct SLIST_ENTRY;
struct RTL_BARRIER;
struct MESSAGE_RESOURCE_ENTRY;
struct MESSAGE_RESOURCE_BLOCK;
struct MESSAGE_RESOURCE_DATA;
struct OSVERSIONINFOW;
struct OSVERSIONINFOEXW;
struct NV_MEMORY_RANGE;
struct CORRELATION_VECTOR;
struct CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG;
struct IMAGE_POLICY_ENTRY;
struct IMAGE_POLICY_METADATA;
struct RTL_CRITICAL_SECTION_DEBUG;
struct RTL_CRITICAL_SECTION;
struct RTL_SRWLOCK;
struct RTL_CONDITION_VARIABLE;
struct HEAP_OPTIMIZE_RESOURCES_INFORMATION;
struct ACTIVATION_CONTEXT_QUERY_INDEX;
struct ASSEMBLY_FILE_DETAILED_INFORMATION;
struct ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;
struct ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;
struct COMPATIBILITY_CONTEXT_ELEMENT;
struct ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;
struct SUPPORTED_OS_INFO;
struct ACTIVATION_CONTEXT_DETAILED_INFORMATION;
struct HARDWARE_COUNTER_DATA;
struct PERFORMANCE_DATA;
struct EVENTLOGRECORD;
struct TAPE_ERASE;
struct TAPE_PREPARE;
struct TAPE_WRITE_MARKS;
struct TAPE_GET_POSITION;
struct TAPE_SET_POSITION;
struct TAPE_GET_DRIVE_PARAMETERS;
struct TAPE_SET_DRIVE_PARAMETERS;
struct TAPE_GET_MEDIA_PARAMETERS;
struct TAPE_SET_MEDIA_PARAMETERS;
struct TAPE_CREATE_PARTITION;
struct TAPE_WMI_OPERATIONS;
struct TRANSACTION_BASIC_INFORMATION;
struct TRANSACTIONMANAGER_BASIC_INFORMATION;
struct TRANSACTIONMANAGER_LOG_INFORMATION;
struct TRANSACTIONMANAGER_LOGPATH_INFORMATION;
struct TRANSACTIONMANAGER_RECOVERY_INFORMATION;
struct TRANSACTIONMANAGER_OLDEST_INFORMATION;
struct TRANSACTION_PROPERTIES_INFORMATION;
struct TRANSACTION_BIND_INFORMATION;
struct TRANSACTION_ENLISTMENT_PAIR;
struct TRANSACTION_ENLISTMENTS_INFORMATION;
struct TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;
struct RESOURCEMANAGER_BASIC_INFORMATION;
struct RESOURCEMANAGER_COMPLETION_INFORMATION;
struct ENLISTMENT_BASIC_INFORMATION;
struct ENLISTMENT_CRM_INFORMATION;
struct TRANSACTION_LIST_ENTRY;
struct TRANSACTION_LIST_INFORMATION;
struct KTMOBJECT_CURSOR;
struct TP_POOL_STACK_INFORMATION;
struct TP_CALLBACK_ENVIRON_V3;
struct SYSTEM_LOGICAL_PROCESSOR_INFORMATION;
struct SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;
struct SYSTEM_CPU_SET_INFORMATION;
struct VALENTW;
struct ACCEL;
struct ACCESSTIMEOUT;
struct ALTTABINFO;
struct ANIMATIONINFO;
struct AUDIODESCRIPTION;
struct BSMINFO;
struct CBT_CREATEWNDA;
struct CBT_CREATEWNDW;
struct CBTACTIVATESTRUCT;
struct CHANGEFILTERSTRUCT;
struct CLIENTCREATESTRUCT;
struct COMBOBOXINFO;
struct COMPAREITEMSTRUCT;
struct COPYDATASTRUCT;
struct CURSORINFO;
struct CURSORSHAPE;
struct CWPRETSTRUCT;
struct CWPSTRUCT;
struct DEBUGHOOKINFO;
struct DELETEITEMSTRUCT;
struct DLGITEMTEMPLATE;
struct DLGTEMPLATE;
struct DRAWITEMSTRUCT;
struct DRAWTEXTPARAMS;
struct DROPSTRUCT;
struct EVENTMSG;
struct FILTERKEYS;
struct FLASHWINFO;
struct GESTURECONFIG;
struct GESTUREINFO;
struct GESTURENOTIFYSTRUCT;
struct GUITHREADINFO;
struct HARDWAREHOOKSTRUCT;
struct HARDWAREINPUT;
struct HELPINFO;
struct HELPWININFOA;
struct HELPWININFOW;
struct HIGHCONTRASTW;
struct ICONINFO;
struct ICONINFOEXW;
struct ICONMETRICSW;
struct INPUT_INJECTION_VALUE;
struct INPUT_MESSAGE_SOURCE;
struct KBDLLHOOKSTRUCT;
struct KEYBDINPUT;
struct LASTINPUTINFO;
struct MDICREATESTRUCTW;
struct MDINEXTMENU;
struct MEASUREITEMSTRUCT;
struct MENUBARINFO;
struct MENUGETOBJECTINFO;
struct MENUINFO;
struct MENUITEMINFOW;
struct MENUITEMTEMPLATE;
struct MENUITEMTEMPLATEHEADER;
struct MINIMIZEDMETRICS;
struct MINMAXINFO;
struct MONITORINFO;
struct MOUSEHOOKSTRUCT;
struct MOUSEHOOKSTRUCTEX;
struct MOUSEKEYS;
struct MOUSEMOVEPOINT;
struct MSG;
struct MSGBOXPARAMSW;
struct MSLLHOOKSTRUCT;
struct MULTIKEYHELPW;
struct NCCALCSIZE_PARAMS;
struct NMHDR;
struct NONCLIENTMETRICSW;
struct PAINTSTRUCT;
struct POINTER_DEVICE_CURSOR_INFO;
struct POINTER_DEVICE_PROPERTY;
struct POINTER_INFO;
struct POINTER_PEN_INFO;
struct POINTER_TOUCH_INFO;
struct POWERBROADCAST_SETTING;
struct RAWINPUTDEVICE;
struct RAWINPUTDEVICELIST;
struct RAWINPUTHEADER;
struct RID_DEVICE_INFO_HID;
struct RID_DEVICE_INFO_KEYBOARD;
struct RID_DEVICE_INFO_MOUSE;
struct SCROLLBARINFO;
struct SCROLLINFO;
struct SERIALKEYSW;
struct SHELLHOOKINFO;
struct SOUNDSENTRYW;
struct STICKYKEYS;
struct STYLESTRUCT;
struct TITLEBARINFO;
struct TITLEBARINFOEX;
struct TOGGLEKEYS;
struct TOUCH_HIT_TESTING_INPUT;
struct TOUCH_HIT_TESTING_PROXIMITY_EVALUATION;
struct TOUCHINPUT;
struct TOUCHPREDICTIONPARAMETERS;
struct TPMPARAMS;
struct TRACKMOUSEEVENT;
struct UPDATELAYEREDWINDOWINFO;
struct USAGE_PROPERTIES;
struct USEROBJECTFLAGS;
struct WINDOWINFO;
struct WINDOWPLACEMENT;
struct WINDOWPOS;
struct WTSSESSION_NOTIFICATION;
struct RAWKEYBOARD;
struct RAWHID;
struct RAWINPUT;
struct INPUT_TRANSFORM;
struct MENUITEMINFO;
struct INPUT;
// Base classes from other headers
class CObject;
class CDXHandleShared;
class CDXObjectBase;
class CDXObject;



// Enums
enum ENUM_LINE_END {
    LINE_END_ROUND,
    LINE_END_BUTT,
    LINE_END_SQUARE
};

enum ENUM_SHOW_FLAGS {
    FLAG_SHOW_NONE = 0,
    FLAG_SHOW_LEGEND = 1,
    FLAG_SHOW_SCALE_LEFT = 2,
    FLAG_SHOW_SCALE_RIGHT = 4,
    FLAG_SHOW_SCALE_TOP = 8,
    FLAG_SHOW_SCALE_BOTTOM = 16,
    FLAG_SHOW_GRID = 32,
    FLAG_SHOW_DESCRIPTORS = 64,
    FLAG_SHOW_VALUE = 128,
    FLAG_SHOW_PERCENT = 256,
    FLAGS_SHOW_SCALES = (FLAG_SHOW_SCALE_LEFT+FLAG_SHOW_SCALE_RIGHT+ FLAG_SHOW_SCALE_TOP+FLAG_SHOW_SCALE_BOTTOM),
    FLAGS_SHOW_ALL = (FLAG_SHOW_LEGEND+FLAGS_SHOW_SCALES+FLAG_SHOW_GRID+ FLAG_SHOW_DESCRIPTORS+FLAG_SHOW_VALUE+FLAG_SHOW_PERCENT)
};

enum ENUM_ALIGNMENT {
    ALIGNMENT_LEFT = 1,
    ALIGNMENT_TOP = 2,
    ALIGNMENT_RIGHT = 4,
    ALIGNMENT_BOTTOM = 8
};

enum EN_SURFACE_FLAGS {
    SF_NONE = 0x0,
    SF_TWO_SIDED = 0x1,
    SF_USE_NORMALS = 0x2
};

enum EN_COLOR_SCHEME {
    CS_NONE = 0,
    CS_JET = 1,
    CS_COLD_TO_HOT = 2,
    CS_RED_TO_GREEN = 3
};

enum ENUM_DATE_MODES {
    DATE_MODE_MON,
    DATE_MODE_YEAR
};

enum ENUM_WND_PROP_FLAGS {
    WND_PROP_FLAG_CAN_DBL_CLICK = 1,
    WND_PROP_FLAG_CAN_DRAG = 2,
    WND_PROP_FLAG_CLICKS_BY_PRESS = 4,
    WND_PROP_FLAG_CAN_LOCK = 8,
    WND_PROP_FLAG_READ_ONLY = 16
};

enum ENUM_WND_STATE_FLAGS {
    WND_STATE_FLAG_ENABLE = 1,
    WND_STATE_FLAG_VISIBLE = 2,
    WND_STATE_FLAG_ACTIVE = 4
};

enum ENUM_MOUSE_FLAGS {
    MOUSE_INVALID_FLAGS = -1,
    MOUSE_EMPTY = 0,
    MOUSE_LEFT = 1,
    MOUSE_RIGHT = 2
};

enum ENUM_WND_ALIGN_FLAGS {
    WND_ALIGN_NONE = 0,
    WND_ALIGN_LEFT = 1,
    WND_ALIGN_TOP = 2,
    WND_ALIGN_RIGHT = 4,
    WND_ALIGN_BOTTOM = 8,
    WND_ALIGN_WIDTH = WND_ALIGN_LEFT|WND_ALIGN_RIGHT,
    WND_ALIGN_HEIGHT = WND_ALIGN_TOP|WND_ALIGN_BOTTOM,
    WND_ALIGN_CLIENT = WND_ALIGN_WIDTH|WND_ALIGN_HEIGHT
};

enum ENUM_TYPE_TREND {
    TYPE_TREND_HARD_DOWN = 0,
    TYPE_TREND_DOWN = 1,
    TYPE_TREND_SOFT_DOWN = 2,
    TYPE_TREND_FLAT = 3,
    TYPE_TREND_SOFT_UP = 4,
    TYPE_TREND_UP = 5,
    TYPE_TREND_HARD_UP = 6
};

enum ENUM_USED_SERIES {
    USE_SERIES_OPEN = 0x1,
    USE_SERIES_HIGH = 0x2,
    USE_SERIES_LOW = 0x4,
    USE_SERIES_CLOSE = 0x8,
    USE_SERIES_SPREAD = 0x10,
    USE_SERIES_TIME = 0x20,
    USE_SERIES_TICK_VOLUME = 0x40,
    USE_SERIES_REAL_VOLUME = 0x80
};

enum ENUM_INIT_PHASE {
    INIT_PHASE_FIRST = 0,
    INIT_PHASE_TUNING = 1,
    INIT_PHASE_VALIDATION = 2,
    INIT_PHASE_COMPLETE = 3
};

enum ENUM_AXIS_TYPE {
    AXIS_TYPE_DOUBLE,
    AXIS_TYPE_DATETIME,
    AXIS_TYPE_CUSTOM
};

enum ENUM_CURVE_TYPE {
    CURVE_POINTS,
    CURVE_LINES,
    CURVE_POINTS_AND_LINES,
    CURVE_STEPS,
    CURVE_HISTOGRAM,
    CURVE_CUSTOM,
    CURVE_NONE
};

enum ENUM_POINT_TYPE {
    POINT_CIRCLE,
    POINT_SQUARE,
    POINT_DIAMOND,
    POINT_TRIANGLE,
    POINT_TRIANGLE_DOWN,
    POINT_X_CROSS,
    POINT_PLUS,
    POINT_STAR,
    POINT_HORIZONTAL_DASH,
    POINT_VERTICAL_DASH
};

enum OperatorType {
    And,
    Or
};

enum HedgeType {
    None,
    Slightly,
    Somewhat,
    Very,
    Extremely
};

enum EnAndMethod {
    MinAnd,
    ProductionAnd
};

enum EnOrMethod {
    MaxOr,
    ProbabilisticOr
};

enum ImplicationMethod {
    MinIpm,
    ProductionImp
};

enum AggregationMethod {
    MaxAgg,
    SumAgg
};

enum DefuzzificationMethod {
    CentroidDef,
    BisectorDef,
    AverageMaximumDef,
    LargestMaximumDef,
    SmallestMaximumDef
};

enum EnType {
    TYPE_CLASS_INamedValue,
    TYPE_CLASS_INamedVariable,
    TYPE_CLASS_NamedVariableImpl,
    TYPE_CLASS_NamedValueImpl,
    TYPE_CLASS_FuzzyTerm,
    TYPE_CLASS_FuzzyVariable,
    TYPE_CLASS_SugenoVariable,
    TYPE_CLASS_ISugenoFunction,
    TYPE_CLASS_LinearSugenoFunction
};

enum EnLexem {
    TYPE_CLASS_IExpression,
    TYPE_CLASS_Lexem,
    TYPE_CLASS_ConditionExpression,
    TYPE_CLASS_VarLexem,
    TYPE_CLASS_KeywordLexem,
    TYPE_CLASS_AltLexem,
    TYPE_CLASS_TermLexem
};

enum EnCondition {
    TYPE_CLASS_ICondition,
    TYPE_CLASS_Conditions,
    TYPE_CLASS_SingleCondition,
    TYPE_CLASS_FuzzyCondition
};

enum EnRule {
    TYPE_CLASS_IParsableRule,
    TYPE_CLASS_GenericFuzzyRule,
    TYPE_CLASS_MamdaniFuzzyRule,
    TYPE_CLASS_SugenoFuzzyRule
};

enum MfCompositionType {
    MinMF,
    MaxMF,
    ProdMF,
    SumMF
};

enum ENUM_LOG_LEVELS {
    LOG_LEVEL_NO = 0,
    LOG_LEVEL_ERRORS = 1,
    LOG_LEVEL_ALL = 2
};

enum STREAM_INFO_LEVELS {
    FindStreamInfoStandard,
    FindStreamInfoMaxInfoLevel
};

enum MEMORY_RESOURCE_NOTIFICATION_TYPE {
    LowMemoryResourceNotification,
    HighMemoryResourceNotification
};

enum OFFER_PRIORITY {
    VmOfferPriorityVeryLow = 1,
    VmOfferPriorityLow,
    VmOfferPriorityBelowNormal,
    VmOfferPriorityNormal
};

enum WIN32_MEMORY_INFORMATION_CLASS {
    MemoryRegionInfo
};

enum THREAD_INFORMATION_CLASS {
    ThreadMemoryPriority,
    ThreadAbsoluteCpuPriority,
    ThreadDynamicCodePolicy,
    ThreadPowerThrottling,
    ThreadInformationClassMax
};

enum PROCESS_INFORMATION_CLASS {
    ProcessMemoryPriority,
    ProcessMemoryExhaustionInfo,
    ProcessAppMemoryInfo,
    ProcessInPrivateInfo,
    ProcessPowerThrottling,
    ProcessReservedValue1,
    ProcessTelemetryCoverageInfo,
    ProcessProtectionLevelInfo,
    ProcessInformationClassMax
};

enum PROCESS_MEMORY_EXHAUSTION_TYPE {
    PMETypeFailFastOnCommitFailure,
    PMETypeMax
};

enum COMPUTER_NAME_FORMAT {
    ComputerNameNetBIOS,
    ComputerNameDnsHostname,
    ComputerNameDnsDomain,
    ComputerNameDnsFullyQualified,
    ComputerNamePhysicalNetBIOS,
    ComputerNamePhysicalDnsHostname,
    ComputerNamePhysicalDnsDomain,
    ComputerNamePhysicalDnsFullyQualified,
    ComputerNameMax
};

enum COPYFILE2_COPY_PHASE {
    COPYFILE2_PHASE_NONE = 0,
    COPYFILE2_PHASE_PREPARE_SOURCE,
    COPYFILE2_PHASE_PREPARE_DEST,
    COPYFILE2_PHASE_READ_SOURCE,
    COPYFILE2_PHASE_WRITE_DESTINATION,
    COPYFILE2_PHASE_SERVER_COPY,
    COPYFILE2_PHASE_NAMEGRAFT_COPY,
    COPYFILE2_PHASE_MAX
};

enum COPYFILE2_MESSAGE_ACTION {
    COPYFILE2_PROGRESS_CONTINUE = 0,
    COPYFILE2_PROGRESS_CANCEL,
    COPYFILE2_PROGRESS_STOP,
    COPYFILE2_PROGRESS_QUIET,
    COPYFILE2_PROGRESS_PAUSE
};

enum COPYFILE2_MESSAGE_TYPE {
    COPYFILE2_CALLBACK_NONE = 0,
    COPYFILE2_CALLBACK_CHUNK_STARTED,
    COPYFILE2_CALLBACK_CHUNK_FINISHED,
    COPYFILE2_CALLBACK_STREAM_STARTED,
    COPYFILE2_CALLBACK_STREAM_FINISHED,
    COPYFILE2_CALLBACK_POLL_CONTINUE,
    COPYFILE2_CALLBACK_ERROR,
    COPYFILE2_CALLBACK_MAX
};

enum DEP_SYSTEM_POLICY_TYPE {
    DEPPolicyAlwaysOff = 0,
    DEPPolicyAlwaysOn,
    DEPPolicyOptIn,
    DEPPolicyOptOut,
    DEPTotalPolicyCount
};

enum FILE_ID_TYPE {
    FileIdType,
    ObjectIdType,
    ExtendedFileIdType,
    MaximumFileIdType
};

enum PRIORITY_HINT {
    IoPriorityHintVeryLow = 0,
    IoPriorityHintLow,
    IoPriorityHintNormal,
    MaximumIoPriorityHintType
};

enum PROC_THREAD_ATTRIBUTE_NUM {
    ProcThreadAttributeParentProcess = 0,
    ProcThreadAttributeHandleList = 2,
    ProcThreadAttributeGroupAffinity = 3,
    ProcThreadAttributePreferredNode = 4,
    ProcThreadAttributeIdealProcessor = 5,
    ProcThreadAttributeUmsThread = 6,
    ProcThreadAttributeMitigationPolicy = 7,
    ProcThreadAttributeSecurityCapabilities = 9,
    ProcThreadAttributeProtectionLevel = 11,
    ProcThreadAttributeJobList = 13,
    ProcThreadAttributeChildProcessPolicy = 14,
    ProcThreadAttributeAllApplicationPackagesPolicy = 15,
    ProcThreadAttributeWin32kFilter = 16,
    ProcThreadAttributeSafeOpenPromptOriginClaim = 17,
    ProcThreadAttributeDesktopAppPolicy = 18
};

enum LATENCY_TIME {
    LT_DONT_CARE,
    LT_LOWEST_LATENCY
};

enum GET_FILEEX_INFO_LEVELS {
    GetFileExInfoStandard,
    GetFileExMaxInfoLevel
};

enum FINDEX_INFO_LEVELS {
    FindExInfoStandard,
    FindExInfoBasic,
    FindExInfoMaxInfoLevel
};

enum FINDEX_SEARCH_OPS {
    FindExSearchNameMatch,
    FindExSearchLimitToDirectories,
    FindExSearchLimitToDevices,
    FindExSearchMaxSearchOp
};

enum DPI_AWARENESS {
    DPI_AWARENESS_INVALID = -1,
    DPI_AWARENESS_UNAWARE = 0,
    DPI_AWARENESS_SYSTEM_AWARE = 1,
    DPI_AWARENESS_PER_MONITOR_AWARE = 2
};

enum DPI_HOSTING_BEHAVIOR {
    DPI_HOSTING_BEHAVIOR_INVALID = -1,
    DPI_HOSTING_BEHAVIOR_DEFAULT = 0,
    DPI_HOSTING_BEHAVIOR_MIXED = 1
};

enum FILE_INFO_BY_HANDLE_CLASS {
    FileBasicInfo = 0,
    FileStandardInfo = 1,
    FileNameInfo = 2,
    FileRenameInfo = 3,
    FileDispositionInfo = 4,
    FileAllocationInfo = 5,
    FileEndOfFileInfo = 6,
    FileStreamInfo = 7,
    FileCompressionInfo = 8,
    FileAttributeTagInfo = 9,
    FileIdBothDirectoryInfo = 10,
    FileIdBothDirectoryRestartInfo = 11,
    FileIoPriorityHintInfo = 12,
    FileRemoteProtocolInfo = 13,
    FileFullDirectoryInfo = 14,
    FileFullDirectoryRestartInfo = 15,
    FileStorageInfo = 16,
    FileAlignmentInfo = 17,
    FileIdInfo = 18,
    FileIdExtdDirectoryInfo = 19,
    FileIdExtdDirectoryRestartInfo = 20,
    MaximumFileInfoByHandlesClass
};

enum READ_DIRECTORY_NOTIFY_INFORMATION_CLASS {
    ReadDirectoryNotifyInformation = 1,
    ReadDirectoryNotifyExtendedInformation
};

enum WELL_KNOWN_SID_TYPE {
    WinNullSid = 0,
    WinWorldSid = 1,
    WinLocalSid = 2,
    WinCreatorOwnerSid = 3,
    WinCreatorGroupSid = 4,
    WinCreatorOwnerServerSid = 5,
    WinCreatorGroupServerSid = 6,
    WinNtAuthoritySid = 7,
    WinDialupSid = 8,
    WinNetworkSid = 9,
    WinBatchSid = 10,
    WinInteractiveSid = 11,
    WinServiceSid = 12,
    WinAnonymousSid = 13,
    WinProxySid = 14,
    WinEnterpriseControllersSid = 15,
    WinSelfSid = 16,
    WinAuthenticatedUserSid = 17,
    WinRestrictedCodeSid = 18,
    WinTerminalServerSid = 19,
    WinRemoteLogonIdSid = 20,
    WinLogonIdsSid = 21,
    WinLocalSystemSid = 22,
    WinLocalServiceSid = 23,
    WinNetworkServiceSid = 24,
    WinBuiltinDomainSid = 25,
    WinBuiltinAdministratorsSid = 26,
    WinBuiltinUsersSid = 27,
    WinBuiltinGuestsSid = 28,
    WinBuiltinPowerUsersSid = 29,
    WinBuiltinAccountOperatorsSid = 30,
    WinBuiltinSystemOperatorsSid = 31,
    WinBuiltinPrintOperatorsSid = 32,
    WinBuiltinBackupOperatorsSid = 33,
    WinBuiltinReplicatorSid = 34,
    WinBuiltinPreWindows2000CompatibleAccessSid = 35,
    WinBuiltinRemoteDesktopUsersSid = 36,
    WinBuiltinNetworkConfigurationOperatorsSid = 37,
    WinAccountAdministratorSid = 38,
    WinAccountGuestSid = 39,
    WinAccountKrbtgtSid = 40,
    WinAccountDomainAdminsSid = 41,
    WinAccountDomainUsersSid = 42,
    WinAccountDomainGuestsSid = 43,
    WinAccountComputersSid = 44,
    WinAccountControllersSid = 45,
    WinAccountCertAdminsSid = 46,
    WinAccountSchemaAdminsSid = 47,
    WinAccountEnterpriseAdminsSid = 48,
    WinAccountPolicyAdminsSid = 49,
    WinAccountRasAndIasServersSid = 50,
    WinNTLMAuthenticationSid = 51,
    WinDigestAuthenticationSid = 52,
    WinSChannelAuthenticationSid = 53,
    WinThisOrganizationSid = 54,
    WinOtherOrganizationSid = 55,
    WinBuiltinIncomingForestTrustBuildersSid = 56,
    WinBuiltinPerfMonitoringUsersSid = 57,
    WinBuiltinPerfLoggingUsersSid = 58,
    WinBuiltinAuthorizationAccessSid = 59,
    WinBuiltinTerminalServerLicenseServersSid = 60,
    WinBuiltinDCOMUsersSid = 61,
    WinBuiltinIUsersSid = 62,
    WinIUserSid = 63,
    WinBuiltinCryptoOperatorsSid = 64,
    WinUntrustedLabelSid = 65,
    WinLowLabelSid = 66,
    WinMediumLabelSid = 67,
    WinHighLabelSid = 68,
    WinSystemLabelSid = 69,
    WinWriteRestrictedCodeSid = 70,
    WinCreatorOwnerRightsSid = 71,
    WinCacheablePrincipalsGroupSid = 72,
    WinNonCacheablePrincipalsGroupSid = 73,
    WinEnterpriseReadonlyControllersSid = 74,
    WinAccountReadonlyControllersSid = 75,
    WinBuiltinEventLogReadersGroup = 76,
    WinNewEnterpriseReadonlyControllersSid = 77,
    WinBuiltinCertSvcDComAccessGroup = 78,
    WinMediumPlusLabelSid = 79,
    WinLocalLogonSid = 80,
    WinConsoleLogonSid = 81,
    WinThisOrganizationCertificateSid = 82,
    WinApplicationPackageAuthoritySid = 83,
    WinBuiltinAnyPackageSid = 84,
    WinCapabilityInternetClientSid = 85,
    WinCapabilityInternetClientServerSid = 86,
    WinCapabilityPrivateNetworkClientServerSid = 87,
    WinCapabilityPicturesLibrarySid = 88,
    WinCapabilityVideosLibrarySid = 89,
    WinCapabilityMusicLibrarySid = 90,
    WinCapabilityDocumentsLibrarySid = 91,
    WinCapabilitySharedUserCertificatesSid = 92,
    WinCapabilityEnterpriseAuthenticationSid = 93,
    WinCapabilityRemovableStorageSid = 94,
    WinBuiltinRDSRemoteAccessServersSid = 95,
    WinBuiltinRDSEndpointServersSid = 96,
    WinBuiltinRDSManagementServersSid = 97,
    WinUserModeDriversSid = 98,
    WinBuiltinHyperVAdminsSid = 99,
    WinAccountCloneableControllersSid = 100,
    WinBuiltinAccessControlAssistanceOperatorsSid = 101,
    WinBuiltinRemoteManagementUsersSid = 102,
    WinAuthenticationAuthorityAssertedSid = 103,
    WinAuthenticationServiceAssertedSid = 104,
    WinLocalAccountSid = 105,
    WinLocalAccountAndAdministratorSid = 106,
    WinAccountProtectedUsersSid = 107,
    WinCapabilityAppointmentsSid = 108,
    WinCapabilityContactsSid = 109,
    WinAccountDefaultSystemManagedSid = 110,
    WinBuiltinDefaultSystemManagedGroupSid = 111,
    WinBuiltinStorageReplicaAdminsSid = 112,
    WinAccountKeyAdminsSid = 113,
    WinAccountEnterpriseKeyAdminsSid = 114,
    WinAuthenticationKeyTrustSid = 115,
    WinAuthenticationKeyPropertyMFASid = 116,
    WinAuthenticationKeyPropertyAttestationSid = 117,
    WinAuthenticationFreshKeyAuthSid = 118,
    WinBuiltinDeviceOwnersSid = 119
};

enum DISPLAYCONFIG_COLOR_ENCODING {
    DISPLAYCONFIG_COLOR_ENCODING_RGB = 0,
    DISPLAYCONFIG_COLOR_ENCODING_YCBCR444 = 1,
    DISPLAYCONFIG_COLOR_ENCODING_YCBCR422 = 2,
    DISPLAYCONFIG_COLOR_ENCODING_YCBCR420 = 3,
    DISPLAYCONFIG_COLOR_ENCODING_INTENSITY = 4,
    DISPLAYCONFIG_COLOR_ENCODING_FORCE_UINT32 = 0xFFFFFFFF
};

enum DISPLAYCONFIG_DEVICE_INFO_TYPE {
    DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME = 1,
    DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME = 2,
    DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE = 3,
    DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME = 4,
    DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE = 5,
    DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_BASE_TYPE = 6,
    DISPLAYCONFIG_DEVICE_INFO_GET_SUPPORT_VIRTUAL_RESOLUTION = 7,
    DISPLAYCONFIG_DEVICE_INFO_SET_SUPPORT_VIRTUAL_RESOLUTION = 8,
    DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO = 9,
    DISPLAYCONFIG_DEVICE_INFO_SET_ADVANCED_COLOR_STATE = 10,
    DISPLAYCONFIG_DEVICE_INFO_GET_SDR_WHITE_LEVEL = 11,
    DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32 = 0xFFFFFFFF
};

enum DISPLAYCONFIG_MODE_INFO_TYPE {
    DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE = 1,
    DISPLAYCONFIG_MODE_INFO_TYPE_TARGET = 2,
    DISPLAYCONFIG_MODE_INFO_TYPE_DESKTOP_IMAGE = 3,
    DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32 = 0xFFFFFFFF
};

enum DISPLAYCONFIG_PIXELFORMAT {
    DISPLAYCONFIG_PIXELFORMAT_8BPP = 1,
    DISPLAYCONFIG_PIXELFORMAT_16BPP = 2,
    DISPLAYCONFIG_PIXELFORMAT_24BPP = 3,
    DISPLAYCONFIG_PIXELFORMAT_32BPP = 4,
    DISPLAYCONFIG_PIXELFORMAT_NONGDI = 5,
    DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32 = 0xffffffff
};

enum DISPLAYCONFIG_ROTATION {
    DISPLAYCONFIG_ROTATION_IDENTITY = 1,
    DISPLAYCONFIG_ROTATION_ROTATE90 = 2,
    DISPLAYCONFIG_ROTATION_ROTATE180 = 3,
    DISPLAYCONFIG_ROTATION_ROTATE270 = 4,
    DISPLAYCONFIG_ROTATION_FORCE_UINT32 = 0xFFFFFFFF
};

enum DISPLAYCONFIG_SCALING {
    DISPLAYCONFIG_SCALING_IDENTITY = 1,
    DISPLAYCONFIG_SCALING_CENTERED = 2,
    DISPLAYCONFIG_SCALING_STRETCHED = 3,
    DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX = 4,
    DISPLAYCONFIG_SCALING_CUSTOM = 5,
    DISPLAYCONFIG_SCALING_PREFERRED = 128,
    DISPLAYCONFIG_SCALING_FORCE_UINT32 = 0xFFFFFFFF
};

enum DISPLAYCONFIG_SCANLINE_ORDERING {
    DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED = 0,
    DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE = 1,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED = 2,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST = DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST = 3,
    DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32 = 0xFFFFFFFF
};

enum DISPLAYCONFIG_TOPOLOGY_ID {
    DISPLAYCONFIG_TOPOLOGY_INTERNAL = 0x00000001,
    DISPLAYCONFIG_TOPOLOGY_CLONE = 0x00000002,
    DISPLAYCONFIG_TOPOLOGY_EXTEND = 0x00000004,
    DISPLAYCONFIG_TOPOLOGY_EXTERNAL = 0x00000008,
    DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32 = 0xFFFFFFFF
};

enum DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY {
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER = -1,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15 = 0,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO = 1,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO = 2,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO = 3,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI = 4,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI = 5,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS = 6,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN = 8,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI = 9,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL = 10,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED = 11,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL = 12,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED = 13,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE = 14,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_MIRACAST = 15,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_WIRED = 16,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL = 0x80000000,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32 = 0xFFFFFFFF
};

enum SID_NAME_USE {
    SidTypeUser = 1,
    SidTypeGroup,
    SidTypeDomain,
    SidTypeAlias,
    SidTypeWellKnownGroup,
    SidTypeDeletedAccount,
    SidTypeInvalid,
    SidTypeUnknown,
    SidTypeComputer,
    SidTypeLabel,
    SidTypeLogonSession
};

enum ACL_INFORMATION_CLASS {
    AclRevisionInformation = 1,
    AclSizeInformation
};

enum AUDIT_EVENT_TYPE {
    AuditEventObjectAccess,
    AuditEventDirectoryServiceAccess
};

enum ACCESS_REASON_TYPE {
    AccessReasonNone = 0x00000000,
    AccessReasonAllowedAce = 0x00010000,
    AccessReasonDeniedAce = 0x00020000,
    AccessReasonAllowedParentAce = 0x00030000,
    AccessReasonDeniedParentAce = 0x00040000,
    AccessReasonNotGrantedByCape = 0x00050000,
    AccessReasonNotGrantedByParentCape = 0x00060000,
    AccessReasonNotGrantedToAppContainer = 0x00070000,
    AccessReasonMissingPrivilege = 0x00100000,
    AccessReasonFromPrivilege = 0x00200000,
    AccessReasonIntegrityLevel = 0x00300000,
    AccessReasonOwnership = 0x00400000,
    AccessReasonNullDacl = 0x00500000,
    AccessReasonEmptyDacl = 0x00600000,
    AccessReasonNoSD = 0x00700000,
    AccessReasonNoGrant = 0x00800000,
    AccessReasonTrustLabel = 0x00900000,
    AccessReasonFilterAce = 0x00a00000
};

enum SECURITY_IMPERSONATION_LEVEL {
    SecurityAnonymous,
    SecurityIdentification,
    SecurityImpersonation,
    SecurityDelegation
};

enum TOKEN_TYPE {
    TokenPrimary = 1,
    TokenImpersonation
};

enum TOKEN_ELEVATION_TYPE {
    TokenElevationTypeDefault = 1,
    TokenElevationTypeFull,
    TokenElevationTypeLimited
};

enum TOKEN_INFORMATION_CLASS {
    TokenUser = 1,
    TokenGroups,
    TokenPrivileges,
    TokenOwner,
    TokenPrimaryGroup,
    TokenDefaultDacl,
    TokenSource,
    TokenType,
    TokenImpersonationLevel,
    TokenStatistics,
    TokenRestrictedSids,
    TokenSessionId,
    TokenGroupsAndPrivileges,
    TokenSessionReference,
    TokenSandBoxInert,
    TokenAuditPolicy,
    TokenOrigin,
    TokenElevationType,
    TokenLinkedToken,
    TokenElevation,
    TokenHasRestrictions,
    TokenAccessInformation,
    TokenVirtualizationAllowed,
    TokenVirtualizationEnabled,
    TokenIntegrityLevel,
    TokenUIAccess,
    TokenMandatoryPolicy,
    TokenLogonSid,
    TokenIsAppContainer,
    TokenCapabilities,
    TokenAppContainerSid,
    TokenAppContainerNumber,
    TokenUserClaimAttributes,
    TokenDeviceClaimAttributes,
    TokenRestrictedUserClaimAttributes,
    TokenRestrictedDeviceClaimAttributes,
    TokenDeviceGroups,
    TokenRestrictedDeviceGroups,
    TokenSecurityAttributes,
    TokenIsRestricted,
    TokenProcessTrustLevel,
    TokenPrivateNameSpace,
    TokenSingletonAttributes,
    TokenBnoIsolation,
    TokenChildProcessFlags,
    MaxTokenInfoClass
};

enum MANDATORY_LEVEL {
    MandatoryLevelUntrusted = 0,
    MandatoryLevelLow,
    MandatoryLevelMedium,
    MandatoryLevelHigh,
    MandatoryLevelSystem,
    MandatoryLevelSecureProcess,
    MandatoryLevelCount
};

enum SE_IMAGE_SIGNATURE_TYPE {
    SeImageSignatureNone = 0,
    SeImageSignatureEmbedded,
    SeImageSignatureCache,
    SeImageSignatureCatalogCached,
    SeImageSignatureCatalogNotCached,
    SeImageSignatureCatalogHint,
    SeImageSignaturePackageCatalog
};

enum SE_LEARNING_MODE_DATA_TYPE {
    SeLearningModeInvalidType = 0,
    SeLearningModeSettings,
    SeLearningModeMax
};

enum HARDWARE_COUNTER_TYPE {
    PMCCounter,
    MaxHardwareCounterType
};

enum PROCESS_MITIGATION_POLICY {
    ProcessDEPPolicy,
    ProcessASLRPolicy,
    ProcessDynamicCodePolicy,
    ProcessStrictHandleCheckPolicy,
    ProcessSystemCallDisablePolicy,
    ProcessMitigationOptionsMask,
    ProcessExtensionPointDisablePolicy,
    ProcessControlFlowGuardPolicy,
    ProcessSignaturePolicy,
    ProcessFontDisablePolicy,
    ProcessImageLoadPolicy,
    ProcessSystemCallFilterPolicy,
    ProcessPayloadRestrictionPolicy,
    ProcessChildProcessPolicy,
    MaxProcessMitigationPolicy
};

enum JOBOBJECT_RATE_CONTROL_TOLERANCE {
    ToleranceLow = 1,
    ToleranceMedium,
    ToleranceHigh
};

enum JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL {
    ToleranceIntervalShort = 1,
    ToleranceIntervalMedium,
    ToleranceIntervalLong
};

enum JOB_OBJECT_NET_RATE_CONTROL_FLAGS {
    JOB_OBJECT_NET_RATE_CONTROL_ENABLE = 0x1,
    JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH = 0x2,
    JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG = 0x4,
    JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS = 0x7
};

enum JOB_OBJECT_IO_RATE_CONTROL_FLAGS {
    JOB_OBJECT_IO_RATE_CONTROL_ENABLE = 0x1,
    JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME = 0x2,
    JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL = 0x4,
    JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP = 0x8,
    JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGS = JOB_OBJECT_IO_RATE_CONTROL_ENABLE| JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME| JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL| JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP
};

enum JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS {
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_ENABLE = 0x1,
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_DISABLE = 0x2,
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_VALID_FLAGS = 0x3
};

enum JOBOBJECTINFOCLASS {
    JobObjectBasicAccountingInformation = 1,
    JobObjectBasicLimitInformation,
    JobObjectBasicProcessIdList,
    JobObjectBasicUIRestrictions,
    JobObjectSecurityLimitInformation,
    JobObjectEndOfJobTimeInformation,
    JobObjectAssociateCompletionPortInformation,
    JobObjectBasicAndIoAccountingInformation,
    JobObjectExtendedLimitInformation,
    JobObjectJobSetInformation,
    JobObjectGroupInformation,
    JobObjectNotificationLimitInformation,
    JobObjectLimitViolationInformation,
    JobObjectGroupInformationEx,
    JobObjectCpuRateControlInformation,
    JobObjectCompletionFilter,
    JobObjectCompletionCounter,
    JobObjectReserved1Information = 18,
    JobObjectReserved2Information,
    JobObjectReserved3Information,
    JobObjectReserved4Information,
    JobObjectReserved5Information,
    JobObjectReserved6Information,
    JobObjectReserved7Information,
    JobObjectReserved8Information,
    JobObjectReserved9Information,
    JobObjectReserved10Information,
    JobObjectReserved11Information,
    JobObjectReserved12Information,
    JobObjectReserved13Information,
    JobObjectReserved14Information = 31,
    JobObjectNetRateControlInformation,
    JobObjectNotificationLimitInformation2,
    JobObjectLimitViolationInformation2,
    JobObjectCreateSilo,
    JobObjectSiloBasicInformation,
    JobObjectReserved15Information = 37,
    JobObjectReserved16Information = 38,
    JobObjectReserved17Information = 39,
    JobObjectReserved18Information = 40,
    JobObjectReserved19Information = 41,
    JobObjectReserved20Information = 42,
    JobObjectReserved21Information = 43,
    JobObjectReserved22Information = 44,
    JobObjectReserved23Information = 45,
    JobObjectReserved24Information = 46,
    JobObjectReserved25Information = 47,
    MaxJobObjectInfoClass
};

enum SERVERSILO_STATE {
    SERVERSILO_INITING = 0,
    SERVERSILO_STARTED,
    SERVERSILO_SHUTTING_DOWN,
    SERVERSILO_TERMINATING,
    SERVERSILO_TERMINATED
};

enum FIRMWARE_TYPE {
    FirmwareTypeUnknown,
    FirmwareTypeBios,
    FirmwareTypeUefi,
    FirmwareTypeMax
};

enum LOGICAL_PROCESSOR_RELATIONSHIP {
    RelationProcessorCore,
    RelationNumaNode,
    RelationCache,
    RelationProcessorPackage,
    RelationGroup,
    RelationAll = 0xffff
};

enum PROCESSOR_CACHE_TYPE {
    CacheUnified,
    CacheInstruction,
    CacheData,
    CacheTrace
};

enum CPU_SET_INFORMATION_TYPE {
    CpuSetInformation
};

enum MEM_EXTENDED_PARAMETER_TYPE {
    MemExtendedParameterInvalidType = 0,
    MemExtendedParameterAddressRequirements,
    MemExtendedParameterNumaNode,
    MemExtendedParameterPartitionHandle,
    MemExtendedParameterMax
};

enum SharedVirtualDiskSupportType {
    SharedVirtualDisksUnsupported = 0,
    SharedVirtualDisksSupported = 1,
    SharedVirtualDiskSnapshotsSupported = 3,
    SharedVirtualDiskCDPSnapshotsSupported = 7
};

enum SharedVirtualDiskHandleState {
    SharedVirtualDiskHandleStateNone = 0,
    SharedVirtualDiskHandleStateFileShared = 1,
    SharedVirtualDiskHandleStateHandleShared = 3
};

enum SYSTEM_POWER_STATE {
    PowerSystemUnspecified = 0,
    PowerSystemWorking = 1,
    PowerSystemSleeping1 = 2,
    PowerSystemSleeping2 = 3,
    PowerSystemSleeping3 = 4,
    PowerSystemHibernate = 5,
    PowerSystemShutdown = 6,
    PowerSystemMaximum = 7
};

enum DEVICE_POWER_STATE {
    PowerDeviceUnspecified = 0,
    PowerDeviceD0,
    PowerDeviceD1,
    PowerDeviceD2,
    PowerDeviceD3,
    PowerDeviceMaximum
};

enum MONITOR_DISPLAY_STATE {
    PowerMonitorOff = 0,
    PowerMonitorOn,
    PowerMonitorDim
};

enum USER_ACTIVITY_PRESENCE {
    PowerUserPresent = 0,
    PowerUserNotPresent,
    PowerUserInactive,
    PowerUserMaximum,
    PowerUserInvalid = PowerUserMaximum
};

enum POWER_REQUEST_TYPE {
    PowerRequestDisplayRequired,
    PowerRequestSystemRequired,
    PowerRequestAwayModeRequired,
    PowerRequestExecutionRequired
};

enum POWER_MONITOR_REQUEST_TYPE {
    MonitorRequestTypeOff,
    MonitorRequestTypeOnAndPresent,
    MonitorRequestTypeToggleOn
};

enum POWER_PLATFORM_ROLE {
    PlatformRoleUnspecified = 0,
    PlatformRoleDesktop,
    PlatformRoleMobile,
    PlatformRoleWorkstation,
    PlatformRoleEnterpriseServer,
    PlatformRoleSOHOServer,
    PlatformRoleAppliancePC,
    PlatformRolePerformanceServer,
    PlatformRoleSlate,
    PlatformRoleMaximum
};

enum HIBERFILE_BUCKET_SIZE {
    HiberFileBucket1GB = 0,
    HiberFileBucket2GB,
    HiberFileBucket4GB,
    HiberFileBucket8GB,
    HiberFileBucket16GB,
    HiberFileBucket32GB,
    HiberFileBucketUnlimited,
    HiberFileBucketMax
};

enum IMAGE_AUX_SYMBOL_TYPE {
    IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF = 1
};

enum IMPORT_OBJECT_TYPE {
    IMPORT_OBJECT_CODE = 0,
    IMPORT_OBJECT_DATA = 1,
    IMPORT_OBJECT_CONST = 2
};

enum IMPORT_OBJECT_NAME_TYPE {
    IMPORT_OBJECT_ORDINAL = 0,
    IMPORT_OBJECT_NAME = 1,
    IMPORT_OBJECT_NAME_NO_PREFIX = 2,
    IMPORT_OBJECT_NAME_UNDECORATE = 3,
    IMPORT_OBJECT_NAME_EXPORTAS = 4
};

enum ReplacesCorHdrNumericDefines {
    COMIMAGE_FLAGS_ILONLY = 0x00000001,
    COMIMAGE_FLAGS_32BITREQUIRED = 0x00000002,
    COMIMAGE_FLAGS_IL_LIBRARY = 0x00000004,
    COMIMAGE_FLAGS_STRONGNAMESIGNED = 0x00000008,
    COMIMAGE_FLAGS_NATIVE_ENTRYPOINT = 0x00000010,
    COMIMAGE_FLAGS_TRACKDEBUGDATA = 0x00010000,
    COMIMAGE_FLAGS_32BITPREFERRED = 0x00020000,
    COR_VERSION_MAJOR_V2 = 2,
    COR_VERSION_MAJOR = COR_VERSION_MAJOR_V2,
    COR_VERSION_MINOR = 5,
    COR_DELETED_NAME_LENGTH = 8,
    COR_VTABLEGAP_NAME_LENGTH = 8,
    NATIVE_TYPE_MAX_CB = 1,
    COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = 0xFF,
    IMAGE_COR_MIH_METHODRVA = 0x01,
    IMAGE_COR_MIH_EHRVA = 0x02,
    IMAGE_COR_MIH_BASICBLOCK = 0x08,
    COR_VTABLE_32BIT = 0x01,
    COR_VTABLE_64BIT = 0x02,
    COR_VTABLE_FROM_UNMANAGED = 0x04,
    COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN = 0x08,
    COR_VTABLE_CALL_MOST_DERIVED = 0x10,
    IMAGE_COR_EATJ_THUNK_SIZE = 32,
    MAX_CLASS_NAME = 1024,
    MAX_PACKAGE_NAME = 1024
};

enum RTL_UMS_THREAD_INFO_CLASS {
    UmsThreadInvalidInfoClass = 0,
    UmsThreadUserContext,
    UmsThreadPriority,
    UmsThreadAffinity,
    UmsThreadTeb,
    UmsThreadIsSuspended,
    UmsThreadIsTerminated,
    UmsThreadMaxInfoClass
};

enum RTL_UMS_SCHEDULER_REASON {
    UmsSchedulerStartup = 0,
    UmsSchedulerThreadBlocked,
    UmsSchedulerThreadYield
};

enum OS_DEPLOYEMENT_STATE_VALUES {
    OS_DEPLOYMENT_STANDARD = 1,
    OS_DEPLOYMENT_COMPACT
};

enum IMAGE_POLICY_ENTRY_TYPE {
    ImagePolicyEntryTypeNone = 0,
    ImagePolicyEntryTypeBool,
    ImagePolicyEntryTypeInt8,
    ImagePolicyEntryTypeUInt8,
    ImagePolicyEntryTypeInt16,
    ImagePolicyEntryTypeUInt16,
    ImagePolicyEntryTypeInt32,
    ImagePolicyEntryTypeUInt32,
    ImagePolicyEntryTypeInt64,
    ImagePolicyEntryTypeUInt64,
    ImagePolicyEntryTypeAnsiString,
    ImagePolicyEntryTypeUnicodeString,
    ImagePolicyEntryTypeOverride,
    ImagePolicyEntryTypeMaximum
};

enum IMAGE_POLICY_ID {
    ImagePolicyIdNone = 0,
    ImagePolicyIdEtw,
    ImagePolicyIdDebug,
    ImagePolicyIdCrashDump,
    ImagePolicyIdCrashDumpKey,
    ImagePolicyIdCrashDumpKeyGuid,
    ImagePolicyIdParentSd,
    ImagePolicyIdParentSdRev,
    ImagePolicyIdSvn,
    ImagePolicyIdDeviceId,
    ImagePolicyIdCapability,
    ImagePolicyIdScenarioId,
    ImagePolicyIdMaximum
};

enum HEAP_INFORMATION_CLASS {
    HeapCompatibilityInformation = 0,
    HeapEnableTerminationOnCorruption = 1,
    HeapOptimizeResources = 3
};

enum ACTIVATION_CONTEXT_INFO_CLASS {
    ActivationContextBasicInformation = 1,
    ActivationContextDetailedInformation = 2,
    AssemblyDetailedInformationInActivationContext = 3,
    FileInformationInAssemblyOfAssemblyInActivationContext = 4,
    RunlevelInformationInActivationContext = 5,
    CompatibilityInformationInActivationContext = 6,
    ActivationContextManifestResourceName = 7,
    MaxActivationContextInfoClass,
    AssemblyDetailedInformationInActivationContxt = 3,
    FileInformationInAssemblyOfAssemblyInActivationContxt = 4
};

enum SERVICE_NODE_TYPE {
    DriverType = 0x00000001,
    FileSystemType = 0x00000002,
    Win32ServiceOwnProcess = 0x00000010,
    Win32ServiceShareProcess = 0x00000020,
    AdapterType = 0x00000004,
    RecognizerType = 0x00000008
};

enum SERVICE_LOAD_TYPE {
    BootLoad = 0x00000000,
    SystemLoad = 0x00000001,
    AutoLoad = 0x00000002,
    DemandLoad = 0x00000003,
    DisableLoad = 0x00000004
};

enum SERVICE_ERROR_TYPE {
    IgnoreError = 0x00000000,
    NormalError = 0x00000001,
    SevereError = 0x00000002,
    CriticalError = 0x00000003
};

enum TAPE_DRIVE_PROBLEM_TYPE {
    TapeDriveProblemNone,
    TapeDriveReadWriteWarning,
    TapeDriveReadWriteError,
    TapeDriveReadWarning,
    TapeDriveWriteWarning,
    TapeDriveReadError,
    TapeDriveWriteError,
    TapeDriveHardwareError,
    TapeDriveUnsupportedMedia,
    TapeDriveScsiConnectionError,
    TapeDriveTimetoClean,
    TapeDriveCleanDriveNow,
    TapeDriveMediaLifeExpired,
    TapeDriveSnappedTape
};

enum TRANSACTION_OUTCOME {
    TransactionOutcomeUndetermined = 1,
    TransactionOutcomeCommitted,
    TransactionOutcomeAborted
};

enum TRANSACTION_STATE {
    TransactionStateNormal = 1,
    TransactionStateIndoubt,
    TransactionStateCommittedNotify
};

enum TRANSACTION_INFORMATION_CLASS {
    TransactionBasicInformation,
    TransactionPropertiesInformation,
    TransactionEnlistmentInformation,
    TransactionSuperiorEnlistmentInformation,
    TransactionBindInformation,
    TransactionDTCPrivateInformation
};

enum TRANSACTIONMANAGER_INFORMATION_CLASS {
    TransactionManagerBasicInformation,
    TransactionManagerLogInformation,
    TransactionManagerLogPathInformation,
    TransactionManagerRecoveryInformation = 4,
    TransactionManagerOnlineProbeInformation = 3,
    TransactionManagerOldestTransactionInformation = 5
};

enum RESOURCEMANAGER_INFORMATION_CLASS {
    ResourceManagerBasicInformation,
    ResourceManagerCompletionInformation
};

enum ENLISTMENT_INFORMATION_CLASS {
    EnlistmentBasicInformation,
    EnlistmentRecoveryInformation,
    EnlistmentCrmInformation
};

enum KTMOBJECT_TYPE {
    KTMOBJECT_TRANSACTION,
    KTMOBJECT_TRANSACTION_MANAGER,
    KTMOBJECT_RESOURCE_MANAGER,
    KTMOBJECT_ENLISTMENT,
    KTMOBJECT_INVALID
};

enum TP_CALLBACK_PRIORITY {
    TP_CALLBACK_PRIORITY_HIGH,
    TP_CALLBACK_PRIORITY_NORMAL,
    TP_CALLBACK_PRIORITY_LOW,
    TP_CALLBACK_PRIORITY_INVALID,
    TP_CALLBACK_PRIORITY_COUNT = TP_CALLBACK_PRIORITY_INVALID
};

enum POWER_USER_PRESENCE_TYPE {
    UserNotPresent = 0,
    UserPresent = 1,
    UserUnknown = 0xff
};

enum POWER_MONITOR_REQUEST_REASON {
    MonitorRequestReasonUnknown,
    MonitorRequestReasonPowerButton,
    MonitorRequestReasonRemoteConnection,
    MonitorRequestReasonScMonitorpower,
    MonitorRequestReasonUserInput,
    MonitorRequestReasonAcDcDisplayBurst,
    MonitorRequestReasonUserDisplayBurst,
    MonitorRequestReasonPoSetSystemState,
    MonitorRequestReasonSetThreadExecutionState,
    MonitorRequestReasonFullWake,
    MonitorRequestReasonSessionUnlock,
    MonitorRequestReasonScreenOffRequest,
    MonitorRequestReasonIdleTimeout,
    MonitorRequestReasonPolicyChange,
    MonitorRequestReasonSleepButton,
    MonitorRequestReasonLid,
    MonitorRequestReasonBatteryCountChange,
    MonitorRequestReasonGracePeriod,
    MonitorRequestReasonPnP,
    MonitorRequestReasonDP,
    MonitorRequestReasonSxTransition,
    MonitorRequestReasonSystemIdle,
    MonitorRequestReasonNearProximity,
    MonitorRequestReasonThermalStandby,
    MonitorRequestReasonResumePdc,
    MonitorRequestReasonResumeS4,
    MonitorRequestReasonTerminal,
    MonitorRequestReasonPdcSignal,
    MonitorRequestReasonAcDcDisplayBurstSuppressed,
    MonitorRequestReasonSystemStateEntered,
    MonitorRequestReasonWinrt,
    MonitorRequestReasonUserInputKeyboard,
    MonitorRequestReasonUserInputMouse,
    MonitorRequestReasonUserInputTouch,
    MonitorRequestReasonUserInputPen,
    MonitorRequestReasonUserInputAccelerometer,
    MonitorRequestReasonUserInputHid,
    MonitorRequestReasonUserInputPoUserPresent,
    MonitorRequestReasonUserInputSessionSwitch,
    MonitorRequestReasonUserInputInitialization,
    MonitorRequestReasonPdcSignalWindowsMobilePwrNotif,
    MonitorRequestReasonPdcSignalWindowsMobileShell,
    MonitorRequestReasonPdcSignalHeyCortana,
    MonitorRequestReasonPdcSignalHolographicShell,
    MonitorRequestReasonPdcSignalFingerprint,
    MonitorRequestReasonMax
};

enum POWER_ACTION {
    PowerActionNone = 0,
    PowerActionReserved,
    PowerActionSleep,
    PowerActionHibernate,
    PowerActionShutdown,
    PowerActionShutdownReset,
    PowerActionShutdownOff,
    PowerActionWarmEject,
    PowerActionDisplayOff
};

enum ACTCTX_REQUESTED_RUN_LEVEL {
    ACTCTX_RUN_LEVEL_UNSPECIFIED = 0,
    ACTCTX_RUN_LEVEL_AS_INVOKER,
    ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE,
    ACTCTX_RUN_LEVEL_REQUIRE_ADMIN,
    ACTCTX_RUN_LEVEL_NUMBERS
};

enum ACTCTX_COMPATIBILITY_ELEMENT_TYPE {
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN = 0,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION
};

enum AR_STATE {
    AR_ENABLED = 0x0,
    AR_DISABLED = 0x1,
    AR_SUPPRESSED = 0x2,
    AR_REMOTESESSION = 0x4,
    AR_MULTIMON = 0x8,
    AR_NOSENSOR = 0x10,
    AR_NOT_SUPPORTED = 0x20,
    AR_DOCKED = 0x40,
    AR_LAPTOP = 0x80
};

enum DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS {
    DCDC_DEFAULT = 0x0000,
    DCDC_DISABLE_FONT_UPDATE = 0x0001,
    DCDC_DISABLE_RELAYOUT = 0x0002
};

enum DIALOG_DPI_CHANGE_BEHAVIORS {
    DDC_DEFAULT = 0x0000,
    DDC_DISABLE_ALL = 0x0001,
    DDC_DISABLE_RESIZE = 0x0002,
    DDC_DISABLE_CONTROL_RELAYOUT = 0x0004
};

enum EDIT_CONTROL_FEATURE {
    EDIT_CONTROL_FEATURE_ENTERPRISE_DATA_PROTECTION_PASTE_SUPPORT = 0,
    EDIT_CONTROL_FEATURE_PASTE_NOTIFICATIONS = 1
};

enum FEEDBACK_TYPE {
    FEEDBACK_TOUCH_CONTACTVISUALIZATION = 1,
    FEEDBACK_PEN_BARRELVISUALIZATION = 2,
    FEEDBACK_PEN_TAP = 3,
    FEEDBACK_PEN_DOUBLETAP = 4,
    FEEDBACK_PEN_PRESSANDHOLD = 5,
    FEEDBACK_PEN_RIGHTTAP = 6,
    FEEDBACK_TOUCH_TAP = 7,
    FEEDBACK_TOUCH_DOUBLETAP = 8,
    FEEDBACK_TOUCH_PRESSANDHOLD = 9,
    FEEDBACK_TOUCH_RIGHTTAP = 10,
    FEEDBACK_GESTURE_PRESSANDTAP = 11,
    FEEDBACK_MAX = 0xFFFFFFFF
};

enum HANDEDNESS {
    HANDEDNESS_LEFT = 0,
    HANDEDNESS_RIGHT
};

enum INPUT_MESSAGE_DEVICE_TYPE {
    IMDT_UNAVAILABLE = 0x00000000,
    IMDT_KEYBOARD = 0x00000001,
    IMDT_MOUSE = 0x00000002,
    IMDT_TOUCH = 0x00000004,
    IMDT_PEN = 0x00000008,
    IMDT_TOUCHPAD = 0x00000010
};

enum INPUT_MESSAGE_ORIGIN_ID {
    IMO_UNAVAILABLE = 0x00000000,
    IMO_HARDWARE = 0x00000001,
    IMO_INJECTED = 0x00000002,
    IMO_SYSTEM = 0x00000004
};

enum ORIENTATION_PREFERENCE {
    ORIENTATION_PREFERENCE_NONE = 0x0,
    ORIENTATION_PREFERENCE_LANDSCAPE = 0x1,
    ORIENTATION_PREFERENCE_PORTRAIT = 0x2,
    ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED = 0x4,
    ORIENTATION_PREFERENCE_PORTRAIT_FLIPPED = 0x8
};

enum POINTER_BUTTON_CHANGE_TYPE {
    POINTER_CHANGE_NONE,
    POINTER_CHANGE_FIRSTBUTTON_DOWN,
    POINTER_CHANGE_FIRSTBUTTON_UP,
    POINTER_CHANGE_SECONDBUTTON_DOWN,
    POINTER_CHANGE_SECONDBUTTON_UP,
    POINTER_CHANGE_THIRDBUTTON_DOWN,
    POINTER_CHANGE_THIRDBUTTON_UP,
    POINTER_CHANGE_FOURTHBUTTON_DOWN,
    POINTER_CHANGE_FOURTHBUTTON_UP,
    POINTER_CHANGE_FIFTHBUTTON_DOWN,
    POINTER_CHANGE_FIFTHBUTTON_UP
};

enum POINTER_DEVICE_CURSOR_TYPE {
    POINTER_DEVICE_CURSOR_TYPE_UNKNOWN = 0x00000000,
    POINTER_DEVICE_CURSOR_TYPE_TIP = 0x00000001,
    POINTER_DEVICE_CURSOR_TYPE_ERASER = 0x00000002,
    POINTER_DEVICE_CURSOR_TYPE_MAX = 0xFFFFFFFF
};

enum POINTER_DEVICE_TYPE {
    POINTER_DEVICE_TYPE_INTEGRATED_PEN = 0x00000001,
    POINTER_DEVICE_TYPE_EXTERNAL_PEN = 0x00000002,
    POINTER_DEVICE_TYPE_TOUCH = 0x00000003,
    POINTER_DEVICE_TYPE_TOUCH_PAD = 0x00000004,
    POINTER_DEVICE_TYPE_MAX = 0xFFFFFFFF
};

// Classes
class CArray : public CObject {
public:
    CArray(void);
    ~CArray();
    int Step(void) const;
    bool Step(const int step);
    int Total(void) const;
    int Available(void) const;
    int Max(void) const;
    bool IsSorted(const int mode = 0) const;
    int SortMode(void) const;
    void Clear(void);
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    void Sort(const int mode = 0);
protected:
    int m_step_resize;
    int m_data_total;
    int m_data_max;
    int m_sort_mode;
    virtual void QuickSort(int beg, int end, const int mode = 0);
};

class CArrayChar : public CArray {
public:
    CArrayChar(void);
    ~CArrayChar();
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    bool Reserve(const int size);
    bool Resize(const int size);
    bool Shutdown(void);
    bool Add(const char element);
    bool AddArray(const char & src);
    bool AddArray(const CArrayChar * src);
    bool Insert(const char element, const int pos);
    bool InsertArray(const char & src, const int pos);
    bool InsertArray(const CArrayChar * src, const int pos);
    bool AssignArray(const char & src);
    bool AssignArray(const CArrayChar * src);
    char At(const int index) const;
    int Minimum(const int start, const int count) const;
    int Maximum(const int start, const int count) const;
    bool Update(const int index, const char element);
    bool Shift(const int index, const int shift);
    bool Delete(const int index);
    bool DeleteRange(int from, int to);
    bool CompareArray(const char & array) const;
    bool CompareArray(const CArrayChar * array) const;
    bool InsertSort(const char element);
    int Search(const char element) const;
    int SearchGreat(const char element) const;
    int SearchLess(const char element) const;
    int SearchGreatOrEqual(const char element) const;
    int SearchLessOrEqual(const char element) const;
    int SearchFirst(const char element) const;
    int SearchLast(const char element) const;
    int SearchLinear(const char element) const;
protected:
    char m_data;
    virtual void QuickSort(int beg, int end, const int mode = 0);
    int QuickSearch(const char element) const;
    int MemMove(const int dest, const int src, int count);
};

class CArrayColor : public CArray {
public:
    CArrayColor(void);
    ~CArrayColor();
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    bool Reserve(const int size);
    bool Resize(const int size);
    bool Shutdown(void);
    bool Add(const color element);
    bool AddArray(const color & src);
    bool AddArray(const CArrayColor * src);
    bool Insert(const color element, const int pos);
    bool InsertArray(const color & src, const int pos);
    bool InsertArray(const CArrayColor * src, const int pos);
    bool AssignArray(const color & src);
    bool AssignArray(const CArrayColor * src);
    color At(const int index) const;
    int Minimum(const int start, const int count) const;
    int Maximum(const int start, const int count) const;
    bool Update(const int index, const color element);
    bool Shift(const int index, const int shift);
    bool Delete(const int index);
    bool DeleteRange(int from, int to);
    bool CompareArray(const color & array) const;
    bool CompareArray(const CArrayColor * array) const;
    bool InsertSort(const color element);
    int Search(const color element) const;
    int SearchGreat(const color element) const;
    int SearchLess(const color element) const;
    int SearchGreatOrEqual(const color element) const;
    int SearchLessOrEqual(const color element) const;
    int SearchFirst(const color element) const;
    int SearchLast(const color element) const;
    int SearchLinear(const color element) const;
protected:
    color m_data;
    virtual void QuickSort(int beg, int end, const int mode = 0);
    int QuickSearch(const color element) const;
    int MemMove(const int dest, const int src, int count);
};

class CArrayDatetime : public CArray {
public:
    CArrayDatetime(void);
    ~CArrayDatetime();
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    bool Reserve(const int size);
    bool Resize(const int size);
    bool Shutdown(void);
    bool Add(const datetime element);
    bool AddArray(const datetime & src);
    bool AddArray(const CArrayDatetime * src);
    bool Insert(const datetime element, const int pos);
    bool InsertArray(const datetime & src, const int pos);
    bool InsertArray(const CArrayDatetime * src, const int pos);
    bool AssignArray(const datetime & src);
    bool AssignArray(const CArrayDatetime * src);
    datetime At(const int index) const;
    int Minimum(const int start, const int count) const;
    int Maximum(const int start, const int count) const;
    bool Update(const int index, const datetime element);
    bool Shift(const int index, const int shift);
    bool Delete(const int index);
    bool DeleteRange(int from, int to);
    bool CompareArray(const datetime & array) const;
    bool CompareArray(const CArrayDatetime * array) const;
    bool InsertSort(const datetime element);
    int Search(const datetime element) const;
    int SearchGreat(const datetime element) const;
    int SearchLess(const datetime element) const;
    int SearchGreatOrEqual(const datetime element) const;
    int SearchLessOrEqual(const datetime element) const;
    int SearchFirst(const datetime element) const;
    int SearchLast(const datetime element) const;
    int SearchLinear(const datetime element) const;
protected:
    datetime m_data;
    virtual void QuickSort(int beg, int end, const int mode = 0);
    int QuickSearch(const datetime element) const;
    int MemMove(const int dest, const int src, int count);
};

class CArrayDouble : public CArray {
public:
    CArrayDouble(void);
    ~CArrayDouble();
    void Delta(const double delta);
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    bool Reserve(const int size);
    bool Resize(const int size);
    bool Shutdown(void);
    bool Add(const double element);
    bool AddArray(const double & src);
    bool AddArray(const CArrayDouble * src);
    bool Insert(const double element, const int pos);
    bool InsertArray(const double & src, const int pos);
    bool InsertArray(const CArrayDouble * src, const int pos);
    bool AssignArray(const double & src);
    bool AssignArray(const CArrayDouble * src);
    double At(const int index) const;
    int Minimum(const int start, const int count) const;
    int Maximum(const int start, const int count) const;
    bool Update(const int index, const double element);
    bool Shift(const int index, const int shift);
    bool Delete(const int index);
    bool DeleteRange(int from, int to);
    bool CompareArray(const double & array) const;
    bool CompareArray(const CArrayDouble * array) const;
    bool InsertSort(const double element);
    int Search(const double element) const;
    int SearchGreat(const double element) const;
    int SearchLess(const double element) const;
    int SearchGreatOrEqual(const double element) const;
    int SearchLessOrEqual(const double element) const;
    int SearchFirst(const double element) const;
    int SearchLast(const double element) const;
    int SearchLinear(const double element) const;
protected:
    double m_data;
    double m_delta;
    virtual void QuickSort(int beg, int end, const int mode = 0);
    int QuickSearch(const double element) const;
    int MemMove(const int dest, const int src, int count);
};

class CArrayFloat : public CArray {
public:
    CArrayFloat(void);
    ~CArrayFloat();
    void Delta(const float delta);
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    bool Reserve(const int size);
    bool Resize(const int size);
    bool Shutdown(void);
    bool Add(const float element);
    bool AddArray(const float & src);
    bool AddArray(const CArrayFloat * src);
    bool Insert(const float element, const int pos);
    bool InsertArray(const float & src, const int pos);
    bool InsertArray(const CArrayFloat * src, const int pos);
    bool AssignArray(const float & src);
    bool AssignArray(const CArrayFloat * src);
    float At(const int index) const;
    int Minimum(const int start, const int count) const;
    int Maximum(const int start, const int count) const;
    bool Update(const int index, const float element);
    bool Shift(const int index, const int shift);
    bool Delete(const int index);
    bool DeleteRange(int from, int to);
    bool CompareArray(const float & array) const;
    bool CompareArray(const CArrayFloat * array) const;
    bool InsertSort(const float element);
    int Search(const float element) const;
    int SearchGreat(const float element) const;
    int SearchLess(const float element) const;
    int SearchGreatOrEqual(const float element) const;
    int SearchLessOrEqual(const float element) const;
    int SearchFirst(const float element) const;
    int SearchLast(const float element) const;
    int SearchLinear(const float element) const;
protected:
    float m_data;
    float m_delta;
    virtual void QuickSort(int beg, int end, const int mode = 0);
    int QuickSearch(const float element) const;
    int MemMove(const int dest, const int src, int count);
};

class CArrayInt : public CArray {
public:
    CArrayInt(void);
    ~CArrayInt();
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    bool Reserve(const int size);
    bool Resize(const int size);
    bool Shutdown(void);
    bool Add(const int element);
    bool AddArray(const int & src);
    bool AddArray(const CArrayInt * src);
    bool Insert(const int element, const int pos);
    bool InsertArray(const int & src, const int pos);
    bool InsertArray(const CArrayInt * src, const int pos);
    bool AssignArray(const int & src);
    bool AssignArray(const CArrayInt * src);
    int At(const int index) const;
    int Minimum(const int start, const int count) const;
    int Maximum(const int start, const int count) const;
    bool Update(const int index, const int element);
    bool Shift(const int index, const int shift);
    bool Delete(const int index);
    bool DeleteRange(int from, int to);
    bool CompareArray(const int & array) const;
    bool CompareArray(const CArrayInt * array) const;
    bool InsertSort(const int element);
    int Search(const int element) const;
    int SearchGreat(const int element) const;
    int SearchLess(const int element) const;
    int SearchGreatOrEqual(const int element) const;
    int SearchLessOrEqual(const int element) const;
    int SearchFirst(const int element) const;
    int SearchLast(const int element) const;
    int SearchLinear(const int element) const;
protected:
    int m_data;
    virtual void QuickSort(int beg, int end, const int mode = 0);
    int QuickSearch(const int element) const;
    int MemMove(const int dest, const int src, int count);
};

class CArrayLong : public CArray {
public:
    CArrayLong(void);
    ~CArrayLong();
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    bool Reserve(const int size);
    bool Resize(const int size);
    bool Shutdown(void);
    bool Add(const long element);
    bool AddArray(const long & src);
    bool AddArray(const CArrayLong * src);
    bool Insert(const long element, const int pos);
    bool InsertArray(const long & src, const int pos);
    bool InsertArray(const CArrayLong * src, const int pos);
    bool AssignArray(const long & src);
    bool AssignArray(const CArrayLong * src);
    long At(const int index) const;
    int Minimum(const int start, const int count) const;
    int Maximum(const int start, const int count) const;
    bool Update(const int index, const long element);
    bool Shift(const int index, const int shift);
    bool Delete(const int index);
    bool DeleteRange(int from, int to);
    bool CompareArray(const long & array) const;
    bool CompareArray(const CArrayLong * array) const;
    bool InsertSort(const long element);
    int Search(const long element) const;
    int SearchGreat(const long element) const;
    int SearchLess(const long element) const;
    int SearchGreatOrEqual(const long element) const;
    int SearchLessOrEqual(const long element) const;
    int SearchFirst(const long element) const;
    int SearchLast(const long element) const;
    int SearchLinear(const long element) const;
protected:
    long m_data;
    virtual void QuickSort(int beg, int end, const int mode = 0);
    int QuickSearch(const long element) const;
    int MemMove(const int dest, const int src, int count);
};

class CArrayObj : public CArray {
public:
    CArrayObj(void);
    ~CArrayObj();
    bool FreeMode(void) const;
    void FreeMode(const bool mode);
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    virtual bool CreateElement(const int index);
    bool Reserve(const int size);
    bool Resize(const int size);
    bool Shutdown(void);
    bool Add(CObject * element);
    bool AddArray(const CArrayObj * src);
    bool Insert(CObject * element, const int pos);
    bool InsertArray(const CArrayObj * src, const int pos);
    bool AssignArray(const CArrayObj * src);
    bool Update(const int index, CObject * element);
    bool Shift(const int index, const int shift);
    bool Delete(const int index);
    bool DeleteRange(int from, int to);
    void Clear(void);
    bool CompareArray(const CArrayObj * array) const;
    bool InsertSort(CObject * element);
    int Search(const CObject * element) const;
    int SearchGreat(const CObject * element) const;
    int SearchLess(const CObject * element) const;
    int SearchGreatOrEqual(const CObject * element) const;
    int SearchLessOrEqual(const CObject * element) const;
    int SearchFirst(const CObject * element) const;
    int SearchLast(const CObject * element) const;
    CObject *At(const int index) const;
protected:
    bool m_free_mode;
    void QuickSort(int beg, int end, const int mode);
    int QuickSearch(const CObject * element) const;
    int MemMove(const int dest, const int src, int count);
};

class CArrayShort : public CArray {
public:
    CArrayShort(void);
    ~CArrayShort();
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    bool Reserve(const int size);
    bool Resize(const int size);
    bool Shutdown(void);
    bool Add(const short element);
    bool AddArray(const short & src);
    bool AddArray(const CArrayShort * src);
    bool Insert(const short element, const int pos);
    bool InsertArray(const short & src, const int pos);
    bool InsertArray(const CArrayShort * src, const int pos);
    bool AssignArray(const short & src);
    bool AssignArray(const CArrayShort * src);
    short At(const int index) const;
    int Minimum(const int start, const int count) const;
    int Maximum(const int start, const int count) const;
    bool Update(const int index, const short element);
    bool Shift(const int index, const int shift);
    bool Delete(const int index);
    bool DeleteRange(int from, int to);
    bool CompareArray(const short & array) const;
    bool CompareArray(const CArrayShort * array) const;
    bool InsertSort(const short element);
    int Search(const short element) const;
    int SearchGreat(const short element) const;
    int SearchLess(const short element) const;
    int SearchGreatOrEqual(const short element) const;
    int SearchLessOrEqual(const short element) const;
    int SearchFirst(const short element) const;
    int SearchLast(const short element) const;
    int SearchLinear(const short element) const;
protected:
    short m_data;
    virtual void QuickSort(int beg, int end, const int mode = 0);
    int QuickSearch(const short element) const;
    int MemMove(const int dest, const int src, int count);
};

class CArrayString : public CArray {
public:
    CArrayString(void);
    ~CArrayString();
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    bool Reserve(const int size);
    bool Resize(const int size);
    bool Shutdown(void);
    bool Add(const string element);
    bool AddArray(const string & src);
    bool AddArray(const CArrayString * src);
    bool Insert(const string element, const int pos);
    bool InsertArray(const string & src, const int pos);
    bool InsertArray(const CArrayString * src, const int pos);
    bool AssignArray(const string & src);
    bool AssignArray(const CArrayString * src);
    string At(const int index) const;
    bool Update(const int index, const string element);
    bool Shift(const int index, const int shift);
    bool Delete(const int index);
    bool DeleteRange(int from, int to);
    bool CompareArray(const string & array) const;
    bool CompareArray(const CArrayString * array) const;
    bool InsertSort(const string element);
    int Search(const string element) const;
    int SearchGreat(const string element) const;
    int SearchLess(const string element) const;
    int SearchGreatOrEqual(const string element) const;
    int SearchLessOrEqual(const string element) const;
    int SearchFirst(const string element) const;
    int SearchLast(const string element) const;
    int SearchLinear(const string element) const;
protected:
    string m_data;
    virtual void QuickSort(int beg, int end, const int mode = 0);
    int QuickSearch(const string element) const;
    int MemMove(const int dest, const int src, int count);
};

class CArrayUChar : public CArray {
public:
    CArrayUChar(void);
    ~CArrayUChar();
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    bool Reserve(const int size);
    bool Resize(const int size);
    bool Shutdown(void);
    bool Add(const uchar element);
    bool AddArray(const uchar & src);
    bool AddArray(const CArrayUChar * src);
    bool Insert(const uchar element, const int pos);
    bool InsertArray(const uchar & src, const int pos);
    bool InsertArray(const CArrayUChar * src, const int pos);
    bool AssignArray(const uchar & src);
    bool AssignArray(const CArrayUChar * src);
    uchar At(const int index) const;
    int Minimum(const int start, const int count) const;
    int Maximum(const int start, const int count) const;
    bool Update(const int index, const uchar element);
    bool Shift(const int index, const int shift);
    bool Delete(const int index);
    bool DeleteRange(int from, int to);
    bool CompareArray(const uchar & array) const;
    bool CompareArray(const CArrayUChar * array) const;
    bool InsertSort(const uchar element);
    int Search(const uchar element) const;
    int SearchGreat(const uchar element) const;
    int SearchLess(const uchar element) const;
    int SearchGreatOrEqual(const uchar element) const;
    int SearchLessOrEqual(const uchar element) const;
    int SearchFirst(const uchar element) const;
    int SearchLast(const uchar element) const;
    int SearchLinear(const uchar element) const;
protected:
    uchar m_data;
    virtual void QuickSort(int beg, int end, const int mode = 0);
    int QuickSearch(const uchar element) const;
    int MemMove(const int dest, const int src, int count);
};

class CArrayUInt : public CArray {
public:
    CArrayUInt(void);
    ~CArrayUInt();
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    bool Reserve(const int size);
    bool Resize(const int size);
    bool Shutdown(void);
    bool Add(const uint element);
    bool AddArray(const uint & src);
    bool AddArray(const CArrayUInt * src);
    bool Insert(const uint element, const int pos);
    bool InsertArray(const uint & src, const int pos);
    bool InsertArray(const CArrayUInt * src, const int pos);
    bool AssignArray(const uint & src);
    bool AssignArray(const CArrayUInt * src);
    uint At(const int index) const;
    int Minimum(const int start, const int count) const;
    int Maximum(const int start, const int count) const;
    bool Update(const int index, const uint element);
    bool Shift(const int index, const int shift);
    bool Delete(const int index);
    bool DeleteRange(int from, int to);
    bool CompareArray(const uint & array) const;
    bool CompareArray(const CArrayUInt * array) const;
    bool InsertSort(const uint element);
    int Search(const uint element) const;
    int SearchGreat(const uint element) const;
    int SearchLess(const uint element) const;
    int SearchGreatOrEqual(const uint element) const;
    int SearchLessOrEqual(const uint element) const;
    int SearchFirst(const uint element) const;
    int SearchLast(const uint element) const;
    int SearchLinear(const uint element) const;
protected:
    uint m_data;
    virtual void QuickSort(int beg, int end, const int mode = 0);
    int QuickSearch(const uint element) const;
    int MemMove(const int dest, const int src, int count);
};

class CArrayULong : public CArray {
public:
    CArrayULong(void);
    ~CArrayULong();
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    bool Reserve(const int size);
    bool Resize(const int size);
    bool Shutdown(void);
    bool Add(const ulong element);
    bool AddArray(const ulong & src);
    bool AddArray(const CArrayULong * src);
    bool Insert(const ulong element, const int pos);
    bool InsertArray(const ulong & src, const int pos);
    bool InsertArray(const CArrayULong * src, const int pos);
    bool AssignArray(const ulong & src);
    bool AssignArray(const CArrayULong * src);
    ulong At(const int index) const;
    int Minimum(const int start, const int count) const;
    int Maximum(const int start, const int count) const;
    bool Update(const int index, const ulong element);
    bool Shift(const int index, const int shift);
    bool Delete(const int index);
    bool DeleteRange(int from, int to);
    bool CompareArray(const ulong & array) const;
    bool CompareArray(const CArrayULong * array) const;
    bool InsertSort(const ulong element);
    int Search(const ulong element) const;
    int SearchGreat(const ulong element) const;
    int SearchLess(const ulong element) const;
    int SearchGreatOrEqual(const ulong element) const;
    int SearchLessOrEqual(const ulong element) const;
    int SearchFirst(const ulong element) const;
    int SearchLast(const ulong element) const;
    int SearchLinear(const ulong element) const;
protected:
    ulong m_data;
    virtual void QuickSort(int beg, int end, const int mode = 0);
    int QuickSearch(const ulong element) const;
    int MemMove(const int dest, const int src, int count);
};

class CArrayUShort : public CArray {
public:
    CArrayUShort(void);
    ~CArrayUShort();
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    bool Reserve(const int size);
    bool Resize(const int size);
    bool Shutdown(void);
    bool Add(const ushort element);
    bool AddArray(const ushort & src);
    bool AddArray(const CArrayUShort * src);
    bool Insert(const ushort element, const int pos);
    bool InsertArray(const ushort & src, const int pos);
    bool InsertArray(const CArrayUShort * src, const int pos);
    bool AssignArray(const ushort & src);
    bool AssignArray(const CArrayUShort * src);
    ushort At(const int index) const;
    int Minimum(const int start, const int count) const;
    int Maximum(const int start, const int count) const;
    bool Update(const int index, const ushort element);
    bool Shift(const int index, const int shift);
    bool Delete(const int index);
    bool DeleteRange(int from, int to);
    bool CompareArray(const ushort & array) const;
    bool CompareArray(const CArrayUShort * array) const;
    bool InsertSort(const ushort element);
    int Search(const ushort element) const;
    int SearchGreat(const ushort element) const;
    int SearchLess(const ushort element) const;
    int SearchGreatOrEqual(const ushort element) const;
    int SearchLessOrEqual(const ushort element) const;
    int SearchFirst(const ushort element) const;
    int SearchLast(const ushort element) const;
    int SearchLinear(const ushort element) const;
protected:
    ushort m_data;
    virtual void QuickSort(int beg, int end, const int mode = 0);
    int QuickSearch(const ushort element) const;
    int MemMove(const int dest, const int src, int count);
};

class CList : public CObject {
public:
    CList(void);
    ~CList();
    bool FreeMode(void) const;
    void FreeMode(bool mode);
    int Total(void) const;
    bool IsSorted(void) const;
    int SortMode(void) const;
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
    int Add(CObject * new_node);
    int Insert(CObject * new_node, int index);
    int IndexOf(CObject * node);
    bool DeleteCurrent(void);
    bool Delete(int index);
    void Clear(void);
    bool CompareList(CList * List);
    void Sort(int mode);
    bool MoveToIndex(int index);
    bool Exchange(CObject * node1, CObject * node2);
protected:
    int m_curr_idx;
    int m_data_total;
    bool m_free_mode;
    bool m_data_sort;
    int m_sort_mode;
    void QuickSort(int beg, int end, int mode);
};

class CTreeNode : public CObject {
public:
    CTreeNode(void);
    ~CTreeNode();
    void Parent(CTreeNode * node);
    void Left(CTreeNode * node);
    void Right(CTreeNode * node);
    int Balance(void) const;
    int BalanceL(void) const;
    int BalanceR(void) const;
    virtual int Type(void) const;
    int RefreshBalance(void);
    bool SaveNode(const int file_handle);
    bool LoadNode(const int file_handle, CTreeNode * main);
};

class CTree : public CTreeNode {
public:
    CTree(void);
    ~CTree();
    virtual int Type() const;
    bool Detach(CTreeNode * node);
    bool Delete(CTreeNode * node);
    void Clear(void);
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
protected:
    void Balance(CTreeNode * node);
};

class CCanvas {
public:
    CCanvas(void);
    ~CCanvas();
    virtual bool Create(const string name, const int width, const int height, ENUM_COLOR_FORMAT clrfmt = COLOR_FORMAT_XRGB_NOALPHA);
    bool CreateBitmap(const string name, const datetime time, const double price, const int width, const int height, ENUM_COLOR_FORMAT clrfmt = COLOR_FORMAT_XRGB_NOALPHA);
    bool CreateBitmap(const long chart_id, const int subwin, const string name, const datetime time, const double price, const int width, const int height, ENUM_COLOR_FORMAT clrfmt = COLOR_FORMAT_XRGB_NOALPHA);
    bool CreateBitmapLabel(const string name, const int x, const int y, const int width, const int height, ENUM_COLOR_FORMAT clrfmt = COLOR_FORMAT_XRGB_NOALPHA);
    bool CreateBitmapLabel(const long chart_id, const int subwin, const string name, const int x, const int y, const int width, const int height, ENUM_COLOR_FORMAT clrfmt = COLOR_FORMAT_XRGB_NOALPHA);
    virtual bool Attach(const long chart_id, const string objname, ENUM_COLOR_FORMAT clrfmt = COLOR_FORMAT_XRGB_NOALPHA);
    virtual bool Attach(const long chart_id, const string objname, const int width, const int height, ENUM_COLOR_FORMAT clrfmt = COLOR_FORMAT_XRGB_NOALPHA);
    virtual void Destroy(void);
    string ChartObjectName(void) const;
    string ResourceName(void) const;
    int Width(void) const;
    int Height(void) const;
    void Update(const bool redraw = true);
    bool Resize(const int width, const int height);
    void Erase(const uint clr = 0);
    uint PixelGet(const int x, const int y) const;
    void PixelSet(const int x, const int y, const uint clr);
    void LineVertical(int x, int y1, int y2, const uint clr);
    void LineHorizontal(int x1, int x2, int y, const uint clr);
    void Line(int x1, int y1, int x2, int y2, const uint clr);
    void Polyline(int & x, int & y, const uint clr);
    void Polygon(int & x, int & y, const uint clr);
    void Rectangle(int x1, int y1, int x2, int y2, const uint clr);
    void Triangle(int x1, int y1, int x2, int y2, int x3, int y3, const uint clr);
    void Circle(int x, int y, int r, const uint clr);
    void Ellipse(int x1, int y1, int x2, int y2, const uint clr);
    void Arc(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, const uint clr);
    void Arc(int x, int y, int rx, int ry, double fi3, double fi4, const uint clr);
    void Arc(int x, int y, int rx, int ry, double fi3, double fi4, int & x3, int & y3, int & x4, int & y4, const uint clr);
    void Pie(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, const uint clr, const uint fill_clr);
    void Pie(int x, int y, int rx, int ry, double fi3, double fi4, const uint clr, const uint fill_clr);
    void FillRectangle(int x1, int y1, int x2, int y2, const uint clr);
    void FillTriangle(int x1, int y1, int x2, int y2, int x3, int y3, const uint clr);
    void FillPolygon(int & x, int & y, const uint clr);
    void FillCircle(int x, int y, int r, const uint clr);
    void FillEllipse(int x1, int y1, int x2, int y2, const uint clr);
    void Fill(int x, int y, const uint clr);
    void Fill(int x, int y, const uint clr, const uint threshould);
    void PixelSetAA(const double x, const double y, const uint clr);
    void LineAA(const int x1, const int y1, const int x2, const int y2, const uint clr, const uint style = UINT_MAX);
    void PolylineAA(int & x, int & y, const uint clr, const uint style = UINT_MAX);
    void PolygonAA(int & x, int & y, const uint clr, const uint style = UINT_MAX);
    void TriangleAA(const int x1, const int y1, const int x2, const int y2, const int x3, const int y3, const uint clr, const uint style = UINT_MAX);
    void CircleAA(const int x, const int y, const double r, const uint clr, const uint style = UINT_MAX);
    void EllipseAA(const double x1, const double y1, const double x2, const double y2, const uint clr, const uint style = UINT_MAX);
    void LineWu(int x1, int y1, int x2, int y2, const uint clr, const uint style = UINT_MAX);
    void PolylineWu(const int & x, const int & y, const uint clr, const uint style = UINT_MAX);
    void PolygonWu(const int & x, const int & y, const uint clr, const uint style = UINT_MAX);
    void TriangleWu(const int x1, const int y1, const int x2, const int y2, const int x3, const int y3, const uint clr, const uint style = UINT_MAX);
    void CircleWu(const int x, const int y, const double r, const uint clr, const uint style = UINT_MAX);
    void EllipseWu(const int x1, const int y1, const int x2, const int y2, const uint clr, const uint style = UINT_MAX);
    void LineThickVertical(const int x, const int y1, const int y2, const uint clr, const int size, const uint style, ENUM_LINE_END end_style);
    void LineThickHorizontal(const int x1, const int x2, const int y, const uint clr, const int size, const uint style, ENUM_LINE_END end_style);
    void LineThick(const int x1, const int y1, const int x2, const int y2, const uint clr, const int size, const uint style, ENUM_LINE_END end_style);
    void PolylineThick(const int & x, const int & y, const uint clr, const int size, const uint style, ENUM_LINE_END end_style);
    void PolygonThick(const int & x, const int & y, const uint clr, const int size, const uint style, ENUM_LINE_END end_style);
    void PolylineSmooth(const int & x, const int & y, const uint clr, const int size, ENUM_LINE_STYLE style = STYLE_SOLID, ENUM_LINE_END end_style = LINE_END_ROUND, double tension = 0.5, double step = 10);
    void PolygonSmooth(int & x, int & y, const uint clr, const int size, ENUM_LINE_STYLE style = STYLE_SOLID, ENUM_LINE_END end_style = LINE_END_ROUND, double tension = 0.5, double step = 10);
    void BitBlt(int dst_x, int dst_y, const uint & src, int src_width, int src_height, int src_x, int src_y, int src_dx, int src_dy, uint mode = 0);
    bool FontSet(const string name, const int size, const uint flags = 0, const uint angle = 0);
    bool FontNameSet(string name);
    bool FontSizeSet(int size);
    bool FontFlagsSet(uint flags);
    bool FontAngleSet(uint angle);
    void FontGet(string & name, int & size, uint & flags, uint & angle);
    string FontNameGet(void) const;
    int FontSizeGet(void) const;
    uint FontFlagsGet(void) const;
    uint FontAngleGet(void) const;
    void TextOut(int x, int y, string text, const uint clr, uint alignment = 0);
    int TextWidth(const string text);
    int TextHeight(const string text);
    void TextSize(const string text, int & width, int & height);
    static uint GetDefaultColor(const int i);
    void TransparentLevelSet(const uchar value);
    bool LoadFromFile(const string filename);
    uint LineStyleGet(void) const;
    void LineStyleSet(const uint style);
    static bool LoadBitmap(const string filename, uint & data, int & width, int & height);
protected:
    long m_chart_id;
    string m_objname;
    ENUM_OBJECT m_objtype;
    string m_rcname;
    int m_width;
    int m_height;
    ENUM_COLOR_FORMAT m_format;
    string m_fontname;
    int m_fontsize;
    uint m_fontflags;
    uint m_fontangle;
    uint m_pixels;
    virtual double FilterFunction(const double x);
};

struct BitmapHeader {
public:
    ushort type;
    uint size;
    uint reserv;
    uint offbits;
    uint imgSSize;
    uint imgWidth;
    uint imgHeight;
    ushort imgPlanes;
    ushort imgBitCount;
    uint imgCompression;
    uint imgSizeImage;
    uint imgXPelsPerMeter;
    uint imgYPelsPerMeter;
    uint imgClrUsed;
    uint imgClrImportant;
};

class CChartCanvas : public CCanvas {
public:
    CChartCanvas(void);
    ~CChartCanvas();
    virtual bool Create(const string name, const int width, const int height, ENUM_COLOR_FORMAT clrfmt = COLOR_FORMAT_XRGB_NOALPHA);
    uint ColorBackground(void) const;
    void ColorBackground(const uint value);
    uint ColorBorder(void) const;
    void ColorBorder(const uint value);
    uint ColorText(void) const;
    void ColorText(const uint value);
    uint ColorGrid(void) const;
    void ColorGrid(const uint value);
    uint MaxData(void) const;
    void MaxData(const uint value);
    uint MaxDescrLen(void) const;
    void MaxDescrLen(const uint value);
    void AllowedShowFlags(const uint flags);
    uint ShowFlags(void) const;
    void ShowFlags(const uint flags);
    bool IsShowLegend(void) const;
    bool IsShowScaleLeft(void) const;
    bool IsShowScaleRight(void) const;
    bool IsShowScaleTop(void) const;
    bool IsShowScaleBottom(void) const;
    bool IsShowGrid(void) const;
    bool IsShowDescriptors(void) const;
    bool IsShowPercent(void) const;
    void ShowLegend(const bool flag = true);
    void ShowScaleLeft(const bool flag = true);
    void ShowScaleRight(const bool flag = true);
    void ShowScaleTop(const bool flag = true);
    void ShowScaleBottom(const bool flag = true);
    void ShowGrid(const bool flag = true);
    void ShowDescriptors(const bool flag = true);
    void ShowValue(const bool flag = true);
    void ShowPercent(const bool flag = true);
    void LegendAlignment(const ENUM_ALIGNMENT value);
    void Accumulative(const bool flag = true);
    double VScaleMin(void) const;
    void VScaleMin(const double value);
    double VScaleMax(void) const;
    void VScaleMax(const double value);
    uint NumGrid(void) const;
    void NumGrid(const uint value);
    void VScaleParams(const double max, const double min, const uint grid);
    int DataOffset(void) const;
    void DataOffset(const int value);
    uint DataTotal(void) const;
    bool DescriptorUpdate(const uint pos, const string descr);
    bool ColorUpdate(const uint pos, const uint clr);
protected:
    uint m_color_background;
    uint m_color_border;
    uint m_color_text;
    uint m_color_grid;
    uint m_max_data;
    uint m_max_descr_len;
    uint m_allowed_show_flags;
    uint m_show_flags;
    ENUM_ALIGNMENT m_legend_alignment;
    uint m_threshold_drawing;
    bool m_accumulative;
    double m_v_scale_min;
    double m_v_scale_max;
    uint m_num_grid;
    int m_scale_digits;
    int m_data_offset;
    uint m_data_total;
    CArrayUInt m_colors;
    CArrayString m_descriptors;
    CArrayInt m_index;
    uint m_index_size;
    double m_sum;
    double m_others;
    uint m_max_descr_width;
    uint m_max_value_width;
    CRect m_data_area;
    double m_scale_x;
    int m_x_min;
    int m_x_0;
    int m_x_max;
    int m_dx_grid;
    double m_scale_y;
    int m_y_min;
    int m_y_0;
    int m_y_max;
    int m_dy_grid;
    string m_scale_text;
    virtual void ValuesCheck(void);
    virtual void Redraw(void);
    virtual void DrawBackground(void);
    virtual void DrawLegend(void);
    int DrawLegendVertical(const int w, const int h);
    int DrawLegendHorizontal(const int w, const int h);
    virtual void CalcScales(void);
    virtual void DrawScales(void);
    virtual int DrawScaleLeft(const bool draw = true);
    virtual int DrawScaleRight(const bool draw = true);
    virtual int DrawScaleTop(const bool draw = true);
    virtual int DrawScaleBottom(const bool draw = true);
    virtual void DrawGrid(void);
    virtual void DrawDescriptors(void);
    virtual void DrawChart(void);
    virtual void DrawData(const uint idx = 0);
};

class CHistogramChart : public CChartCanvas {
public:
    CHistogramChart(void);
    ~CHistogramChart();
    virtual bool Create(const string name, const int width, const int height, ENUM_COLOR_FORMAT clrfmt = COLOR_FORMAT_ARGB_NORMALIZE);
    void Gradient(const bool flag = true);
    void BarGap(const uint value);
    void BarMinSize(const uint value);
    void BarBorder(const uint value);
    bool SeriesAdd(const double & value, const string descr = "", const uint clr = 0);
    bool SeriesInsert(const uint pos, const double & value, const string descr = "", const uint clr = 0);
    bool SeriesUpdate(const uint pos, const double & value, const string descr = NULL, const uint clr = 0);
    bool SeriesDelete(const uint pos);
    bool ValueUpdate(const uint series, const uint pos, double value);
protected:
    virtual void DrawData(const uint idx);
    void DrawBar(const int x, const int y, const int w, const int h, const uint clr);
    void GradientBrush(const int size, const uint fill_clr);
};

class CLineChart : public CChartCanvas {
public:
    CLineChart(void);
    ~CLineChart();
    virtual bool Create(const string name, const int width, const int height, ENUM_COLOR_FORMAT clrfmt = COLOR_FORMAT_ARGB_NORMALIZE);
    void Filled(const bool flag = true);
    bool SeriesAdd(const double & value, const string descr = "", const uint clr = 0);
    bool SeriesInsert(const uint pos, const double & value, const string descr = "", const uint clr = 0);
    bool SeriesUpdate(const uint pos, const double & value, const string descr = NULL, const uint clr = 0);
    bool SeriesDelete(const uint pos);
    bool ValueUpdate(const uint series, const uint pos, double value);
protected:
    virtual void DrawChart(void);
    virtual void DrawData(const uint index = 0);
};

class CPieChart : public CChartCanvas {
public:
    CPieChart(void);
    ~CPieChart();
    virtual bool Create(const string name, const int width, const int height, ENUM_COLOR_FORMAT clrfmt = COLOR_FORMAT_XRGB_NOALPHA);
    bool SeriesSet(const double & value, const string & text, const uint & clr);
    bool ValueAdd(const double value, const string descr = "", const uint clr = 0);
    bool ValueInsert(const uint pos, const double value, const string descr = "", const uint clr = 0);
    bool ValueUpdate(const uint pos, const double value, const string descr = NULL, const uint clr = 0);
    bool ValueDelete(const uint pos);
protected:
    virtual void DrawChart(void);
    void DrawPie(double fi3, double fi4, int idx, CPoint & p, const uint clr);
    string LabelMake(const string text, const double value, const bool to_left);
};

class CDXMesh : public CDXObject {
public:
    CDXMesh(void);
    ~CDXMesh();
    bool Create(CDXDispatcher & dispatcher, CDXInput* buffer_scene, const DXVertex & vertices, const uint & indices, ENUM_DX_PRIMITIVE_TOPOLOGY topology = DX_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
    bool Create(CDXDispatcher & dispatcher, CDXInput* buffer_scene, string obj_path, float scale = 1.0f, bool inverse_winding = false);
    bool VerticesSet(const DXVertex & vertices);
    bool IndicesSet(const uint & indices);
    bool TopologySet(ENUM_DX_PRIMITIVE_TOPOLOGY topology);
    void TransformMatrixGet(DXMatrix & mat) const;
    void TransformMatrixSet(const DXMatrix & mat);
    void DiffuseColorGet(DXColor & clr) const;
    void DiffuseColorSet(const DXColor & clr);
    void SpecularColorGet(DXColor & clr) const;
    void SpecularColorSet(const DXColor & clr);
    void SpecularPowerGet(float & power) const;
    void SpecularPowerSet(float power);
    void EmissionColorGet(DXColor & clr) const;
    void EmissionColorSet(const DXColor & clr);
    virtual bool Render(void);
    bool TextureSet(CDXDispatcher & dispatcher, string path, uint data_x = 0, uint data_y = 0, uint data_width = 0, uint data_height = 0);
    bool TextureSet(CDXDispatcher & dispatcher, ENUM_DX_FORMAT format, uint width, uint height, const uint & data, uint data_x = 0, uint data_y = 0, uint data_width = 0, uint data_height = 0);
    void TextureDelete();
    virtual void Shutdown(void);
protected:
    DXMatrix m_transform_matrix;
    DXColor m_diffuse_color;
    DXColor m_emission_color;
    DXColor m_specular_color;
    float m_specular_power;
    ENUM_DX_PRIMITIVE_TOPOLOGY m_topology;
};

class CDXBox : public CDXMesh {
public:
    CDXBox();
    ~CDXBox();
    bool Create(CDXDispatcher & dispatcher, CDXInput* buffer_scene, const DXVector3 & from, const DXVector3 & to);
    bool Update(const DXVector3 & from, const DXVector3 & to);
};

class CDXVertexBuffer : public CDXHandleShared {
public:
    virtual ~CDXVertexBuffer();
    bool Render(uint start = 0, uint count = WHOLE_ARRAY);
    void Shutdown(void);
};

class CDXIndexBuffer : public CDXHandleShared {
public:
    virtual ~CDXIndexBuffer();
    bool Create(int context_handle, const uint & indices, uint start = 0, uint count = WHOLE_ARRAY);
    bool Render(uint start = 0, uint count = WHOLE_ARRAY);
    void Shutdown(void);
};

class CDXDispatcher : public CDXObjectBase {
public:
    CDXDispatcher(void);
    ~CDXDispatcher();
    bool Create(int context);
    void Destroy(void);
    void Check(void);
    int DXContext(void) const;
    CDXIndexBuffer* IndexBufferCreate(const uint & indicies, uint start = 0, uint count = WHOLE_ARRAY);
    CDXTexture* TextureCreateFromFile(string path, uint data_x = 0, uint data_y = 0, uint data_width = 0, uint data_height = 0);
    CDXTexture* TextureCreateFromData(ENUM_DX_FORMAT format, uint width, uint height, const uint & data, uint data_x = 0, uint data_y = 0, uint data_width = 0, uint data_height = 0);
protected:
    CDXObjectBase m_dx_resources;
};

struct DXColor {
public:
    float r;
    float g;
    float b;
    float a;
    DXColor(void);
    DXColor(float red, float green, float blue, float alpha);
    DXColor(const DXVector4 & v);
    DXColor(const DXVector3 & v);
    DXColor(const DXColor   & c);
};

struct DXPlane {
public:
    float a;
    float b;
    float c;
    float d;
};

struct DXVector2 {
public:
    float x;
    float y;
    DXVector2(void);
    DXVector2(float v);
    DXVector2(float vx, float vy);
    DXVector2(const DXVector3 & v);
    DXVector2(const DXVector4 & v);
};

struct DXVector3 {
public:
    float x;
    float y;
    float z;
    DXVector3(void);
    DXVector3(float v);
    DXVector3(float vx, float vy, float vz);
    DXVector3(const DXVector2 & v);
    DXVector3(const DXVector4 & v);
};

struct DXVector4 {
public:
    float x;
    float y;
    float z;
    float w;
    DXVector4(void);
    DXVector4(float v);
    DXVector4(float vx, float vy, float vz, float vw);
    DXVector4(const DXVector2 & v);
    DXVector4(const DXVector3 & v);
    DXVector4(const DXVector4 & v);
};

struct DXMatrix {
};

struct DXQuaternion {
public:
    float x;
    float y;
    float z;
    float w;
};

struct DViewport {
public:
    ulong x;
    ulong y;
    ulong width;
    ulong height;
    float minz;
    float maxz;
};

class CDXSurface : public CDXMesh {
public:
    enum EN_SURFACE_FLAGS;
    enum EN_COLOR_SCHEME;
    CDXSurface();
    ~CDXSurface();
    bool Create(CDXDispatcher & dispatcher, CDXInput* buffer_scene, double & data, uint m_data_widht, uint m_data_height, float data_range, const DXVector3 & from, const DXVector3 & to, DXVector2 & texture_size, uint flags = SF_NONE, EN_COLOR_SCHEME color_scheme = CS_NONE);
    bool Update(double & data, uint m_data_widht, uint m_data_height, float data_range, const DXVector3 & from, const DXVector3 & to, DXVector2 & texture_size, uint flags = 0, EN_COLOR_SCHEME color_scheme = CS_NONE);
protected:
    uint m_data_width;
    uint m_data_height;
    uint m_flags;
    EN_COLOR_SCHEME m_color_scheme;
};

struct OBJFaceType {
public:
    int total;
    int v;
    int t;
    int n;
};

struct GRADIENT_COLOR {
public:
    uint clr;
    uint pos;
};

struct GRADIENT_SIZE {
public:
    uint size;
    uint pos;
};

class CFlameCanvas : public CCanvas {
public:
    CFlameCanvas(void);
    ~CFlameCanvas();
    bool FlameCreate(const string name, const datetime time, const int future_bars, const int back_bars = 0);
    void RatesTotal(const int value);
    void PaletteSet(uint clr = 0xFF0000);
    void FlameDraw(const double & prices, const int width, const int lenght);
    void FlameSet(datetime xb1, double yb1, datetime xe1, double ye1, datetime xb2, double yb2, datetime xe2, double ye2);
    void ChartEventHandler(const int id, const long & lparam, const double & dparam, const string & sparam);
protected:
    bool Resize(void);
    void ChartScale(void);
    void FlameSet(void);
    void CloudDraw(const double & prices, const int width, const int lenght, GRADIENT_SIZE & size, GRADIENT_COLOR & gradient, const uchar t_level = 255, const bool custom_gradient = true);
    void FlameDraw(const int width, const int lenght, GRADIENT_SIZE & size, GRADIENT_COLOR & gradient);
    void GradientVertical(const int xb, const int xe, const int yb1, const int ye1, const int yb2, const int ye2, const GRADIENT_COLOR & gradient);
    void GradientVerticalLine(int x, int y1, int y2, const GRADIENT_COLOR & gradient);
    void GradientVerticalLineMonochrome(int x, int y1, int y2, uint clr1, uint clr2);
    void FlameCreate(void);
    void FlameCalculate(void);
    void Delay(const uint value);
};

class CChartObject : public CObject {
public:
    CChartObject(void);
    ~CChartObject();
    virtual int Type(void) const;
    long ChartId(void) const;
    int Window(void) const;
    string Name(void) const;
    bool Name(const string name);
    int NumPoints(void) const;
    bool Attach(long chart_id, const string name, const int window, const int points);
    bool SetPoint(const int point, const datetime time, const double price) const;
    bool Delete(void);
    void Detach(void);
    datetime Time(const int point) const;
    bool Time(const int point, const datetime time) const;
    double Price(const int point) const;
    bool Price(const int point, const double price) const;
    color Color(void) const;
    bool Color(const color new_color) const;
    ENUM_LINE_STYLE Style(void) const;
    bool Style(const ENUM_LINE_STYLE new_style) const;
    int Width(void) const;
    bool Width(const int new_width) const;
    bool Background(void) const;
    bool Background(const bool new_back) const;
    bool Fill(void) const;
    bool Fill(const bool new_fill) const;
    long Z_Order(void) const;
    bool Z_Order(const long value) const;
    bool Selected(void) const;
    bool Selected(const bool new_sel) const;
    bool Selectable(void) const;
    bool Selectable(const bool new_sel) const;
    string Description(void) const;
    bool Description(const string new_text) const;
    string Tooltip(void) const;
    bool Tooltip(const string new_text) const;
    int Timeframes(void) const;
    virtual bool Timeframes(const int timeframes) const;
    datetime CreateTime(void) const;
    int LevelsCount(void) const;
    bool LevelsCount(const int new_count) const;
    color LevelColor(const int level) const;
    bool LevelColor(const int level, const color new_color) const;
    ENUM_LINE_STYLE LevelStyle(const int level) const;
    bool LevelStyle(const int level, const ENUM_LINE_STYLE new_style) const;
    int LevelWidth(const int level) const;
    bool LevelWidth(const int level, const int new_width) const;
    double LevelValue(const int level) const;
    bool LevelValue(const int level, const double new_value) const;
    string LevelDescription(const int level) const;
    bool LevelDescription(const int level, const string new_text) const;
    long GetInteger(const ENUM_OBJECT_PROPERTY_INTEGER prop_id, const int modifier = -1) const;
    bool GetInteger(const ENUM_OBJECT_PROPERTY_INTEGER prop_id, const int modifier, long & value) const;
    bool SetInteger(const ENUM_OBJECT_PROPERTY_INTEGER prop_id, const int modifier, const long value) const;
    bool SetInteger(const ENUM_OBJECT_PROPERTY_INTEGER prop_id, const long value) const;
    double GetDouble(const ENUM_OBJECT_PROPERTY_DOUBLE prop_id, const int modifier = -1) const;
    bool GetDouble(const ENUM_OBJECT_PROPERTY_DOUBLE prop_id, const int modifier, double & value) const;
    bool SetDouble(const ENUM_OBJECT_PROPERTY_DOUBLE prop_id, const int modifier, const double value) const;
    bool SetDouble(const ENUM_OBJECT_PROPERTY_DOUBLE prop_id, const double value) const;
    string GetString(const ENUM_OBJECT_PROPERTY_STRING prop_id, const int modifier = -1) const;
    bool GetString(const ENUM_OBJECT_PROPERTY_STRING prop_id, const int modifier, string & value) const;
    bool SetString(const ENUM_OBJECT_PROPERTY_STRING prop_id, const int modifier, const string value) const;
    bool SetString(const ENUM_OBJECT_PROPERTY_STRING prop_id, const string value) const;
    bool ShiftObject(const datetime d_time, const double d_price) const;
    bool ShiftPoint(const int point, const datetime d_time, const double d_price) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
protected:
    long m_chart_id;
    int m_window;
    string m_name;
    int m_num_points;
};

class CChartObjectText : public CChartObject {
public:
    CChartObjectText(void);
    ~CChartObjectText();
    bool Create(long chart_id, const string name, const int window, const datetime time, const double price);
    virtual int Type(void) const;
    double Angle(void) const;
    bool Angle(const double angle) const;
    string Font(void) const;
    bool Font(const string font) const;
    int FontSize(void) const;
    bool FontSize(const int size) const;
    ENUM_ANCHOR_POINT Anchor(void) const;
    bool Anchor(const ENUM_ANCHOR_POINT anchor) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectLabel : public CChartObjectText {
public:
    CChartObjectLabel(void);
    ~CChartObjectLabel();
    bool Create(long chart_id, const string name, const int window, const int X, const int Y);
    virtual int Type(void) const;
    int X_Distance(void) const;
    bool X_Distance(const int X) const;
    int Y_Distance(void) const;
    bool Y_Distance(const int Y) const;
    int X_Size(void) const;
    int Y_Size(void) const;
    ENUM_BASE_CORNER Corner(void) const;
    bool Corner(const ENUM_BASE_CORNER corner) const;
    datetime Time(const int point) const;
    bool Time(const int point, const datetime time) const;
    double Price(const int point) const;
    bool Price(const int point, const double price) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectEdit : public CChartObjectLabel {
public:
    CChartObjectEdit(void);
    ~CChartObjectEdit();
    bool Create(long chart_id, const string name, const int window, const int X, const int Y, const int sizeX, const int sizeY);
    virtual int Type(void) const;
    bool X_Size(const int X) const;
    int X_Size(void) const;
    bool Y_Size(const int Y) const;
    int Y_Size(void) const;
    color BackColor(void) const;
    bool BackColor(const color new_color) const;
    color BorderColor(void) const;
    bool BorderColor(const color new_color) const;
    bool ReadOnly(void) const;
    bool ReadOnly(const bool flag) const;
    ENUM_ALIGN_MODE TextAlign(void) const;
    bool TextAlign(const ENUM_ALIGN_MODE align) const;
    bool Angle(const double angle) const;
    double Angle(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectButton : public CChartObjectEdit {
public:
    CChartObjectButton(void);
    ~CChartObjectButton();
    virtual int Type(void) const;
    bool State(void) const;
    bool State(const bool state) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectPanel : public CChartObjectButton {
public:
    CChartObjectPanel();
    ~CChartObjectPanel();
    bool Attach(CChartObjectLabel * chart_object);
    bool X_Distance(const int X);
    int X_Distance(void) const;
    bool Y_Distance(const int Y);
    int Y_Distance(void) const;
    int X_Size() const;
    int X_Size(const int Y) const;
    int Y_Size() const;
    int Y_Size(const int Y) const;
    int Timeframes(void) const;
    virtual bool Timeframes(const int timeframes);
    bool State(const bool state);
    bool State(void) const;
    bool CheckState();
protected:
    CArrayObj m_attachment;
    CArrayInt m_dX;
    CArrayInt m_dY;
    bool m_expanded;
};

class CChartObjectArrow : public CChartObject {
public:
    CChartObjectArrow(void);
    ~CChartObjectArrow();
    bool Create(long chart_id, const string name, const int window, const datetime time, const double price, const char code);
    virtual int Type(void) const;
    char ArrowCode(void) const;
    virtual bool ArrowCode(const char code) const;
    ENUM_ARROW_ANCHOR Anchor(void) const;
    virtual bool Anchor(const ENUM_ARROW_ANCHOR anchor) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectArrowThumbUp : public CChartObjectArrow {
public:
    CChartObjectArrowThumbUp(void);
    ~CChartObjectArrowThumbUp();
    bool Create(long chart_id, const string name, const int window, const datetime time, const double price);
    virtual int Type(void) const;
    virtual bool ArrowCode(const char code) const;
    char ArrowCode(void) const;
};

class CChartObjectArrowThumbDown : public CChartObjectArrow {
public:
    CChartObjectArrowThumbDown(void);
    ~CChartObjectArrowThumbDown();
    bool Create(long chart_id, const string name, const int window, const datetime time, const double price);
    virtual int Type(void) const;
    virtual bool ArrowCode(const char code) const;
    char ArrowCode(void) const;
};

class CChartObjectArrowUp : public CChartObjectArrow {
public:
    CChartObjectArrowUp(void);
    ~CChartObjectArrowUp();
    bool Create(long chart_id, const string name, const int window, const datetime time, const double price);
    virtual int Type(void) const;
    virtual bool ArrowCode(const char code) const;
    char ArrowCode(void) const;
};

class CChartObjectArrowDown : public CChartObjectArrow {
public:
    CChartObjectArrowDown(void);
    ~CChartObjectArrowDown();
    bool Create(long chart_id, const string name, const int window, const datetime time, const double price);
    virtual int Type(void) const;
    virtual bool ArrowCode(const char code) const;
    char ArrowCode(void) const;
};

class CChartObjectArrowStop : public CChartObjectArrow {
public:
    CChartObjectArrowStop(void);
    ~CChartObjectArrowStop();
    bool Create(long chart_id, const string name, const int window, const datetime time, const double price);
    virtual int Type(void) const;
    virtual bool ArrowCode(const char code) const;
    char ArrowCode(void) const;
};

class CChartObjectArrowCheck : public CChartObjectArrow {
public:
    CChartObjectArrowCheck(void);
    ~CChartObjectArrowCheck();
    bool Create(long chart_id, const string name, const int window, const datetime time, const double price);
    virtual int Type(void) const;
    virtual bool ArrowCode(const char code) const;
    char ArrowCode(void) const;
};

class CChartObjectArrowLeftPrice : public CChartObjectArrow {
public:
    CChartObjectArrowLeftPrice(void);
    ~CChartObjectArrowLeftPrice();
    bool Create(long chart_id, const string name, const int window, const datetime time, const double price);
    virtual int Type(void) const;
    virtual bool ArrowCode(const char code) const;
    char ArrowCode(void) const;
    virtual bool Anchor(const ENUM_ARROW_ANCHOR anchor) const;
    ENUM_ARROW_ANCHOR Anchor(void) const;
};

class CChartObjectArrowRightPrice : public CChartObjectArrow {
public:
    CChartObjectArrowRightPrice(void);
    ~CChartObjectArrowRightPrice();
    bool Create(long chart_id, const string name, const int window, const datetime time, const double price);
    virtual int Type(void) const;
    virtual bool ArrowCode(const char code) const;
    char ArrowCode(void) const;
    virtual bool Anchor(const ENUM_ARROW_ANCHOR anchor) const;
    ENUM_ARROW_ANCHOR Anchor(void) const;
};

class CChartObjectBitmap : public CChartObject {
public:
    CChartObjectBitmap(void);
    ~CChartObjectBitmap();
    string BmpFile(void) const;
    bool BmpFile(const string name) const;
    int X_Offset(void) const;
    bool X_Offset(const int X) const;
    int Y_Offset(void) const;
    bool Y_Offset(const int Y) const;
    bool Create(long chart_id, const string name, const int window, const datetime time, const double price);
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectBmpLabel : public CChartObject {
public:
    CChartObjectBmpLabel(void);
    ~CChartObjectBmpLabel();
    int X_Distance(void) const;
    bool X_Distance(const int X) const;
    int Y_Distance(void) const;
    bool Y_Distance(const int Y) const;
    int X_Size(void) const;
    int Y_Size(void) const;
    ENUM_BASE_CORNER Corner(void) const;
    bool Corner(const ENUM_BASE_CORNER corner) const;
    string BmpFileOn(void) const;
    bool BmpFileOn(const string name) const;
    string BmpFileOff(void) const;
    bool BmpFileOff(const string name) const;
    bool State(void) const;
    bool State(const bool state) const;
    int X_Offset(void) const;
    bool X_Offset(const int X) const;
    int Y_Offset(void) const;
    bool Y_Offset(const int Y) const;
    bool Time(const datetime time) const;
    bool Price(const double price) const;
    bool Create(long chart_id, const string name, const int window, const int X, const int Y);
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectTrend : public CChartObject {
public:
    CChartObjectTrend(void);
    ~CChartObjectTrend();
    bool RayLeft(void) const;
    bool RayLeft(const bool new_sel) const;
    bool RayRight(void) const;
    bool RayRight(const bool new_sel) const;
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2);
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectChannel : public CChartObjectTrend {
public:
    CChartObjectChannel(void);
    ~CChartObjectChannel();
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2, const datetime time3, const double price3);
    virtual int Type(void) const;
};

class CChartObjectStdDevChannel : public CChartObjectTrend {
public:
    CChartObjectStdDevChannel(void);
    ~CChartObjectStdDevChannel();
    double Deviations(void) const;
    bool Deviations(const double deviation) const;
    bool Create(long chart_id, const string name, const int window, const datetime time1, const datetime time2, const double deviation);
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectRegression : public CChartObjectTrend {
public:
    CChartObjectRegression(void);
    ~CChartObjectRegression();
    bool Create(long chart_id, const string name, const int window, const datetime time1, const datetime time2);
    virtual int Type(void) const;
};

class CChartObjectPitchfork : public CChartObjectTrend {
public:
    CChartObjectPitchfork(void);
    ~CChartObjectPitchfork();
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2, const datetime time3, const double price3);
    virtual int Type(void) const;
};

class CChartObjectElliottWave3 : public CChartObject {
public:
    CChartObjectElliottWave3(void);
    ~CChartObjectElliottWave3();
    ENUM_ELLIOT_WAVE_DEGREE Degree(void) const;
    bool Degree(const ENUM_ELLIOT_WAVE_DEGREE degree) const;
    bool Lines(void) const;
    bool Lines(const bool lines) const;
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2, const datetime time3, const double price3);
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectElliottWave5 : public CChartObjectElliottWave3 {
public:
    CChartObjectElliottWave5(void);
    ~CChartObjectElliottWave5();
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2, const datetime time3, const double price3, const datetime time4, const double price4, const datetime time5, const double price5);
    virtual int Type(void) const;
};

class CChartObjectFibo : public CChartObjectTrend {
public:
    CChartObjectFibo(void);
    ~CChartObjectFibo();
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2);
    virtual int Type(void) const;
};

class CChartObjectFiboTimes : public CChartObject {
public:
    CChartObjectFiboTimes(void);
    ~CChartObjectFiboTimes();
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2);
    virtual int Type(void) const;
};

class CChartObjectFiboFan : public CChartObject {
public:
    CChartObjectFiboFan(void);
    ~CChartObjectFiboFan();
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2);
    virtual int Type(void) const;
};

class CChartObjectFiboArc : public CChartObject {
public:
    CChartObjectFiboArc(void);
    ~CChartObjectFiboArc();
    double Scale(void) const;
    bool Scale(const double scale) const;
    bool Ellipse(void) const;
    bool Ellipse(const bool ellipse) const;
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2, const double scale);
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectFiboChannel : public CChartObjectTrend {
public:
    CChartObjectFiboChannel(void);
    ~CChartObjectFiboChannel();
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2, const datetime time3, const double price3);
    virtual int Type(void) const;
};

class CChartObjectFiboExpansion : public CChartObjectTrend {
public:
    CChartObjectFiboExpansion(void);
    ~CChartObjectFiboExpansion();
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2, const datetime time3, const double price3);
    virtual int Type(void) const;
};

class CChartObjectTrendByAngle : public CChartObjectTrend {
public:
    CChartObjectTrendByAngle(void);
    ~CChartObjectTrendByAngle();
    double Angle(void) const;
    bool Angle(const double angle) const;
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2);
    virtual int Type(void) const;
};

class CChartObjectGannLine : public CChartObjectTrendByAngle {
public:
    CChartObjectGannLine(void);
    ~CChartObjectGannLine();
    double PipsPerBar(void) const;
    bool PipsPerBar(const double ppb) const;
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double ppb);
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectGannFan : public CChartObjectTrend {
public:
    CChartObjectGannFan(void);
    ~CChartObjectGannFan();
    double PipsPerBar(void) const;
    bool PipsPerBar(const double ppb) const;
    bool Downtrend(void) const;
    bool Downtrend(const bool downtrend) const;
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double ppb);
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectGannGrid : public CChartObjectTrend {
public:
    CChartObjectGannGrid(void);
    ~CChartObjectGannGrid();
    double PipsPerBar(void) const;
    bool PipsPerBar(const double ppb) const;
    bool Downtrend(void) const;
    bool Downtrend(const bool downtrend) const;
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double ppb);
    virtual int Type(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectVLine : public CChartObject {
public:
    CChartObjectVLine(void);
    ~CChartObjectVLine();
    bool Create(long chart_id, const string name, const int window, const datetime time);
    virtual int Type(void) const;
};

class CChartObjectHLine : public CChartObject {
public:
    CChartObjectHLine(void);
    ~CChartObjectHLine();
    bool Create(long chart_id, const string name, const int window, const double price);
    virtual int Type(void) const;
};

class CChartObjectCycles : public CChartObject {
public:
    CChartObjectCycles(void);
    ~CChartObjectCycles();
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2);
    virtual int Type(void) const;
};

class CChartObjectRectangle : public CChartObject {
public:
    CChartObjectRectangle(void);
    ~CChartObjectRectangle();
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2);
    virtual int Type(void) const;
};

class CChartObjectTriangle : public CChartObject {
public:
    CChartObjectTriangle(void);
    ~CChartObjectTriangle();
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2, const datetime time3, const double price3);
    virtual int Type(void) const;
};

class CChartObjectEllipse : public CChartObject {
public:
    CChartObjectEllipse(void);
    ~CChartObjectEllipse();
    bool Create(long chart_id, const string name, const int window, const datetime time1, const double price1, const datetime time2, const double price2, const datetime time3, const double price3);
    virtual int Type(void) const;
};

class CChartObjectRectLabel : public CChartObjectLabel {
public:
    CChartObjectRectLabel(void);
    ~CChartObjectRectLabel();
    bool Create(long chart_id, const string name, const int window, const int X, const int Y, const int sizeX, const int sizeY);
    virtual int Type(void) const;
    bool X_Size(const int X) const;
    int X_Size(void) const;
    bool Y_Size(const int Y) const;
    int Y_Size(void) const;
    color BackColor(void) const;
    bool BackColor(const color new_color) const;
    ENUM_BORDER_TYPE BorderType(void) const;
    bool BorderType(const ENUM_BORDER_TYPE flag) const;
    bool Angle(const double angle) const;
    double Angle(void) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChartObjectSubChart : public CChartObject {
public:
    CChartObjectSubChart(void);
    ~CChartObjectSubChart();
    bool Create(long chart_id, const string name, const int window, const int X, const int Y, const int sizeX, const int sizeY);
    virtual int Type(void) const;
    int X_Distance(void) const;
    bool X_Distance(const int X) const;
    int Y_Distance(void) const;
    bool Y_Distance(const int Y) const;
    ENUM_BASE_CORNER Corner(void) const;
    bool Corner(const ENUM_BASE_CORNER corner) const;
    int X_Size(void) const;
    bool X_Size(const int size) const;
    int Y_Size(void) const;
    bool Y_Size(const int size) const;
    string Symbol(void) const;
    bool Symbol(const string symbol) const;
    int Period(void) const;
    bool Period(const int period) const;
    int Scale(void) const;
    bool Scale(const int scale) const;
    bool DateScale(void) const;
    bool DateScale(const bool scale) const;
    bool PriceScale(void) const;
    bool PriceScale(const bool scale) const;
    datetime Time(const int point) const;
    bool Time(const int point, const datetime time) const;
    double Price(const int point) const;
    bool Price(const int point, const double price) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
};

class CChart : public CObject {
public:
    CChart(void);
    ~CChart();
    long ChartId(void) const;
    virtual int Type(void) const;
    ENUM_CHART_MODE Mode(void) const;
    bool Mode(const ENUM_CHART_MODE mode) const;
    bool Foreground(void) const;
    bool Foreground(const bool foreground) const;
    bool Shift(void) const;
    bool Shift(const bool shift) const;
    double ShiftSize(void) const;
    bool ShiftSize(double shift) const;
    bool AutoScroll(void) const;
    bool AutoScroll(const bool auto_scroll) const;
    int Scale(void) const;
    bool Scale(int scale) const;
    bool ScaleFix(void) const;
    bool ScaleFix(const bool scale_fix) const;
    bool ScaleFix_11(void) const;
    bool ScaleFix_11(const bool scale_fix_11) const;
    double FixedMax(void) const;
    bool FixedMax(const double fixed_max) const;
    double FixedMin(void) const;
    bool FixedMin(const double fixed_min) const;
    bool ScalePPB(void) const;
    bool ScalePPB(const bool scale_ppb) const;
    double PointsPerBar(void) const;
    bool PointsPerBar(const double points_per_bar) const;
    bool ShowOHLC(void) const;
    bool ShowOHLC(const bool show) const;
    bool ShowLineBid(void) const;
    bool ShowLineBid(const bool show) const;
    bool ShowLineAsk(void) const;
    bool ShowLineAsk(const bool show) const;
    bool ShowLastLine(void) const;
    bool ShowLastLine(const bool show) const;
    bool ShowPeriodSep(void) const;
    bool ShowPeriodSep(const bool show) const;
    bool ShowGrid(void) const;
    bool ShowGrid(const bool show) const;
    ENUM_CHART_VOLUME_MODE ShowVolumes(void) const;
    bool ShowVolumes(const ENUM_CHART_VOLUME_MODE show) const;
    bool ShowObjectDescr(void) const;
    bool ShowObjectDescr(const bool show) const;
    bool ShowDateScale(const bool show) const;
    bool ShowPriceScale(const bool show) const;
    color ColorBackground(void) const;
    bool ColorBackground(const color new_color) const;
    color ColorForeground(void) const;
    bool ColorForeground(const color new_color) const;
    color ColorGrid(void) const;
    bool ColorGrid(const color new_color) const;
    color ColorBarUp(void) const;
    bool ColorBarUp(const color new_color) const;
    color ColorBarDown(void) const;
    bool ColorBarDown(const color new_color) const;
    color ColorCandleBull(void) const;
    bool ColorCandleBull(const color new_color) const;
    color ColorCandleBear(void) const;
    bool ColorCandleBear(const color new_color) const;
    color ColorChartLine(void) const;
    bool ColorChartLine(const color new_color) const;
    color ColorVolumes(void) const;
    bool ColorVolumes(const color new_color) const;
    color ColorLineBid(void) const;
    bool ColorLineBid(const color new_color) const;
    color ColorLineAsk(void) const;
    bool ColorLineAsk(const color new_color) const;
    color ColorLineLast(void) const;
    bool ColorLineLast(const color new_color) const;
    color ColorStopLevels(void) const;
    bool ColorStopLevels(const color new_color) const;
    bool BringToTop(void) const;
    bool EventObjectCreate(const bool flag = true) const;
    bool EventObjectDelete(const bool flag = true) const;
    bool EventMouseMove(const bool flag = true) const;
    bool MouseScroll(const bool flag = true) const;
    int VisibleBars(void) const;
    int WindowsTotal(void) const;
    bool WindowIsVisible(const int num) const;
    int WindowHandle(void) const;
    int FirstVisibleBar(void) const;
    int WidthInBars(void) const;
    int WidthInPixels(void) const;
    int HeightInPixels(const int num) const;
    int SubwindowY(const int num) const;
    double PriceMin(const int num) const;
    double PriceMax(const int num) const;
    bool IsObject(void) const;
    void Attach(void);
    void Attach(const long chart);
    void FirstChart(void);
    void NextChart(void);
    long Open(const string symbol_name, const ENUM_TIMEFRAMES timeframe);
    void Detach(void);
    void Close(void);
    bool Navigate(const ENUM_CHART_POSITION position, const int shift = 0) const;
    string Symbol(void) const;
    ENUM_TIMEFRAMES Period(void) const;
    void Redraw(void) const;
    long GetInteger(const ENUM_CHART_PROPERTY_INTEGER prop_id, const int sub_window = 0) const;
    bool GetInteger(const ENUM_CHART_PROPERTY_INTEGER prop_id, const int sub_window, long & value) const;
    bool SetInteger(const ENUM_CHART_PROPERTY_INTEGER prop_id, const long value) const;
    double GetDouble(const ENUM_CHART_PROPERTY_DOUBLE prop_id, const int sub_window = 0) const;
    bool GetDouble(const ENUM_CHART_PROPERTY_DOUBLE prop_id, const int sub_window, double & value) const;
    bool SetDouble(const ENUM_CHART_PROPERTY_DOUBLE prop_id, const double value) const;
    string GetString(const ENUM_CHART_PROPERTY_STRING prop_id) const;
    bool GetString(const ENUM_CHART_PROPERTY_STRING prop_id, string & value) const;
    bool SetString(const ENUM_CHART_PROPERTY_STRING prop_id, const string value) const;
    bool SetSymbolPeriod(const string symbol, const ENUM_TIMEFRAMES period) const;
    bool ApplyTemplate(const string filename) const;
    bool ScreenShot(const string filename, const int width, const int height, const ENUM_ALIGN_MODE align_mode = ALIGN_RIGHT) const;
    int WindowOnDropped(void) const;
    double PriceOnDropped(void) const;
    datetime TimeOnDropped(void) const;
    int XOnDropped(void) const;
    int YOnDropped(void) const;
    bool IndicatorAdd(const int subwin, const int handle) const;
    bool IndicatorDelete(const int subwin, const string name) const;
    int IndicatorsTotal(const int subwin) const;
    string IndicatorName(const int subwin, const int index) const;
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
protected:
    long m_chart_id;
};

class CWnd : public CObject {
public:
    CWnd(void);
    ~CWnd();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual void Destroy(const int reason = 0);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    virtual bool OnMouseEvent(const int x, const int y, const int flags);
    string Name(void) const;
    int ControlsTotal(void) const;
    virtual CWnd* ControlFind(const long id);
    CRect Rect(void) const;
    int Left(void) const;
    virtual void Left(const int x);
    int Top(void) const;
    virtual void Top(const int y);
    int Right(void) const;
    virtual void Right(const int x);
    int Bottom(void) const;
    virtual void Bottom(const int y);
    int Width(void) const;
    virtual bool Width(const int w);
    int Height(void) const;
    virtual bool Height(const int h);
    CSize Size(void) const;
    virtual bool Size(const int w, const int h);
    virtual bool Size(const CSize & size);
    virtual bool Move(const int x, const int y);
    virtual bool Move(const CPoint & point);
    virtual bool Shift(const int dx, const int dy);
    bool Contains(const int x, const int y) const;
    bool Contains(CWnd * control) const;
    void Alignment(const int flags, const int left, const int top, const int right, const int bottom);
    virtual bool Align(const CRect & rect);
    virtual long Id(const long id);
    long Id(void) const;
    bool IsEnabled(void) const;
    virtual bool Enable(void);
    virtual bool Disable(void);
    bool IsVisible(void) const;
    virtual bool Visible(const bool flag);
    virtual bool Show(void);
    virtual bool Hide(void);
    bool IsActive(void) const;
    virtual bool Activate(void);
    virtual bool Deactivate(void);
    int StateFlags(void) const;
    void StateFlags(const int flags);
    void StateFlagsSet(const int flags);
    void StateFlagsReset(const int flags);
    int PropFlags(void) const;
    void PropFlags(const int flags);
    void PropFlagsSet(const int flags);
    void PropFlagsReset(const int flags);
    int MouseX(void) const;
    void MouseX(const int value);
    int MouseY(void) const;
    void MouseY(const int value);
    int MouseFlags(void) const;
    virtual void MouseFlags(const int value);
    bool MouseFocusKill(const long id = CONTROLS_INVALID_ID);
    bool BringToTop(void);
protected:
    long m_chart_id;
    int m_subwin;
    string m_name;
    CRect m_rect;
    long m_id;
    int m_state_flags;
    int m_prop_flags;
    int m_align_flags;
    int m_align_left;
    int m_align_top;
    int m_align_right;
    int m_align_bottom;
    int m_mouse_x;
    int m_mouse_y;
    int m_mouse_flags;
    uint m_last_click;
    virtual bool OnCreate(void);
    virtual bool OnDestroy(void);
    virtual bool OnMove(void);
    virtual bool OnResize(void);
    virtual bool OnEnable(void);
    virtual bool OnDisable(void);
    virtual bool OnShow(void);
    virtual bool OnHide(void);
    virtual bool OnActivate(void);
    virtual bool OnDeactivate(void);
    virtual bool OnClick(void);
    virtual bool OnDblClick(void);
    virtual bool OnChange(void);
    virtual bool OnMouseDown(void);
    virtual bool OnMouseUp(void);
    virtual bool OnDragStart(void);
    virtual bool OnDragProcess(const int x, const int y);
    virtual bool OnDragEnd(void);
    virtual bool DragObjectCreate(void);
    virtual bool DragObjectDestroy(void);
};

class CWndObj : public CWnd {
public:
    CWndObj(void);
    ~CWndObj();
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    string Text(void) const;
    bool Text(const string value);
    color Color(void) const;
    bool Color(const color value);
    color ColorBackground(void) const;
    bool ColorBackground(const color value);
    color ColorBorder(void) const;
    bool ColorBorder(const color value);
    string Font(void) const;
    bool Font(const string value);
    int FontSize(void) const;
    bool FontSize(const int value);
    long ZOrder(void) const;
    bool ZOrder(const long value);
protected:
    string m_text;
    color m_color;
    color m_color_background;
    color m_color_border;
    string m_font;
    int m_font_size;
    long m_zorder;
    virtual bool OnObjectCreate(void);
    virtual bool OnObjectChange(void);
    virtual bool OnObjectDelete(void);
    virtual bool OnObjectDrag(void);
    virtual bool OnSetText(void);
    virtual bool OnSetColor(void);
    virtual bool OnSetColorBackground(void);
    virtual bool OnSetColorBorder(void);
    virtual bool OnSetFont(void);
    virtual bool OnSetFontSize(void);
    virtual bool OnSetZOrder(void);
    virtual bool OnDestroy(void);
    virtual bool OnChange(void);
};

class CBmpButton : public CWndObj {
public:
    CBmpButton(void);
    ~CBmpButton();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    int Border(void) const;
    bool Border(const int value);
    bool BmpNames(const string off = "", const string on = "");
    string BmpOffName(void) const;
    bool BmpOffName(const string name);
    string BmpOnName(void) const;
    bool BmpOnName(const string name);
    string BmpPassiveName(void) const;
    bool BmpPassiveName(const string name);
    string BmpActiveName(void) const;
    bool BmpActiveName(const string name);
    bool Pressed(void) const;
    bool Pressed(const bool pressed);
    bool Locking(void) const;
    void Locking(const bool locking);
protected:
    virtual bool OnSetZOrder(void);
    virtual bool OnCreate(void);
    virtual bool OnShow(void);
    virtual bool OnHide(void);
    virtual bool OnMove(void);
    virtual bool OnChange(void);
    virtual bool OnActivate(void);
    virtual bool OnDeactivate(void);
    virtual bool OnMouseDown(void);
    virtual bool OnMouseUp(void);
};

class CButton : public CWndObj {
public:
    CButton(void);
    ~CButton();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    bool Pressed(void) const;
    bool Pressed(const bool pressed);
    bool Locking(void) const;
    void Locking(const bool flag);
protected:
    virtual bool OnSetText(void);
    virtual bool OnSetColor(void);
    virtual bool OnSetColorBackground(void);
    virtual bool OnSetColorBorder(void);
    virtual bool OnSetFont(void);
    virtual bool OnSetFontSize(void);
    virtual bool OnCreate(void);
    virtual bool OnShow(void);
    virtual bool OnHide(void);
    virtual bool OnMove(void);
    virtual bool OnResize(void);
    virtual bool OnMouseDown(void);
    virtual bool OnMouseUp(void);
};

class CWndContainer : public CWnd {
public:
    CWndContainer(void);
    ~CWndContainer();
    virtual void Destroy(const int reason = 0);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    virtual bool OnMouseEvent(const int x, const int y, const int flags);
    int ControlsTotal(void) const;
    virtual CWnd* ControlFind(const long id);
    virtual bool MouseFocusKill(const long id = -1);
    bool Add(CWnd * control);
    bool Add(CWnd & control);
    bool Delete(CWnd * control);
    bool Delete(CWnd & control);
    virtual bool Move(const int x, const int y);
    virtual bool Move(const CPoint & point);
    virtual bool Shift(const int dx, const int dy);
    virtual long Id(const long id);
    long Id(void) const;
    virtual bool Enable(void);
    virtual bool Disable(void);
    virtual bool Show(void);
    virtual bool Hide(void);
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
protected:
    virtual bool OnResize(void);
    virtual bool OnActivate(void);
    virtual bool OnDeactivate(void);
};

class CCheckBox : public CWndContainer {
public:
    CCheckBox(void);
    ~CCheckBox();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    string Text(void) const;
    bool Text(const string value);
    color Color(void) const;
    bool Color(const color value);
    bool Checked(void) const;
    bool Checked(const bool flag);
    int Value(void) const;
    void Value(const int value);
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
protected:
    virtual bool CreateButton(void);
    virtual bool CreateLabel(void);
    virtual bool OnClickButton(void);
    virtual bool OnClickLabel(void);
};

class CWndClient : public CWndContainer {
public:
    CWndClient(void);
    ~CWndClient();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    virtual bool ColorBackground(const color value);
    virtual bool ColorBorder(const color value);
    virtual bool BorderType(const ENUM_BORDER_TYPE flag);
    virtual bool VScrolled(void);
    virtual bool VScrolled(const bool flag);
    virtual bool HScrolled(void);
    virtual bool HScrolled(const bool flag);
    virtual long Id(const long id);
    virtual long Id(void) const;
    virtual bool Show(void);
protected:
    bool m_v_scrolled;
    bool m_h_scrolled;
    CPanel m_background;
    CScrollV m_scroll_v;
    CScrollH m_scroll_h;
    virtual bool CreateBack(void);
    virtual bool CreateScrollV(void);
    virtual bool CreateScrollH(void);
    virtual bool OnResize(void);
    virtual bool OnVScrollShow(void);
    virtual bool OnVScrollHide(void);
    virtual bool OnHScrollShow(void);
    virtual bool OnHScrollHide(void);
    virtual bool OnScrollLineDown(void);
    virtual bool OnScrollLineUp(void);
    virtual bool OnScrollLineLeft(void);
    virtual bool OnScrollLineRight(void);
    virtual bool Rebound(const CRect & rect);
};

class CCheckGroup : public CWndClient {
public:
    CCheckGroup(void);
    ~CCheckGroup();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual void Destroy(const int reason = 0);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    virtual bool AddItem(const string item, const long value = 0);
    long Value(void) const;
    bool Value(const long value);
    int Check(const int idx) const;
    bool Check(const int idx, const int value);
    virtual bool Show(void);
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
protected:
    bool CreateButton(int index);
    virtual bool OnVScrollShow(void);
    virtual bool OnVScrollHide(void);
    virtual bool OnScrollLineDown(void);
    virtual bool OnScrollLineUp(void);
    virtual bool OnChangeItem(const int row_index);
    bool Redraw(void);
    bool RowState(const int index, const bool select);
};

class CComboBox : public CWndContainer {
public:
    CComboBox(void);
    ~CComboBox();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    bool AddItem(const string item, const long value = 0);
    void ListViewItems(const int value);
    virtual bool ItemAdd(const string item, const long value = 0);
    virtual bool ItemInsert(const int index, const string item, const long value = 0);
    virtual bool ItemUpdate(const int index, const string item, const long value = 0);
    virtual bool ItemDelete(const int index);
    virtual bool ItemsClear(void);
    string Select(void);
    bool Select(const int index);
    bool SelectByText(const string text);
    bool SelectByValue(const long value);
    long Value(void);
    virtual bool Show(void);
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
protected:
    virtual bool CreateEdit(void);
    virtual bool CreateButton(void);
    virtual bool CreateList(void);
    virtual bool OnClickEdit(void);
    virtual bool OnClickButton(void);
    virtual bool OnChangeList(void);
    bool ListShow(void);
    bool ListHide(void);
    void CheckListHide(const int id, int x, int y);
};

class CDateDropList : public CWndContainer {
public:
    CDateDropList(void);
    ~CDateDropList();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    datetime Value(void);
    void Value(datetime value);
    void Value(MqlDateTime& value);
    virtual bool Show(void);
protected:
    virtual bool OnClick(void);
    virtual bool CreateButtons(void);
    virtual bool CreateList(void);
    void DrawCanvas(void);
    void DrawClickRect(const int idx, int x, int y, string text, const uint clr, uint alignment = 0);
    virtual bool OnClickDec(void);
    virtual bool OnClickInc(void);
    virtual bool OnClickList(void);
};

class CDatePicker : public CWndContainer {
public:
    CDatePicker(void);
    ~CDatePicker();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    datetime Value(void) const;
    void Value(datetime value);
    virtual bool Show(void);
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
protected:
    virtual bool CreateEdit(void);
    virtual bool CreateButton(void);
    virtual bool CreateList(void);
    virtual bool OnClickEdit(void);
    virtual bool OnClickButton(void);
    virtual bool OnChangeList(void);
    bool ListShow(void);
    bool ListHide(void);
    void CheckListHide(const int id, int x, int y);
};

class CDialog : public CWndContainer {
public:
    CDialog(void);
    ~CDialog();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    string Caption(void) const;
    bool Caption(const string text);
    bool Add(CWnd * control);
    bool Add(CWnd & control);
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
protected:
    bool m_panel_flag;
    bool m_minimized;
    CRect m_min_rect;
    CRect m_norm_rect;
    virtual bool CreateWhiteBorder(void);
    virtual bool CreateBackground(void);
    virtual bool CreateCaption(void);
    virtual bool CreateButtonClose(void);
    virtual bool CreateClientArea(void);
    virtual void OnClickCaption(void);
    virtual void OnClickButtonClose(void);
    void CaptionAlignment(const int flags, const int left, const int top, const int right, const int bottom);
    bool ClientAreaVisible(const bool visible);
    int ClientAreaLeft(void) const;
    int ClientAreaTop(void) const;
    int ClientAreaRight(void) const;
    int ClientAreaBottom(void) const;
    int ClientAreaWidth(void) const;
    int ClientAreaHeight(void) const;
    virtual bool OnDialogDragStart(void);
    virtual bool OnDialogDragProcess(void);
    virtual bool OnDialogDragEnd(void);
};

class CAppDialog : public CDialog {
public:
    CAppDialog(void);
    ~CAppDialog();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual void Destroy(const int reason = REASON_PROGRAM);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    bool Run(void);
    void ChartEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    void Minimized(const bool flag);
    void IniFileSave(void);
    void IniFileLoad(void);
    virtual string IniFileName(void) const;
    virtual string IniFileExt(void) const;
    virtual bool Load(const int file_handle);
    virtual bool Save(const int file_handle);
protected:
    CChart m_chart;
    virtual bool CreateButtonMinMax(void);
    virtual void OnClickButtonClose(void);
    virtual void OnClickButtonMinMax(void);
    virtual void OnAnotherApplicationClose(const long & lparam, const double & dparam, const string & sparam);
    virtual bool Rebound(const CRect & rect);
    virtual void Minimize(void);
    virtual void Maximize(void);
    string CreateInstanceId(void);
    string ProgramName(void) const;
    void SubwinOff(void);
};

class CEdit : public CWndObj {
public:
    CEdit(void);
    ~CEdit();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    bool ReadOnly(void) const;
    bool ReadOnly(const bool flag);
    ENUM_ALIGN_MODE TextAlign(void) const;
    bool TextAlign(const ENUM_ALIGN_MODE align);
    string Text(void) const;
    bool Text(const string value);
protected:
    virtual bool OnObjectEndEdit(void);
    virtual bool OnSetText(void);
    virtual bool OnSetColor(void);
    virtual bool OnSetColorBackground(void);
    virtual bool OnSetColorBorder(void);
    virtual bool OnSetFont(void);
    virtual bool OnSetFontSize(void);
    virtual bool OnSetZOrder(void);
    virtual bool OnCreate(void);
    virtual bool OnShow(void);
    virtual bool OnHide(void);
    virtual bool OnMove(void);
    virtual bool OnResize(void);
    virtual bool OnChange(void);
    virtual bool OnClick(void);
};

class CLabel : public CWndObj {
public:
    CLabel(void);
    ~CLabel();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
protected:
    virtual bool OnSetText(void);
    virtual bool OnSetColor(void);
    virtual bool OnSetFont(void);
    virtual bool OnSetFontSize(void);
    virtual bool OnCreate(void);
    virtual bool OnShow(void);
    virtual bool OnHide(void);
    virtual bool OnMove(void);
};

class CListView : public CWndClient {
public:
    CListView(void);
    ~CListView();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual void Destroy(const int reason = 0);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    bool TotalView(const int value);
    virtual bool AddItem(const string item, const long value = 0);
    virtual bool ItemAdd(const string item, const long value = 0);
    virtual bool ItemInsert(const int index, const string item, const long value = 0);
    virtual bool ItemUpdate(const int index, const string item, const long value = 0);
    virtual bool ItemDelete(const int index);
    virtual bool ItemsClear(void);
    int Current(void);
    string Select(void);
    bool Select(const int index);
    bool SelectByText(const string text);
    bool SelectByValue(const long value);
    long Value(void);
    virtual bool Show(void);
protected:
    bool CreateRow(const int index);
    virtual bool OnResize(void);
    virtual bool OnVScrollShow(void);
    virtual bool OnVScrollHide(void);
    virtual bool OnScrollLineDown(void);
    virtual bool OnScrollLineUp(void);
    virtual bool OnItemClick(const int index);
    bool Redraw(void);
    bool RowState(const int index, const bool select);
    bool CheckView(void);
};

class CPanel : public CWndObj {
public:
    CPanel(void);
    ~CPanel();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    ENUM_BORDER_TYPE BorderType(void) const;
    bool BorderType(const ENUM_BORDER_TYPE type);
protected:
    virtual bool OnSetText(void);
    virtual bool OnSetColorBackground(void);
    virtual bool OnSetColorBorder(void);
    virtual bool OnCreate(void);
    virtual bool OnShow(void);
    virtual bool OnHide(void);
    virtual bool OnMove(void);
    virtual bool OnResize(void);
    virtual bool OnChange(void);
};

class CPicture : public CWndObj {
public:
    CPicture(void);
    ~CPicture();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    int Border(void) const;
    bool Border(const int value);
    string BmpName(void) const;
    bool BmpName(const string name);
protected:
    virtual bool OnCreate(void);
    virtual bool OnShow(void);
    virtual bool OnHide(void);
    virtual bool OnMove(void);
    virtual bool OnChange(void);
};

class CRadioButton : public CWndContainer {
public:
    CRadioButton(void);
    ~CRadioButton();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    string Text(void) const;
    bool Text(const string value);
    color Color(void) const;
    bool Color(const color value);
    bool State(void) const;
    bool State(const bool flag);
protected:
    virtual bool CreateButton(void);
    virtual bool CreateLabel(void);
    virtual bool OnClickButton(void);
    virtual bool OnClickLabel(void);
};

class CRadioGroup : public CWndClient {
public:
    CRadioGroup(void);
    ~CRadioGroup();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual void Destroy(const int reason = 0);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    virtual bool AddItem(const string item, const long value = 0);
    long Value(void) const;
    bool Value(const long value);
    bool ValueCheck(long value) const;
    virtual bool Show(void);
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
protected:
    bool CreateButton(const int index);
    virtual bool OnVScrollShow(void);
    virtual bool OnVScrollHide(void);
    virtual bool OnScrollLineDown(void);
    virtual bool OnScrollLineUp(void);
    virtual bool OnChangeItem(const int row_index);
    bool Redraw(void);
    bool RowState(const int index, const bool select);
    void Select(const int index);
};

struct CPoint {
public:
    int x;
    int y;
};

struct CSize {
public:
    int cx;
    int cy;
};

struct CRect {
public:
    int left;
    int top;
    int right;
    int bottom;
    CPoint LeftTop(void) const;
    void LeftTop(const int x, const int y);
    void LeftTop(const CPoint& point);
    CPoint RightBottom(void) const;
    void RightBottom(const int x, const int y);
    void RightBottom(const CPoint& point);
    CPoint CenterPoint(void) const;
    int Width(void) const;
    void Width(const int w);
    int Height(void) const;
    void Height(const int h);
    CSize Size(void) const;
    void Size(const int cx, const int cy);
    void Size(const CSize& size);
    void SetBound(const int l, const int t, const int r, const int b);
    void SetBound(const CRect& rect);
    void SetBound(const CPoint& point, const CSize& size);
    void SetBound(const CPoint& left_top, const CPoint& right_bottom);
    void Move(const int x, const int y);
    void Move(const CPoint& point);
    void Shift(const int dx, const int dy);
    void Shift(const CPoint& point);
    void Shift(const CSize& size);
    bool Contains(const int x, const int y) const;
    bool Contains(const CPoint& point) const;
    void Normalize(void);
};

class CScroll : public CWndContainer {
public:
    CScroll(void);
    ~CScroll();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    int MinPos(void) const;
    void MinPos(const int value);
    int MaxPos(void) const;
    void MaxPos(const int value);
    int CurrPos(void) const;
    bool CurrPos(int value);
protected:
    CPanel m_back;
    CBmpButton m_inc;
    CBmpButton m_dec;
    CBmpButton m_thumb;
    int m_min_pos;
    int m_max_pos;
    int m_curr_pos;
    virtual bool CreateBack(void);
    virtual bool CreateInc(void);
    virtual bool CreateDec(void);
    virtual bool CreateThumb(void);
    virtual bool OnClickInc(void);
    virtual bool OnClickDec(void);
    virtual bool OnShow(void);
    virtual bool OnHide(void);
    virtual bool OnChangePos(void);
    virtual bool OnThumbDragStart(void);
    virtual bool OnThumbDragProcess(void);
    virtual bool OnThumbDragEnd(void);
    virtual int CalcPos(const int coord);
};

class CScrollV : public CScroll {
public:
    CScrollV(void);
    ~CScrollV();
protected:
    virtual bool CreateInc(void);
    virtual bool CreateDec(void);
    virtual bool CreateThumb(void);
    virtual bool OnResize(void);
    virtual bool OnChangePos(void);
    virtual bool OnThumbDragStart(void);
    virtual bool OnThumbDragProcess(void);
    virtual bool OnThumbDragEnd(void);
    virtual int CalcPos(const int coord);
};

class CScrollH : public CScroll {
public:
    CScrollH(void);
    ~CScrollH();
protected:
    virtual bool CreateInc(void);
    virtual bool CreateDec(void);
    virtual bool CreateThumb(void);
    virtual bool OnResize(void);
    virtual bool OnChangePos(void);
    virtual bool OnThumbDragStart(void);
    virtual bool OnThumbDragProcess(void);
    virtual bool OnThumbDragEnd(void);
    virtual int CalcPos(const int coord);
};

class CSpinEdit : public CWndContainer {
public:
    CSpinEdit(void);
    ~CSpinEdit();
    virtual bool Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
    virtual bool OnEvent(const int id, const long & lparam, const double & dparam, const string & sparam);
    int MinValue(void) const;
    void MinValue(const int value);
    int MaxValue(void) const;
    void MaxValue(const int value);
    int Value(void) const;
    bool Value(int value);
    virtual bool Save(const int file_handle);
    virtual bool Load(const int file_handle);
protected:
    virtual bool CreateEdit(void);
    virtual bool CreateInc(void);
    virtual bool CreateDec(void);
    virtual bool OnClickInc(void);
    virtual bool OnClickDec(void);
    virtual bool OnChangeValue(void);
};

class CDragWnd : public CWnd {
public:
    CDragWnd(void);
    ~CDragWnd();
    void Limits(const int l, const int t, const int r, const int b);
protected:
    int m_limit_left;
    int m_limit_top;
    int m_limit_right;
    int m_limit_bottom;
    virtual bool OnDragProcess(const int x, const int y);
};

class CExpertBase : public CObject {
public:
    CExpertBase(void);
    ~CExpertBase();
    ENUM_INIT_PHASE InitPhase(void) const;
    void TrendType(ENUM_TYPE_TREND value);
    int UsedSeries(void) const;
    void EveryTick(bool value);
    double Open(int ind) const;
    double High(int ind) const;
    double Low(int ind) const;
    double Close(int ind) const;
    int Spread(int ind) const;
    datetime Time(int ind) const;
    long TickVolume(int ind) const;
    long RealVolume(int ind) const;
    virtual bool Init(CSymbolInfo * symbol, ENUM_TIMEFRAMES period, double point);
    bool Symbol(string name);
    bool Period(ENUM_TIMEFRAMES value);
    void Magic(ulong value);
    void SetMarginMode(void);
    virtual bool ValidationSettings();
    virtual bool SetPriceSeries(CiOpen * open, CiHigh * high, CiLow * low, CiClose * close);
    virtual bool SetOtherSeries(CiSpread * spread, CiTime * time, CiTickVolume * tick_volume, CiRealVolume * real_volume);
    virtual bool InitIndicators(CIndicators * indicators = NULL);
protected:
    ulong m_magic;
    ENUM_INIT_PHASE m_init_phase;
    bool m_other_symbol;
    bool m_other_period;
    ENUM_TIMEFRAMES m_period;
    double m_adjusted_point;
    CAccountInfo m_account;
    ENUM_ACCOUNT_MARGIN_MODE m_margin_mode;
    ENUM_TYPE_TREND m_trend_type;
    bool m_every_tick;
    int m_used_series;
    bool InitOpen(CIndicators * indicators);
    bool InitHigh(CIndicators * indicators);
    bool InitLow(CIndicators * indicators);
    bool InitClose(CIndicators * indicators);
    bool InitSpread(CIndicators * indicators);
    bool InitTime(CIndicators * indicators);
    bool InitTickVolume(CIndicators * indicators);
    bool InitRealVolume(CIndicators * indicators);
    virtual double PriceLevelUnit(void);
    virtual int StartIndex(void);
    virtual bool CompareMagic(ulong magic);
    bool IsHedging(void) const;
};

class CExpertMoney : public CExpertBase {
public:
    CExpertMoney(void);
    ~CExpertMoney();
    void Percent(double percent);
    virtual bool ValidationSettings();
    virtual double CheckOpenLong(double price, double sl);
    virtual double CheckOpenShort(double price, double sl);
    virtual double CheckReverse(CPositionInfo * position, double sl);
    virtual double CheckClose(CPositionInfo * position);
protected:
    double m_percent;
};

class CExpertSignal : public CExpertBase {
public:
    CExpertSignal(void);
    ~CExpertSignal();
    void BasePrice(double value);
    int UsedSeries(void);
    void Weight(double value);
    void PatternsUsage(int value);
    void General(int value);
    void Ignore(long value);
    void Invert(long value);
    void ThresholdOpen(int value);
    void ThresholdClose(int value);
    void PriceLevel(double value);
    void StopLevel(double value);
    void TakeLevel(double value);
    void Expiration(int value);
    void Magic(ulong value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual bool AddFilter(CExpertSignal * filter);
    virtual bool CheckOpenLong(double & price, double & sl, double & tp, datetime & expiration);
    virtual bool CheckOpenShort(double & price, double & sl, double & tp, datetime & expiration);
    virtual bool OpenLongParams(double & price, double & sl, double & tp, datetime & expiration);
    virtual bool OpenShortParams(double & price, double & sl, double & tp, datetime & expiration);
    virtual bool CheckCloseLong(double & price);
    virtual bool CheckCloseShort(double & price);
    virtual bool CloseLongParams(double & price);
    virtual bool CloseShortParams(double & price);
    virtual bool CheckReverseLong(double & price, double & sl, double & tp, datetime & expiration);
    virtual bool CheckReverseShort(double & price, double & sl, double & tp, datetime & expiration);
    virtual bool CheckTrailingOrderLong(COrderInfo * order, double & price);
    virtual bool CheckTrailingOrderShort(COrderInfo * order, double & price);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
    virtual double Direction(void);
    void SetDirection(void);
protected:
    double m_base_price;
    CArrayObj m_filters;
    double m_weight;
    int m_patterns_usage;
    int m_general;
    long m_ignore;
    long m_invert;
    int m_threshold_open;
    int m_threshold_close;
    double m_price_level;
    double m_stop_level;
    double m_take_level;
    int m_expiration;
    double m_direction;
};

class CTrade : public CObject {
public:
    CTrade(void);
    ~CTrade();
    void LogLevel(const ENUM_LOG_LEVELS log_level);
    void Request(MqlTradeRequest & request) const;
    ENUM_TRADE_REQUEST_ACTIONS RequestAction(void) const;
    string RequestActionDescription(void) const;
    ulong RequestMagic(void) const;
    ulong RequestOrder(void) const;
    ulong RequestPosition(void) const;
    ulong RequestPositionBy(void) const;
    string RequestSymbol(void) const;
    double RequestVolume(void) const;
    double RequestPrice(void) const;
    double RequestStopLimit(void) const;
    double RequestSL(void) const;
    double RequestTP(void) const;
    ulong RequestDeviation(void) const;
    ENUM_ORDER_TYPE RequestType(void) const;
    string RequestTypeDescription(void) const;
    ENUM_ORDER_TYPE_FILLING RequestTypeFilling(void) const;
    string RequestTypeFillingDescription(void) const;
    ENUM_ORDER_TYPE_TIME RequestTypeTime(void) const;
    string RequestTypeTimeDescription(void) const;
    datetime RequestExpiration(void) const;
    string RequestComment(void) const;
    void Result(MqlTradeResult & result) const;
    uint ResultRetcode(void) const;
    string ResultRetcodeDescription(void) const;
    int ResultRetcodeExternal(void) const;
    ulong ResultDeal(void) const;
    ulong ResultOrder(void) const;
    double ResultVolume(void) const;
    double ResultPrice(void) const;
    double ResultBid(void) const;
    double ResultAsk(void) const;
    string ResultComment(void) const;
    void CheckResult(MqlTradeCheckResult & check_result) const;
    uint CheckResultRetcode(void) const;
    string CheckResultRetcodeDescription(void) const;
    double CheckResultBalance(void) const;
    double CheckResultEquity(void) const;
    double CheckResultProfit(void) const;
    double CheckResultMargin(void) const;
    double CheckResultMarginFree(void) const;
    double CheckResultMarginLevel(void) const;
    string CheckResultComment(void) const;
    void SetAsyncMode(const bool mode);
    void SetExpertMagicNumber(const ulong magic);
    void SetDeviationInPoints(const ulong deviation);
    void SetTypeFilling(const ENUM_ORDER_TYPE_FILLING filling);
    bool SetTypeFillingBySymbol(const string symbol);
    void SetMarginMode(void);
    bool PositionOpen(const string symbol, const ENUM_ORDER_TYPE order_type, const double volume, const double price, const double sl, const double tp, const string comment = "");
    bool PositionModify(const string symbol, const double sl, const double tp);
    bool PositionModify(const ulong ticket, const double sl, const double tp);
    bool PositionClose(const string symbol, const ulong deviation = ULONG_MAX);
    bool PositionClose(const ulong ticket, const ulong deviation = ULONG_MAX);
    bool PositionCloseBy(const ulong ticket, const ulong ticket_by);
    bool PositionClosePartial(const string symbol, const double volume, const ulong deviation = ULONG_MAX);
    bool PositionClosePartial(const ulong ticket, const double volume, const ulong deviation = ULONG_MAX);
    bool OrderOpen(const string symbol, const ENUM_ORDER_TYPE order_type, const double volume, const double limit_price, const double price, const double sl, const double tp, ENUM_ORDER_TYPE_TIME type_time = ORDER_TIME_GTC, const datetime expiration = 0, const string comment = "");
    bool OrderModify(const ulong ticket, const double price, const double sl, const double tp, const ENUM_ORDER_TYPE_TIME type_time, const datetime expiration, const double stoplimit = 0.0);
    bool OrderDelete(const ulong ticket);
    bool Buy(const double volume, const string symbol = NULL, double price = 0.0, const double sl = 0.0, const double tp = 0.0, const string comment = "");
    bool Sell(const double volume, const string symbol = NULL, double price = 0.0, const double sl = 0.0, const double tp = 0.0, const string comment = "");
    bool BuyLimit(const double volume, const double price, const string symbol = NULL, const double sl = 0.0, const double tp = 0.0, const ENUM_ORDER_TYPE_TIME type_time = ORDER_TIME_GTC, const datetime expiration = 0, const string comment = "");
    bool BuyStop(const double volume, const double price, const string symbol = NULL, const double sl = 0.0, const double tp = 0.0, const ENUM_ORDER_TYPE_TIME type_time = ORDER_TIME_GTC, const datetime expiration = 0, const string comment = "");
    bool SellLimit(const double volume, const double price, const string symbol = NULL, const double sl = 0.0, const double tp = 0.0, const ENUM_ORDER_TYPE_TIME type_time = ORDER_TIME_GTC, const datetime expiration = 0, const string comment = "");
    bool SellStop(const double volume, const double price, const string symbol = NULL, const double sl = 0.0, const double tp = 0.0, const ENUM_ORDER_TYPE_TIME type_time = ORDER_TIME_GTC, const datetime expiration = 0, const string comment = "");
    virtual double CheckVolume(const string symbol, double volume, double price, ENUM_ORDER_TYPE order_type);
    virtual bool OrderCheck(const MqlTradeRequest & request, MqlTradeCheckResult & check_result);
    virtual bool OrderSend(const MqlTradeRequest & request, MqlTradeResult & result);
    void PrintRequest(void) const;
    void PrintResult(void) const;
    string FormatPositionType(string & str, const uint type) const;
    string FormatOrderType(string & str, const uint type) const;
    string FormatOrderStatus(string & str, const uint status) const;
    string FormatOrderTypeFilling(string & str, const uint type) const;
    string FormatOrderTypeTime(string & str, const uint type) const;
    string FormatOrderPrice(string & str, const double price_order, const double price_trigger, const uint digits) const;
    string FormatRequest(string & str, const MqlTradeRequest & request) const;
    string FormatRequestResult(string & str, const MqlTradeRequest & request, const MqlTradeResult & result) const;
protected:
    MqlTradeRequest m_request;
    MqlTradeResult m_result;
    MqlTradeCheckResult m_check_result;
    bool m_async_mode;
    ulong m_magic;
    ulong m_deviation;
    ENUM_ORDER_TYPE_FILLING m_type_filling;
    ENUM_ACCOUNT_MARGIN_MODE m_margin_mode;
    ENUM_LOG_LEVELS m_log_level;
    bool FillingCheck(const string symbol);
    bool ExpirationCheck(const string symbol);
    bool OrderTypeCheck(const string symbol);
    void ClearStructures(void);
    bool IsStopped(const string function);
    bool IsHedging(void) const;
    bool SelectPosition(const string symbol);
};

class CExpertTrade : public CTrade {
public:
    CExpertTrade(void);
    ~CExpertTrade();
    bool SetSymbol(CSymbolInfo * symbol);
    bool SetOrderTypeTime(ENUM_ORDER_TYPE_TIME order_type_time);
    bool SetOrderExpiration(datetime order_expiration);
    bool Buy(double volume, double price, double sl, double tp, const string comment = "");
    bool Sell(double volume, double price, double sl, double tp, const string comment = "");
protected:
    ENUM_ORDER_TYPE_TIME m_order_type_time;
    datetime m_order_expiration;
    CAccountInfo m_account;
};

class CExpertTrailing : public CExpertBase {
public:
    CExpertTrailing(void);
    ~CExpertTrailing();
    virtual bool CheckTrailingStopLong(CPositionInfo * position, double & sl, double & tp);
    virtual bool CheckTrailingStopShort(CPositionInfo * position, double & sl, double & tp);
};

class CMoneyFixedLot : public CExpertMoney {
public:
    CMoneyFixedLot(void);
    ~CMoneyFixedLot();
    void Lots(double lots);
    virtual bool ValidationSettings(void);
    virtual double CheckOpenLong(double price, double sl);
    virtual double CheckOpenShort(double price, double sl);
protected:
    double m_lots;
};

class CMoneyFixedMargin : public CExpertMoney {
public:
    CMoneyFixedMargin(void);
    ~CMoneyFixedMargin();
    virtual double CheckOpenLong(double price, double sl);
    virtual double CheckOpenShort(double price, double sl);
};

class CMoneyFixedRisk : public CExpertMoney {
public:
    CMoneyFixedRisk(void);
    ~CMoneyFixedRisk();
    virtual double CheckOpenLong(double price, double sl);
    virtual double CheckOpenShort(double price, double sl);
    virtual double CheckClose(CPositionInfo * position);
};

class CMoneyNone : public CExpertMoney {
public:
    CMoneyNone(void);
    ~CMoneyNone();
    virtual bool ValidationSettings(void);
    virtual double CheckOpenLong(double price, double sl);
    virtual double CheckOpenShort(double price, double sl);
};

class CMoneySizeOptimized : public CExpertMoney {
public:
    CMoneySizeOptimized(void);
    ~CMoneySizeOptimized();
    void DecreaseFactor(double decrease_factor);
    virtual bool ValidationSettings(void);
    virtual double CheckOpenLong(double price, double sl);
    virtual double CheckOpenShort(double price, double sl);
protected:
    double m_decrease_factor;
    double Optimize(double lots);
};

class CSignalAC : public CExpertSignal {
public:
    CSignalAC(void);
    ~CSignalAC();
    void Pattern_0(int value);
    void Pattern_1(int value);
    void Pattern_2(int value);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiAC m_ac;
    int m_pattern_0;
    int m_pattern_1;
    int m_pattern_2;
    bool InitAC(CIndicators * indicators);
    double AC(int ind);
    double DiffAC(int ind);
};

class CSignalAMA : public CExpertSignal {
public:
    CSignalAMA(void);
    ~CSignalAMA();
    void PeriodMA(int value);
    void PeriodFast(int value);
    void PeriodSlow(int value);
    void Shift(int value);
    void Applied(ENUM_APPLIED_PRICE value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    void Pattern_2(int value);
    void Pattern_3(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiAMA m_ma;
    int m_ma_period;
    int m_period_fast;
    int m_period_slow;
    int m_ma_shift;
    ENUM_APPLIED_PRICE m_ma_applied;
    int m_pattern_0;
    int m_pattern_1;
    int m_pattern_2;
    int m_pattern_3;
    bool InitMA(CIndicators * indicators);
    double MA(int ind);
    double DiffMA(int ind);
    double DiffOpenMA(int ind);
    double DiffHighMA(int ind);
    double DiffLowMA(int ind);
    double DiffCloseMA(int ind);
};

class CSignalAO : public CExpertSignal {
public:
    CSignalAO(void);
    ~CSignalAO();
    void Pattern_0(int value);
    void Pattern_1(int value);
    void Pattern_2(int value);
    void Pattern_3(int value);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiAO m_ao;
    int m_pattern_0;
    int m_pattern_1;
    int m_pattern_2;
    int m_pattern_3;
    double m_extr_osc;
    double m_extr_pr;
    int m_extr_pos;
    uint m_extr_map;
    bool InitAO(CIndicators * indicators);
    double AO(int ind);
    double DiffAO(int ind);
    int StateAO(int ind);
    bool ExtStateAO(int ind);
};

class CSignalBearsPower : public CExpertSignal {
public:
    CSignalBearsPower(void);
    ~CSignalBearsPower();
    void PeriodBears(int value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
protected:
    CiBearsPower m_bears;
    int m_period_bears;
    int m_pattern_0;
    int m_pattern_1;
    double m_extr_osc;
    double m_extr_pr;
    int m_extr_pos;
    uint m_extr_map;
    bool InitBears(CIndicators * indicators);
    double Bears(int ind);
    double DiffBears(int ind);
    int StateBears(int ind);
    bool ExtStateBears(int ind);
};

class CSignalBullsPower : public CExpertSignal {
public:
    CSignalBullsPower(void);
    ~CSignalBullsPower();
    void PeriodBulls(int value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int ShortCondition(void);
protected:
    CiBullsPower m_bulls;
    int m_period_bulls;
    int m_pattern_0;
    int m_pattern_1;
    double m_extr_osc;
    double m_extr_pr;
    int m_extr_pos;
    uint m_extr_map;
    bool InitBears(CIndicators * indicators);
    double Bulls(int ind);
    double DiffBulls(int ind);
    int StateBulls(int ind);
    bool ExtStateBulls(int ind);
};

class CSignalCCI : public CExpertSignal {
public:
    CSignalCCI(void);
    ~CSignalCCI();
    void PeriodCCI(int value);
    void Applied(ENUM_APPLIED_PRICE value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    void Pattern_2(int value);
    void Pattern_3(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiCCI m_cci;
    int m_periodCCI;
    ENUM_APPLIED_PRICE m_applied;
    int m_pattern_0;
    int m_pattern_1;
    int m_pattern_2;
    int m_pattern_3;
    double m_extr_osc;
    double m_extr_pr;
    int m_extr_pos;
    uint m_extr_map;
    bool InitStoch(CIndicators * indicators);
    double CCI(int ind);
    double Diff(int ind);
    int State(int ind);
    bool ExtState(int ind);
    bool CompareMaps(int map, int count, bool minimax = false, int start = 0);
};

class CSignalDEMA : public CExpertSignal {
public:
    CSignalDEMA(void);
    ~CSignalDEMA();
    void PeriodMA(int value);
    void Shift(int value);
    void Applied(ENUM_APPLIED_PRICE value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    void Pattern_2(int value);
    void Pattern_3(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiDEMA m_ma;
    int m_ma_period;
    int m_ma_shift;
    ENUM_APPLIED_PRICE m_ma_applied;
    int m_pattern_0;
    int m_pattern_1;
    int m_pattern_2;
    int m_pattern_3;
    bool InitMA(CIndicators * indicators);
    double MA(int ind);
    double DiffMA(int ind);
    double DiffOpenMA(int ind);
    double DiffHighMA(int ind);
    double DiffLowMA(int ind);
    double DiffCloseMA(int ind);
};

class CSignalDeM : public CExpertSignal {
public:
    CSignalDeM(void);
    ~CSignalDeM();
    void PeriodDeM(int value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    void Pattern_2(int value);
    void Pattern_3(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiDeMarker m_dem;
    int m_periodDeM;
    int m_pattern_0;
    int m_pattern_1;
    int m_pattern_2;
    int m_pattern_3;
    double m_extr_osc;
    double m_extr_pr;
    int m_extr_pos;
    uint m_extr_map;
    bool InitStoch(CIndicators * indicators);
    double DeM(int ind);
    double DiffDeM(int ind);
    int StateDeM(int ind);
    bool ExtStateDeM(int ind);
    bool CompareMaps(int map, int count, bool minimax = false, int start = 0);
};

class CSignalEnvelopes : public CExpertSignal {
public:
    CSignalEnvelopes(void);
    ~CSignalEnvelopes();
    void PeriodMA(int value);
    void Shift(int value);
    void Method(ENUM_MA_METHOD value);
    void Applied(ENUM_APPLIED_PRICE value);
    void Deviation(double value);
    void LimitIn(double value);
    void LimitOut(double value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiEnvelopes m_env;
    int m_ma_period;
    int m_ma_shift;
    ENUM_MA_METHOD m_ma_method;
    ENUM_APPLIED_PRICE m_ma_applied;
    double m_deviation;
    double m_limit_in;
    double m_limit_out;
    int m_pattern_0;
    int m_pattern_1;
    bool InitMA(CIndicators * indicators);
    double Upper(int ind);
    double Lower(int ind);
};

class CSignalFrAMA : public CExpertSignal {
public:
    CSignalFrAMA(void);
    ~CSignalFrAMA();
    void PeriodMA(int value);
    void Shift(int value);
    void Applied(ENUM_APPLIED_PRICE value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    void Pattern_2(int value);
    void Pattern_3(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiFrAMA m_ma;
    int m_ma_period;
    int m_ma_shift;
    ENUM_APPLIED_PRICE m_ma_applied;
    int m_pattern_0;
    int m_pattern_1;
    int m_pattern_2;
    int m_pattern_3;
    bool InitMA(CIndicators * indicators);
    double MA(int ind);
    double DiffMA(int ind);
    double DiffOpenMA(int ind);
    double DiffHighMA(int ind);
    double DiffLowMA(int ind);
    double DiffCloseMA(int ind);
};

class CSignalITF : public CExpertSignal {
public:
    CSignalITF(void);
    ~CSignalITF();
    void GoodMinuteOfHour(int value);
    void BadMinutesOfHour(long value);
    void GoodHourOfDay(int value);
    void BadHoursOfDay(int value);
    void GoodDayOfWeek(int value);
    void BadDaysOfWeek(int value);
    virtual double Direction(void);
protected:
    int m_good_minute_of_hour;
    long m_bad_minutes_of_hour;
    int m_good_hour_of_day;
    int m_bad_hours_of_day;
    int m_good_day_of_week;
    int m_bad_days_of_week;
};

class CSignalMA : public CExpertSignal {
public:
    CSignalMA(void);
    ~CSignalMA();
    void PeriodMA(int value);
    void Shift(int value);
    void Method(ENUM_MA_METHOD value);
    void Applied(ENUM_APPLIED_PRICE value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    void Pattern_2(int value);
    void Pattern_3(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiMA m_ma;
    int m_ma_period;
    int m_ma_shift;
    ENUM_MA_METHOD m_ma_method;
    ENUM_APPLIED_PRICE m_ma_applied;
    int m_pattern_0;
    int m_pattern_1;
    int m_pattern_2;
    int m_pattern_3;
    bool InitMA(CIndicators * indicators);
    double MA(int ind);
    double DiffMA(int ind);
    double DiffOpenMA(int ind);
    double DiffHighMA(int ind);
    double DiffLowMA(int ind);
    double DiffCloseMA(int ind);
};

class CSignalMACD : public CExpertSignal {
public:
    CSignalMACD(void);
    ~CSignalMACD();
    void PeriodFast(int value);
    void PeriodSlow(int value);
    void PeriodSignal(int value);
    void Applied(ENUM_APPLIED_PRICE value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    void Pattern_2(int value);
    void Pattern_3(int value);
    void Pattern_4(int value);
    void Pattern_5(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiMACD m_MACD;
    int m_period_fast;
    int m_period_slow;
    int m_period_signal;
    ENUM_APPLIED_PRICE m_applied;
    int m_pattern_0;
    int m_pattern_1;
    int m_pattern_2;
    int m_pattern_3;
    int m_pattern_4;
    int m_pattern_5;
    double m_extr_osc;
    double m_extr_pr;
    int m_extr_pos;
    uint m_extr_map;
    bool InitMACD(CIndicators * indicators);
    double Main(int ind);
    double Signal(int ind);
    double DiffMain(int ind);
    int StateMain(int ind);
    double State(int ind);
    bool ExtState(int ind);
    bool CompareMaps(int map, int count, bool minimax = false, int start = 0);
};

class CSignalRSI : public CExpertSignal {
public:
    CSignalRSI(void);
    ~CSignalRSI();
    void PeriodRSI(int value);
    void Applied(ENUM_APPLIED_PRICE value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    void Pattern_2(int value);
    void Pattern_3(int value);
    void Pattern_4(int value);
    void Pattern_5(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiRSI m_rsi;
    int m_periodRSI;
    ENUM_APPLIED_PRICE m_applied;
    int m_pattern_0;
    int m_pattern_1;
    int m_pattern_2;
    int m_pattern_3;
    int m_pattern_4;
    int m_pattern_5;
    double m_extr_osc;
    double m_extr_pr;
    int m_extr_pos;
    uint m_extr_map;
    bool InitRSI(CIndicators * indicators);
    double RSI(int ind);
    double DiffRSI(int ind);
    int StateRSI(int ind);
    bool ExtStateRSI(int ind);
    bool CompareMaps(int map, int count, bool minimax = false, int start = 0);
};

class CSignalRVI : public CExpertSignal {
public:
    CSignalRVI(void);
    ~CSignalRVI();
    void PeriodRVI(int value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiRVI m_rvi;
    int m_periodRVI;
    int m_pattern_0;
    int m_pattern_1;
    bool InitRVI(CIndicators * indicators);
    double Main(int ind);
    double DiffMain(int ind);
    double Signal(int ind);
    double DiffSignal(int ind);
    double DiffMainSignal(int ind);
};

class CSignalSAR : public CExpertSignal {
public:
    CSignalSAR(void);
    ~CSignalSAR();
    void Step(double value);
    void Maximum(double value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiSAR m_sar;
    double m_step;
    double m_maximum;
    int m_pattern_0;
    int m_pattern_1;
    bool InitSAR(CIndicators * indicators);
    double SAR(int ind);
    double Close(int ind);
    double DiffClose(int ind);
};

class CSignalStoch : public CExpertSignal {
public:
    CSignalStoch(void);
    ~CSignalStoch();
    void PeriodK(int value);
    void PeriodD(int value);
    void PeriodSlow(int value);
    void Applied(ENUM_STO_PRICE value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    void Pattern_2(int value);
    void Pattern_3(int value);
    void Pattern_4(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiStochastic m_stoch;
    int m_periodK;
    int m_periodD;
    int m_period_slow;
    ENUM_STO_PRICE m_applied;
    int m_pattern_0;
    int m_pattern_1;
    int m_pattern_2;
    int m_pattern_3;
    int m_pattern_4;
    double m_extr_osc;
    double m_extr_pr;
    int m_extr_pos;
    uint m_extr_map;
    bool InitStoch(CIndicators * indicators);
    double Main(int ind);
    double DiffMain(int ind);
    double Signal(int ind);
    double DiffSignal(int ind);
    double DiffMainSignal(int ind);
    int StateStoch(int ind);
    bool ExtStateStoch(int ind);
    bool CompareMaps(int map, int count, bool minimax = false, int start = 0);
    void DiverDebugPrint();
};

class CSignalTEMA : public CExpertSignal {
public:
    CSignalTEMA(void);
    ~CSignalTEMA();
    void PeriodMA(int value);
    void Shift(int value);
    void Applied(ENUM_APPLIED_PRICE value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    void Pattern_2(int value);
    void Pattern_3(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiTEMA m_ma;
    int m_ma_period;
    int m_ma_shift;
    ENUM_APPLIED_PRICE m_ma_applied;
    int m_pattern_0;
    int m_pattern_1;
    int m_pattern_2;
    int m_pattern_3;
    bool InitMA(CIndicators * indicators);
    double MA(int ind);
    double DiffMA(int ind);
    double DiffOpenMA(int ind);
    double DiffHighMA(int ind);
    double DiffLowMA(int ind);
    double DiffCloseMA(int ind);
};

class CSignalTriX : public CExpertSignal {
public:
    CSignalTriX(void);
    ~CSignalTriX();
    void PeriodTriX(int value);
    void Applied(ENUM_APPLIED_PRICE value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    void Pattern_2(int value);
    void Pattern_3(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiTriX m_trix;
    int m_period_trix;
    ENUM_APPLIED_PRICE m_applied;
    int m_pattern_0;
    int m_pattern_1;
    int m_pattern_2;
    int m_pattern_3;
    double m_extr_osc;
    double m_extr_pr;
    int m_extr_pos;
    uint m_extr_map;
    bool InitTriX(CIndicators * indicators);
    double TriX(int ind);
    double DiffTriX(int ind);
    int State(int ind);
    bool ExtState(int ind);
    bool CompareMaps(int map, int count, bool minimax = false, int start = 0);
};

class CSignalWPR : public CExpertSignal {
public:
    CSignalWPR(void);
    ~CSignalWPR();
    void PeriodWPR(int value);
    void Pattern_0(int value);
    void Pattern_1(int value);
    void Pattern_2(int value);
    virtual bool ValidationSettings(void);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual int LongCondition(void);
    virtual int ShortCondition(void);
protected:
    CiWPR m_wpr;
    int m_period_wpr;
    int m_pattern_0;
    int m_pattern_1;
    int m_pattern_2;
    double m_extr_osc;
    double m_extr_pr;
    int m_extr_pos;
    uint m_extr_map;
    bool InitWPR(CIndicators * indicators);
    double WPR(int ind);
    double Diff(int ind);
    int State(int ind);
    bool ExtState(int ind);
    bool CompareMaps(int map, int count, bool minimax = false, int start = 0);
};

class CTrailingFixedPips : public CExpertTrailing {
public:
    CTrailingFixedPips(void);
    ~CTrailingFixedPips();
    void StopLevel(int stop_level);
    void ProfitLevel(int profit_level);
    virtual bool ValidationSettings(void);
    virtual bool CheckTrailingStopLong(CPositionInfo * position, double & sl, double & tp);
    virtual bool CheckTrailingStopShort(CPositionInfo * position, double & sl, double & tp);
protected:
    int m_stop_level;
    int m_profit_level;
};

class CTrailingMA : public CExpertTrailing {
public:
    CTrailingMA(void);
    ~CTrailingMA();
    void Period(int period);
    void Shift(int shift);
    void Method(ENUM_MA_METHOD method);
    void Applied(ENUM_APPLIED_PRICE applied);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual bool ValidationSettings(void);
    virtual bool CheckTrailingStopLong(CPositionInfo * position, double & sl, double & tp);
    virtual bool CheckTrailingStopShort(CPositionInfo * position, double & sl, double & tp);
protected:
    int m_ma_period;
    int m_ma_shift;
    ENUM_MA_METHOD m_ma_method;
    ENUM_APPLIED_PRICE m_ma_applied;
};

class CTrailingNone : public CExpertTrailing {
public:
    CTrailingNone(void);
    ~CTrailingNone();
};

class CTrailingPSAR : public CExpertTrailing {
public:
    CTrailingPSAR(void);
    ~CTrailingPSAR();
    void Step(double step);
    void Maximum(double maximum);
    virtual bool InitIndicators(CIndicators * indicators);
    virtual bool CheckTrailingStopLong(CPositionInfo * position, double & sl, double & tp);
    virtual bool CheckTrailingStopShort(CPositionInfo * position, double & sl, double & tp);
protected:
    CiSAR m_sar;
    double m_step;
    double m_maximum;
};

class CFile : public CObject {
public:
    CFile(void);
    ~CFile();
    int Handle(void) const;
    string FileName(void) const;
    int Flags(void) const;
    void SetUnicode(const bool unicode);
    void SetCommon(const bool common);
    int Open(const string file_name, int open_flags, const short delimiter = '\t');
    void Close(void);
    void Delete(void);
    ulong Size(void);
    ulong Tell(void);
    void Seek(const long offset, const ENUM_FILE_POSITION origin);
    void Flush(void);
    bool IsEnding(void);
    bool IsLineEnding(void);
    void Delete(const string file_name, const int common_flag = 0);
    bool IsExist(const string file_name, const int common_flag = 0);
    bool Copy(const string src_name, const int common_flag, const string dst_name, const int mode_flags);
    bool Move(const string src_name, const int common_flag, const string dst_name, const int mode_flags);
    bool FolderCreate(const string folder_name);
    bool FolderDelete(const string folder_name);
    bool FolderClean(const string folder_name);
    long FileFindFirst(const string file_filter, string & returned_filename);
    bool FileFindNext(const long search_handle, string & returned_filename);
    void FileFindClose(const long search_handle);
protected:
    int m_handle;
    string m_name;
    int m_flags;
};

class CFileBin : public CFile {
public:
    CFileBin(void);
    ~CFileBin();
    int Open(const string file_name, const int open_flags);
    uint WriteChar(const char value);
    uint WriteShort(const short value);
    uint WriteInteger(const int value);
    uint WriteLong(const long value);
    uint WriteFloat(const float value);
    uint WriteDouble(const double value);
    uint WriteString(const string value);
    uint WriteString(const string value, const int size);
    uint WriteCharArray(const char & array, const int start_item = 0, const int items_count = WHOLE_ARRAY);
    uint WriteShortArray(const short& array, const int start_item = 0, const int items_count = WHOLE_ARRAY);
    uint WriteIntegerArray(const int& array, const int start_item = 0, const int items_count = WHOLE_ARRAY);
    uint WriteLongArray(const long & array, const int start_item = 0, const int items_count = WHOLE_ARRAY);
    uint WriteFloatArray(const float & array, const int start_item = 0, const int items_count = WHOLE_ARRAY);
    uint WriteDoubleArray(const double & array, const int start_item = 0, const int items_count = WHOLE_ARRAY);
    bool WriteObject(CObject * object);
    bool ReadChar(char & value);
    bool ReadShort(short & value);
    bool ReadInteger(int & value);
    bool ReadLong(long & value);
    bool ReadFloat(float & value);
    bool ReadDouble(double & value);
    bool ReadString(string & value);
    bool ReadString(string & value, const int size);
    uint ReadCharArray(char & array, const int start_item = 0, const int items_count = WHOLE_ARRAY);
    uint ReadShortArray(short& array, const int start_item = 0, const int items_count = WHOLE_ARRAY);
    uint ReadIntegerArray(int& array, const int start_item = 0, const int items_count = WHOLE_ARRAY);
    uint ReadLongArray(long & array, const int start_item = 0, const int items_count = WHOLE_ARRAY);
    uint ReadFloatArray(float & array, const int start_item = 0, const int items_count = WHOLE_ARRAY);
    uint ReadDoubleArray(double & array, const int start_item = 0, const int items_count = WHOLE_ARRAY);
    bool ReadObject(CObject * object);
    template<typename T> uint WriteStruct(T &data);
    template<typename T> uint WriteArray(T &array, const int start_item = 0, const int items_count = WHOLE_ARRAY);
    template<typename T> uint WriteEnum(const T value);
    template<typename T> uint ReadArray(T &array, const int start_item = 0, const int items_count = WHOLE_ARRAY);
    template<typename T> bool ReadStruct(T &data);
    template<typename T> bool ReadEnum(T &value);
};

struct BITMAPFILEHEADER {
public:
    ushort bfType;
    uint bfSize;
    ushort bfReserved1;
    ushort bfReserved2;
    uint bfOffBits;
};

struct BITMAPINFOHEADER {
public:
    uint biSize;
    int biWidth;
    int biHeight;
    ushort biPlanes;
    ushort biBitCount;
    uint biCompression;
    uint biSizeImage;
    int biXPelsPerMeter;
    int biYPelsPerMeter;
    uint biClrUsed;
    uint biClrImportant;
};

class CFileBMP : public CObject {
public:
    CFileBMP(void);
    ~CFileBMP();
    int OpenWrite(const string file_name, bool common_flag = false);
    int OpenRead(const string file_name, bool common_flag = false);
    int Write32BitsArray(uint& uint_array, const int width, const int height);
    int Read32BitsArray(uint& uint_array, int& width, int& height);
    void Close(void);
protected:
    int m_handle;
    BITMAPFILEHEADER m_file_header;
    BITMAPINFOHEADER m_info_header;
};

class CFilePipe : public CFile {
public:
    CFilePipe(void);
    ~CFilePipe();
    int Open(const string file_name, const int open_flags);
    bool WaitForRead(const ulong size);
    uint WriteLong(const long value);
    uint WriteFloat(const float value);
    uint WriteDouble(const double value);
    uint WriteString(const string value);
    uint WriteString(const string value, const int size);
    bool WriteObject(CObject * object);
    bool ReadLong(long & value);
    bool ReadFloat(float & value);
    bool ReadDouble(double & value);
    bool ReadString(string & value);
    bool ReadString(string & value, const int size);
    bool ReadObject(CObject * object);
};

class CFileTxt : public CFile {
public:
    CFileTxt(void);
    ~CFileTxt();
    int Open(const string file_name, const int open_flags);
    uint WriteString(const string value);
    string ReadString(void);
};

template<typename T>
struct Slot {
public:
    int hash_code;
    T value;
    int next;
    Slot(void);
};

struct Introsort {
public:
    TKey keys;
    TItem items;
    Introsort(void);
    ~Introsort();
    void Sort(const int index, const int length);
};

class CPrimeGenerator {
public:
    static bool IsPrime(const int candidate);
    static int GetPrime(const int min);
    static int ExpandPrime(const int old_size);
};

template<typename T>
class CLinkedListNode {
public:
    CLinkedListNode(T value);
    CLinkedListNode(CLinkedList<T>* list, T value);
    ~CLinkedListNode();
    void List(CLinkedList<T>* value);
    void Next(CLinkedListNode<T>* value);
    void Previous(CLinkedListNode<T>* value);
    T Value(void);
    void Value(T value);
protected:
    T m_item;
};

class CAxis {
public:
    CAxis(void);
    ~CAxis();
    double Step(void) const;
    double Min(void) const;
    void Min(const double min);
    double Max(void) const;
    void Max(const double max);
    string Name(void) const;
    void Name(const string name);
    ENUM_AXIS_TYPE Type(void) const;
    void Type(ENUM_AXIS_TYPE type);
    uint Color(void) const;
    void Color(const uint clr);
    bool AutoScale(void) const;
    void AutoScale(const bool auto);
    int ValuesSize(void) const;
    void ValuesSize(const int size);
    int ValuesWidth(void) const;
    void ValuesWidth(const int width);
    string ValuesFormat(void) const;
    void ValuesFormat(const string format);
    int ValuesDateTimeMode(void) const;
    void ValuesDateTimeMode(const int mode);
    DoubleToStringFunction ValuesFunctionFormat(void) const;
    void ValuesFunctionFormat(DoubleToStringFunction func);
    void ValuesFunctionFormatCBData(void * cbdata);
    string ValuesFontName(void) const;
    void ValuesFontName(const string fontname);
    uint ValuesFontAngle(void) const;
    void ValuesFontAngle(const uint fontangle);
    uint ValuesFontFlags(void) const;
    void ValuesFontFlags(const uint fontflags);
    int NameSize(void) const;
    void NameSize(const int size);
    double ZeroLever(void) const;
    void ZeroLever(const double value);
    double DefaultStep(void) const;
    void DefaultStep(const double value);
    double MaxLabels(void) const;
    void MaxLabels(const double value);
    double MinGrace(void) const;
    void MinGrace(const double value);
    double MaxGrace(void) const;
    void MaxGrace(const double value);
    void SelectAxisScale(void);
};

class CColorGenerator {
public:
    CColorGenerator(void);
    ~CColorGenerator();
    uint Next(void);
    void Reset(void);
};

struct CPoint2D {
public:
    double x;
    double y;
};

class CCurve : public CObject {
public:
    CCurve(const double & y, const uint clr, ENUM_CURVE_TYPE type, const string name);
    CCurve(const double & x, const double & y, const uint clr, ENUM_CURVE_TYPE type, const string name);
    CCurve(const CPoint2D & points, const uint clr, ENUM_CURVE_TYPE type, const string name);
    CCurve(CurveFunction function, const double from, const double to, const double step, const uint clr, ENUM_CURVE_TYPE type, const string name);
    ~CCurve();
    void GetX(double & x) const;
    void GetY(double & y) const;
    double XMax(void) const;
    double XMin(void) const;
    double YMax(void) const;
    double YMin(void) const;
    int Size(void) const;
    void Update(const double & y);
    void Update(const double & x, const double & y);
    void Update(const CPoint2D & points);
    void Update(CurveFunction function, const double from, const double to, const double step);
    uint Color(void) const;
    int Type(void) const;
    string Name(void) const;
    bool Visible(void) const;
    void Color(const uint clr);
    void Type(const int type);
    void Name(const string name);
    void Visible(const bool visible);
    ENUM_LINE_STYLE LinesStyle(void) const;
    ENUM_LINE_END LinesEndStyle(void) const;
    int LinesWidth(void) const;
    bool LinesSmooth(void) const;
    double LinesSmoothTension(void) const;
    double LinesSmoothStep(void) const;
    void LinesStyle(ENUM_LINE_STYLE style);
    void LinesEndStyle(ENUM_LINE_END end_style);
    void LinesWidth(const int width);
    void LinesSmooth(const bool smooth);
    void LinesSmoothTension(const double tension);
    void LinesSmoothStep(const double step);
    int PointsSize(void) const;
    ENUM_POINT_TYPE PointsType(void) const;
    bool PointsFill(void) const;
    uint PointsColor(void) const;
    void PointsSize(const int size);
    void PointsType(ENUM_POINT_TYPE type);
    void PointsFill(const bool fill);
    void PointsColor(const uint clr);
    int StepsDimension(void) const;
    void StepsDimension(const int dimension);
    int HistogramWidth(void) const;
    void HistogramWidth(const int width);
    PlotFucntion CustomPlotFunction(void) const;
    void CustomPlotFunction(PlotFucntion func);
    void CustomPlotCBData(void * cbdata);
    bool TrendLineVisible(void) const;
    uint TrendLineColor(void) const;
    void TrendLineVisible(const bool visible);
    void TrendLineColor(const uint clr);
    void TrendLineCoefficients(double & coefficients);
protected:
    bool m_trend_calc;
    double m_trend_coeff;
    virtual void CalculateCoefficients(void);
};

class CSeries : public CArrayObj {
public:
    CSeries(void);
    ~CSeries();
    string Name(void) const;
    int BuffersTotal(void) const;
    int BufferSize(void) const;
    int Timeframe(void) const;
    string Symbol(void) const;
    ENUM_TIMEFRAMES Period(void) const;
    string PeriodDescription(const int val = 0);
    void RefreshCurrent(const bool flag);
    virtual bool BufferResize(const int size);
    virtual void Refresh(const int flags);
protected:
    string m_name;
    int m_buffers_total;
    int m_buffer_size;
    int m_timeframe_flags;
    string m_symbol;
    ENUM_TIMEFRAMES m_period;
    bool m_refresh_current;
    datetime m_first_date;
    bool SetSymbolPeriod(const string symbol, const ENUM_TIMEFRAMES period);
    void PeriodToTimeframeFlag(const ENUM_TIMEFRAMES period);
    bool CheckLoadHistory(const int size);
    bool CheckTerminalHistory(const int size);
    bool CheckServerHistory(const int size);
};

class CIndicator : public CSeries {
public:
    CIndicator(void);
    ~CIndicator();
    int Handle(void) const;
    string Status(void) const;
    void FullRelease(const bool flag = true);
    void Redrawer(const bool flag = true);
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const ENUM_INDICATOR type, const int num_params, const MqlParam & params);
    virtual bool BufferResize(const int size);
    int BarsCalculated(void) const;
    double GetData(const int buffer_num, const int index) const;
    int GetData(const int start_pos, const int count, const int buffer_num, double & buffer) const;
    int GetData(const datetime start_time, const int count, const int buffer_num, double & buffer) const;
    int GetData(const datetime start_time, const datetime stop_time, const int buffer_num, double & buffer) const;
    int Minimum(const int buffer_num, const int start, const int count) const;
    double MinValue(const int buffer_num, const int start, const int count, int & index) const;
    int Maximum(const int buffer_num, const int start, const int count) const;
    double MaxValue(const int buffer_num, const int start, const int count, int & index) const;
    virtual void Refresh(const int flags = OBJ_ALL_PERIODS);
    bool AddToChart(const long chart, const int subwin);
    bool DeleteFromChart(const long chart, const int subwin);
    static string MethodDescription(const int val);
    static string PriceDescription(const int val);
    static string VolumeDescription(const int val);
protected:
    int m_handle;
    string m_status;
    bool m_full_release;
    bool m_redrawer;
    bool CreateBuffers(const string symbol, const ENUM_TIMEFRAMES period, const int buffers);
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
};

class CiAC : public CIndicator {
public:
    CiAC(void);
    ~CiAC();
    bool Create(const string symbol, const ENUM_TIMEFRAMES period);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period);
};

class CiAlligator : public CIndicator {
public:
    CiAlligator(void);
    ~CiAlligator();
    int JawPeriod(void) const;
    int JawShift(void) const;
    int TeethPeriod(void) const;
    int TeethShift(void) const;
    int LipsPeriod(void) const;
    int LipsShift(void) const;
    ENUM_MA_METHOD MaMethod(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int jaw_period, const int jaw_shift, const int teeth_period, const int teeth_shift, const int lips_period, const int lips_shift, const ENUM_MA_METHOD ma_method, const int applied);
    double Jaw(const int index) const;
    double Teeth(const int index) const;
    double Lips(const int index) const;
    virtual int Type(void) const;
protected:
    int m_jaw_period;
    int m_jaw_shift;
    int m_teeth_period;
    int m_teeth_shift;
    int m_lips_period;
    int m_lips_shift;
    ENUM_MA_METHOD m_ma_method;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int jaw_period, const int jaw_shift, const int teeth_period, const int teeth_shift, const int lips_period, const int lips_shift, const ENUM_MA_METHOD ma_method, const int applied);
};

class CiAO : public CIndicator {
public:
    CiAO(void);
    ~CiAO();
    bool Create(const string symbol, const ENUM_TIMEFRAMES period);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period);
};

class CiFractals : public CIndicator {
public:
    CiFractals(void);
    ~CiFractals();
    bool Create(const string symbol, const ENUM_TIMEFRAMES period);
    double Upper(const int index) const;
    double Lower(const int index) const;
    virtual int Type(void) const;
protected:
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period);
};

class CiGator : public CIndicator {
public:
    CiGator(void);
    ~CiGator();
    int JawPeriod(void) const;
    int JawShift(void) const;
    int TeethPeriod(void) const;
    int TeethShift(void) const;
    int LipsPeriod(void) const;
    int LipsShift(void) const;
    ENUM_MA_METHOD MaMethod(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int jaw_period, const int jaw_shift, const int teeth_period, const int teeth_shift, const int lips_period, const int lips_shift, const ENUM_MA_METHOD ma_method, const int applied);
    double Upper(const int index) const;
    double Lower(const int index) const;
    virtual int Type(void) const;
protected:
    int m_jaw_period;
    int m_jaw_shift;
    int m_teeth_period;
    int m_teeth_shift;
    int m_lips_period;
    int m_lips_shift;
    ENUM_MA_METHOD m_ma_method;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int jaw_period, const int jaw_shift, const int teeth_period, const int teeth_shift, const int lips_period, const int lips_shift, const ENUM_MA_METHOD ma_method, const int applied);
};

class CiBWMFI : public CIndicator {
public:
    CiBWMFI(void);
    ~CiBWMFI();
    ENUM_APPLIED_VOLUME Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const ENUM_APPLIED_VOLUME applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    ENUM_APPLIED_VOLUME m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const ENUM_APPLIED_VOLUME applied);
};

class CiCustom : public CIndicator {
public:
    CiCustom(void);
    ~CiCustom();
    bool NumBuffers(const int buffers);
    int NumParams(void) const;
    ENUM_DATATYPE ParamType(const int ind) const;
    long ParamLong(const int ind) const;
    double ParamDouble(const int ind) const;
    string ParamString(const int ind) const;
    virtual int Type(void) const;
protected:
    int m_num_params;
    MqlParam m_params;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
};

class CDoubleBuffer : public CArrayDouble {
public:
    CDoubleBuffer(void);
    ~CDoubleBuffer();
    void Size(const int size);
    double At(const int index) const;
    virtual bool Refresh(void);
    virtual bool RefreshCurrent(void);
    void SetSymbolPeriod(const string symbol, const ENUM_TIMEFRAMES period);
protected:
    string m_symbol;
    ENUM_TIMEFRAMES m_period;
    int m_size;
};

class CIndicatorBuffer : public CDoubleBuffer {
public:
    CIndicatorBuffer(void);
    ~CIndicatorBuffer();
    int Offset(void) const;
    void Offset(const int offset);
    string Name(void) const;
    void Name(const string name);
    double At(const int index) const;
    bool Refresh(const int handle, const int num);
    bool RefreshCurrent(const int handle, const int num);
protected:
    int m_offset;
    string m_name;
};

class CIndicators : public CArrayObj {
public:
    CIndicators(void);
    ~CIndicators();
    bool BufferResize(const int size);
    int Refresh(void);
protected:
    MqlDateTime m_prev_time;
    int TimeframesFlags(const MqlDateTime & time);
};

class CiATR : public CIndicator {
public:
    CiATR(void);
    ~CiATR();
    int MaPeriod(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period);
};

class CiBearsPower : public CIndicator {
public:
    CiBearsPower(void);
    ~CiBearsPower();
    int MaPeriod(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period);
};

class CiBullsPower : public CIndicator {
public:
    CiBullsPower(void);
    ~CiBullsPower();
    int MaPeriod(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period);
};

class CiCCI : public CIndicator {
public:
    CiCCI(void);
    ~CiCCI();
    int MaPeriod(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int applied);
};

class CiChaikin : public CIndicator {
public:
    CiChaikin(void);
    ~CiChaikin();
    int FastMaPeriod(void) const;
    int SlowMaPeriod(void) const;
    ENUM_MA_METHOD MaMethod(void) const;
    ENUM_APPLIED_VOLUME Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int fast_ma_period, const int slow_ma_period, const ENUM_MA_METHOD ma_method, const ENUM_APPLIED_VOLUME applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_fast_ma_period;
    int m_slow_ma_period;
    ENUM_MA_METHOD m_ma_method;
    ENUM_APPLIED_VOLUME m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int fast_ma_period, const int slow_ma_period, const ENUM_MA_METHOD ma_method, const ENUM_APPLIED_VOLUME applied);
};

class CiDeMarker : public CIndicator {
public:
    CiDeMarker(void);
    ~CiDeMarker();
    int MaPeriod(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period);
};

class CiForce : public CIndicator {
public:
    CiForce(void);
    ~CiForce();
    int MaPeriod(void) const;
    ENUM_MA_METHOD MaMethod(void) const;
    ENUM_APPLIED_VOLUME Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const ENUM_MA_METHOD ma_method, const ENUM_APPLIED_VOLUME applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    ENUM_MA_METHOD m_ma_method;
    ENUM_APPLIED_VOLUME m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const ENUM_MA_METHOD ma_method, const ENUM_APPLIED_VOLUME applied);
};

class CiMACD : public CIndicator {
public:
    CiMACD(void);
    ~CiMACD();
    int FastEmaPeriod(void) const;
    int SlowEmaPeriod(void) const;
    int SignalPeriod(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int fast_ema_period, const int slow_ema_period, const int signal_period, const int applied);
    double Main(const int index) const;
    double Signal(const int index) const;
    virtual int Type(void) const;
protected:
    int m_fast_ema_period;
    int m_slow_ema_period;
    int m_signal_period;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int fast_ema_period, const int slow_ema_period, const int signal_period, const int applied);
};

class CiMomentum : public CIndicator {
public:
    CiMomentum(void);
    ~CiMomentum();
    int MaPeriod(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int applied);
};

class CiOsMA : public CIndicator {
public:
    CiOsMA(void);
    ~CiOsMA();
    int FastEmaPeriod(void) const;
    int SlowEmaPeriod(void) const;
    int SignalPeriod(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int fast_ema_period, const int slow_ema_period, const int signal_period, const int applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_fast_ema_period;
    int m_slow_ema_period;
    int m_signal_period;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int fast_ema_period, const int slow_ema_period, const int signal_period, const int applied);
};

class CiRSI : public CIndicator {
public:
    CiRSI(void);
    ~CiRSI();
    int MaPeriod(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int applied);
};

class CiRVI : public CIndicator {
public:
    CiRVI(void);
    ~CiRVI();
    int MaPeriod(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period);
    double Main(const int index) const;
    double Signal(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period);
};

class CiStochastic : public CIndicator {
public:
    CiStochastic(void);
    ~CiStochastic();
    int Kperiod(void) const;
    int Dperiod(void) const;
    int Slowing(void) const;
    ENUM_MA_METHOD MaMethod(void) const;
    ENUM_STO_PRICE PriceField(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int Kperiod, const int Dperiod, const int slowing, const ENUM_MA_METHOD ma_method, const ENUM_STO_PRICE price_field);
    double Main(const int index) const;
    double Signal(const int index) const;
    virtual int Type(void) const;
protected:
    int m_Kperiod;
    int m_Dperiod;
    int m_slowing;
    ENUM_MA_METHOD m_ma_method;
    ENUM_STO_PRICE m_price_field;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int Kperiod, const int Dperiod, const int slowing, const ENUM_MA_METHOD ma_method, const ENUM_STO_PRICE price_field);
};

class CiWPR : public CIndicator {
public:
    CiWPR(void);
    ~CiWPR();
    int CalcPeriod(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int calc_period);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_calc_period;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int calc_period);
};

class CiTriX : public CIndicator {
public:
    CiTriX(void);
    ~CiTriX();
    int MaPeriod(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int applied);
};

class CPriceSeries : public CSeries {
public:
    CPriceSeries(void);
    ~CPriceSeries();
    virtual bool BufferResize(const int size);
    virtual int MinIndex(const int start, const int count) const;
    virtual double MinValue(const int start, const int count, int & index) const;
    virtual int MaxIndex(const int start, const int count) const;
    virtual double MaxValue(const int start, const int count, int & index) const;
    double GetData(const int index) const;
    virtual void Refresh(const int flags = OBJ_ALL_PERIODS);
};

class COpenBuffer : public CDoubleBuffer {
public:
    COpenBuffer(void);
    ~COpenBuffer();
    virtual bool Refresh(void);
    virtual bool RefreshCurrent(void);
};

class CiOpen : public CPriceSeries {
public:
    CiOpen(void);
    ~CiOpen();
    bool Create(const string symbol, const ENUM_TIMEFRAMES period);
    double GetData(const int index) const;
    int GetData(const int start_pos, const int count, double & buffer) const;
    int GetData(const datetime start_time, const int count, double & buffer) const;
    int GetData(const datetime start_time, const datetime stop_time, double & buffer) const;
};

class CHighBuffer : public CDoubleBuffer {
public:
    CHighBuffer(void);
    ~CHighBuffer();
    virtual bool Refresh(void);
    virtual bool RefreshCurrent(void);
};

class CiHigh : public CPriceSeries {
public:
    CiHigh(void);
    ~CiHigh();
    bool Create(const string symbol, const ENUM_TIMEFRAMES period);
    double GetData(const int index) const;
    int GetData(const int start_pos, const int count, double & buffer) const;
    int GetData(const datetime start_time, const int count, double & buffer) const;
    int GetData(const datetime start_time, const datetime stop_time, double & buffer) const;
};

class CLowBuffer : public CDoubleBuffer {
public:
    CLowBuffer(void);
    ~CLowBuffer();
    virtual bool Refresh(void);
    virtual bool RefreshCurrent(void);
};

class CiLow : public CPriceSeries {
public:
    CiLow(void);
    ~CiLow();
    bool Create(const string symbol, const ENUM_TIMEFRAMES period);
    double GetData(const int index) const;
    int GetData(const int start_pos, const int count, double & buffer) const;
    int GetData(const datetime start_time, const int count, double & buffer) const;
    int GetData(const datetime start_time, const datetime stop_time, double & buffer) const;
};

class CCloseBuffer : public CDoubleBuffer {
public:
    CCloseBuffer(void);
    ~CCloseBuffer();
    virtual bool Refresh(void);
    virtual bool RefreshCurrent(void);
};

class CiClose : public CPriceSeries {
public:
    CiClose(void);
    ~CiClose();
    bool Create(const string symbol, const ENUM_TIMEFRAMES period);
    double GetData(const int index) const;
    int GetData(const int start_pos, const int count, double & buffer) const;
    int GetData(const datetime start_time, const int count, double & buffer) const;
    int GetData(const datetime start_time, const datetime stop_time, double & buffer) const;
};

class CSpreadBuffer : public CArrayInt {
public:
    CSpreadBuffer(void);
    ~CSpreadBuffer();
    void Size(const int size);
    int At(const int index) const;
    virtual bool Refresh(void);
    virtual bool RefreshCurrent(void);
    void SetSymbolPeriod(const string symbol, const ENUM_TIMEFRAMES period);
protected:
    string m_symbol;
    ENUM_TIMEFRAMES m_period;
    int m_freshed_data;
    int m_size;
};

class CiSpread : public CSeries {
public:
    CiSpread(void);
    ~CiSpread();
    bool Create(const string symbol, const ENUM_TIMEFRAMES period);
    virtual bool BufferResize(const int size);
    int GetData(const int index) const;
    int GetData(const int start_pos, const int count, int & buffer) const;
    int GetData(const datetime start_time, const int count, int & buffer) const;
    int GetData(const datetime start_time, const datetime stop_time, int & buffer) const;
    virtual void Refresh(const int flags = OBJ_ALL_PERIODS);
};

class CTimeBuffer : public CArrayDatetime {
public:
    CTimeBuffer(void);
    ~CTimeBuffer();
    void Size(const int size);
    datetime At(const int index) const;
    virtual bool Refresh(void);
    virtual bool RefreshCurrent(void);
    void SetSymbolPeriod(const string symbol, const ENUM_TIMEFRAMES period);
protected:
    string m_symbol;
    ENUM_TIMEFRAMES m_period;
    int m_freshed_data;
    int m_size;
};

class CiTime : public CSeries {
public:
    CiTime(void);
    ~CiTime();
    bool Create(const string symbol, const ENUM_TIMEFRAMES period);
    virtual bool BufferResize(const int size);
    datetime GetData(const int index) const;
    int GetData(const int start_pos, const int count, datetime & buffer) const;
    int GetData(const datetime start_time, const int count, datetime & buffer) const;
    int GetData(const datetime start_time, const datetime stop_time, datetime & buffer) const;
    virtual void Refresh(const int flags = OBJ_ALL_PERIODS);
};

class CTickVolumeBuffer : public CArrayLong {
public:
    CTickVolumeBuffer(void);
    ~CTickVolumeBuffer();
    void Size(const int size);
    long At(const int index) const;
    virtual bool Refresh(void);
    virtual bool RefreshCurrent(void);
    void SetSymbolPeriod(const string symbol, const ENUM_TIMEFRAMES period);
protected:
    string m_symbol;
    ENUM_TIMEFRAMES m_period;
    int m_freshed_data;
    int m_size;
};

class CiTickVolume : public CSeries {
public:
    CiTickVolume(void);
    ~CiTickVolume();
    bool Create(const string symbol, const ENUM_TIMEFRAMES period);
    virtual bool BufferResize(const int size);
    long GetData(const int index) const;
    int GetData(const int start_pos, const int count, long & buffer) const;
    int GetData(const datetime start_time, const int count, long & buffer) const;
    int GetData(const datetime start_time, const datetime stop_time, long & buffer) const;
    virtual void Refresh(const int flags = OBJ_ALL_PERIODS);
};

class CRealVolumeBuffer : public CArrayLong {
public:
    CRealVolumeBuffer(void);
    ~CRealVolumeBuffer();
    void Size(const int size);
    long At(const int index) const;
    virtual bool Refresh(void);
    virtual bool RefreshCurrent(void);
    void SetSymbolPeriod(const string symbol, const ENUM_TIMEFRAMES period);
protected:
    string m_symbol;
    ENUM_TIMEFRAMES m_period;
    int m_freshed_data;
    int m_size;
};

class CiRealVolume : public CSeries {
public:
    CiRealVolume(void);
    ~CiRealVolume();
    bool Create(const string symbol, const ENUM_TIMEFRAMES period);
    virtual bool BufferResize(const int size);
    long GetData(const int index) const;
    int GetData(const int start_pos, const int count, long & buffer) const;
    int GetData(const datetime start_time, const int count, long & buffer) const;
    int GetData(const datetime start_time, const datetime stop_time, long & buffer) const;
    virtual void Refresh(const int flags = OBJ_ALL_PERIODS);
};

class CiADX : public CIndicator {
public:
    CiADX(void);
    ~CiADX();
    int MaPeriod(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period);
    double Main(const int index) const;
    double Plus(const int index) const;
    double Minus(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period);
};

class CiADXWilder : public CIndicator {
public:
    CiADXWilder(void);
    ~CiADXWilder();
    int MaPeriod(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period);
    double Main(const int index) const;
    double Plus(const int index) const;
    double Minus(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period);
};

class CiBands : public CIndicator {
public:
    CiBands(void);
    ~CiBands();
    int MaPeriod(void) const;
    int MaShift(void) const;
    double Deviation(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int ma_shift, const double deviation, const int applied);
    double Base(const int index) const;
    double Upper(const int index) const;
    double Lower(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    int m_ma_shift;
    double m_deviation;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int ma_shift, const double deviation, const int applied);
};

class CiEnvelopes : public CIndicator {
public:
    CiEnvelopes(void);
    ~CiEnvelopes();
    int MaPeriod(void) const;
    int MaShift(void) const;
    ENUM_MA_METHOD MaMethod(void) const;
    int Applied(void) const;
    double Deviation(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int ma_shift, const ENUM_MA_METHOD ma_method, const int applied, const double deviation);
    double Upper(const int index) const;
    double Lower(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    int m_ma_shift;
    ENUM_MA_METHOD m_ma_method;
    int m_applied;
    double m_deviation;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int ma_shift, const ENUM_MA_METHOD ma_method, const int applied, const double deviation);
};

class CiIchimoku : public CIndicator {
public:
    CiIchimoku(void);
    ~CiIchimoku();
    int TenkanSenPeriod(void) const;
    int KijunSenPeriod(void) const;
    int SenkouSpanBPeriod(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int tenkan_sen, const int kijun_sen, const int senkou_span_b);
    double TenkanSen(const int index) const;
    double KijunSen(const int index) const;
    double SenkouSpanA(const int index) const;
    double SenkouSpanB(const int index) const;
    double ChinkouSpan(const int index) const;
    virtual int Type(void) const;
protected:
    int m_tenkan_sen;
    int m_kijun_sen;
    int m_senkou_span_b;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int tenkan_sen, const int kijun_sen, const int senkou_span_b);
};

class CiMA : public CIndicator {
public:
    CiMA(void);
    ~CiMA();
    int MaPeriod(void) const;
    int MaShift(void) const;
    ENUM_MA_METHOD MaMethod(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int ma_shift, const ENUM_MA_METHOD ma_method, const int applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    int m_ma_shift;
    ENUM_MA_METHOD m_ma_method;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int ma_shift, const ENUM_MA_METHOD ma_method, const int applied);
};

class CiSAR : public CIndicator {
public:
    CiSAR(void);
    ~CiSAR();
    double SarStep(void) const;
    double Maximum(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const double step, const double maximum);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    double m_step;
    double m_maximum;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const double step, const double maximum);
};

class CiStdDev : public CIndicator {
public:
    CiStdDev(void);
    ~CiStdDev();
    int MaPeriod(void) const;
    int MaShift(void) const;
    ENUM_MA_METHOD MaMethod(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int ma_shift, const ENUM_MA_METHOD ma_method, const int applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    int m_ma_shift;
    ENUM_MA_METHOD m_ma_method;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int ma_shift, const ENUM_MA_METHOD ma_method, const int applied);
};

class CiDEMA : public CIndicator {
public:
    CiDEMA(void);
    ~CiDEMA();
    int MaPeriod(void) const;
    int IndShift(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int ind_shift, const int applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    int m_ind_shift;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int ind_shift, const int applied);
};

class CiTEMA : public CIndicator {
public:
    CiTEMA(void);
    ~CiTEMA();
    int MaPeriod(void) const;
    int IndShift(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int ma_shift, const int applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    int m_ind_shift;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int ma_shift, const int applied);
};

class CiFrAMA : public CIndicator {
public:
    CiFrAMA(void);
    ~CiFrAMA();
    int MaPeriod(void) const;
    int IndShift(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int ind_shift, const int applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    int m_ind_shift;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int ind_shift, const int applied);
};

class CiAMA : public CIndicator {
public:
    CiAMA(void);
    ~CiAMA();
    int MaPeriod(void) const;
    int FastEmaPeriod(void) const;
    int SlowEmaPeriod(void) const;
    int IndShift(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int fast_ema_period, const int slow_ema_period, const int ind_shift, const int applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    int m_fast_ema_period;
    int m_slow_ema_period;
    int m_ind_shift;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const int fast_ema_period, const int slow_ema_period, const int ind_shift, const int applied);
};

class CiVIDyA : public CIndicator {
public:
    CiVIDyA(void);
    ~CiVIDyA();
    int CmoPeriod(void) const;
    int EmaPeriod(void) const;
    int IndShift(void) const;
    int Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int cmo_period, const int ema_period, const int ind_shift, const int applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_cmo_period;
    int m_ema_period;
    int m_ind_shift;
    int m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int cmo_period, const int ema_period, const int ind_shift, const int applied);
};

class CiAD : public CIndicator {
public:
    CiAD(void);
    ~CiAD();
    ENUM_APPLIED_VOLUME Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const ENUM_APPLIED_VOLUME applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    ENUM_APPLIED_VOLUME m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const ENUM_APPLIED_VOLUME applied);
};

class CiMFI : public CIndicator {
public:
    CiMFI(void);
    ~CiMFI();
    int MaPeriod(void) const;
    ENUM_APPLIED_VOLUME Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const ENUM_APPLIED_VOLUME applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    int m_ma_period;
    ENUM_APPLIED_VOLUME m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int ma_period, const ENUM_APPLIED_VOLUME applied);
};

class CiOBV : public CIndicator {
public:
    CiOBV(void);
    ~CiOBV();
    ENUM_APPLIED_VOLUME Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const ENUM_APPLIED_VOLUME applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    ENUM_APPLIED_VOLUME m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const ENUM_APPLIED_VOLUME applied);
};

class CiVolumes : public CIndicator {
public:
    CiVolumes(void);
    ~CiVolumes();
    ENUM_APPLIED_VOLUME Applied(void) const;
    bool Create(const string symbol, const ENUM_TIMEFRAMES period, const ENUM_APPLIED_VOLUME applied);
    double Main(const int index) const;
    virtual int Type(void) const;
protected:
    ENUM_APPLIED_VOLUME m_applied;
    virtual bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const int num_params, const MqlParam & params);
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, const ENUM_APPLIED_VOLUME applied);
};

class CDictionary_Obj_Obj : public CObject {
public:
    CDictionary_Obj_Obj(void);
    ~CDictionary_Obj_Obj();
    CObject *Key();
    void Key(CObject * key);
    CObject *Value();
    void Value(CObject * value);
    void SetAll(CObject * key, CObject * value);
};

class CDictionary_String_Obj : public CObject {
public:
    CDictionary_String_Obj(void);
    ~CDictionary_String_Obj();
    string Key();
    void Key(const string key);
    CObject *Value();
    void Value(CObject * value);
    void SetAll(const string key, CObject * value);
};

class CDictionary_Obj_Double : public CObject {
public:
    CDictionary_Obj_Double(void);
    ~CDictionary_Obj_Double();
    void Key(CObject * key);
    double Value();
    void Value(const double value);
    void SetAll(CObject * key, const double value);
};

class ICondition : public CObject {
public:
    virtual bool IsTypeOf(EnCondition type);
};

class CSingleCondition : public ICondition {
public:
    CSingleCondition(void);
    CSingleCondition(INamedVariable * var, INamedValue * term);
    CSingleCondition(INamedVariable * var, INamedValue * term, bool not);
    ~CSingleCondition();
    void Var(INamedVariable * value);
    bool Not(void);
    void Not(bool not);
    void Term(INamedValue * value);
    virtual bool IsTypeOf(EnCondition type);
};

class CFuzzyCondition : public CSingleCondition {
public:
    CFuzzyCondition(CFuzzyVariable * var, CFuzzyTerm * term, bool not);
    CFuzzyCondition(CFuzzyVariable * var, CFuzzyTerm * term, bool not, HedgeType hedge);
    CFuzzyCondition(CFuzzyVariable * var, CFuzzyTerm * term);
    ~CFuzzyCondition();
    HedgeType Hedge(void);
    void Hedge(HedgeType value);
    virtual bool IsTypeOf(EnCondition type);
};

class CConditions : public ICondition {
public:
    CConditions(void);
    ~CConditions();
    bool Not(void);
    void Not(bool value);
    OperatorType Op(void);
    void Op(OperatorType value);
    virtual bool IsTypeOf(EnCondition type);
};

class IParsableRule : public CObject {
public:
    virtual void Condition(CConditions * value);
    virtual void Conclusion(CSingleCondition * value);
    virtual bool IsTypeOf(EnRule type);
};

class CGenericFuzzyRule : public IParsableRule {
public:
    CGenericFuzzyRule(void);
    ~CGenericFuzzyRule();
    void Condition(CConditions * value);
    virtual void Conclusion(CSingleCondition * value);
    virtual bool IsTypeOf(EnRule type);
};

class CMamdaniFuzzyRule : public CGenericFuzzyRule {
public:
    CMamdaniFuzzyRule(void);
    ~CMamdaniFuzzyRule();
    void Conclusion(CSingleCondition * value);
    double Weight(void);
    void Weight(const double value);
    virtual bool IsTypeOf(EnRule type);
};

class CSugenoFuzzyRule : public CGenericFuzzyRule {
public:
    CSugenoFuzzyRule(void);
    ~CSugenoFuzzyRule();
    void Conclusion(CSingleCondition * value);
    virtual bool IsTypeOf(EnRule type);
};

class INamedValue : public CObject {
public:
    virtual bool IsTypeOf(EnType type);
    virtual string Name(void);
    virtual void Name(const string name);
};

class CNamedValueImpl : public INamedValue {
public:
    virtual bool IsTypeOf(EnType type);
    virtual void Name(const string name);
    virtual string Name(void);
};

class CFuzzyTerm : public CNamedValueImpl {
public:
    CFuzzyTerm(const string name, IMembershipFunction * mf);
    ~CFuzzyTerm();
    virtual bool IsTypeOf(EnType type);
};

class INamedVariable : public INamedValue {
public:
    virtual bool IsTypeOf(EnType type);
};

class CNamedVariableImpl : public INamedVariable {
public:
    virtual bool IsTypeOf(EnType type);
    virtual void Name(const string name);
    virtual string Name(void);
};

class CFuzzyVariable : public CNamedVariableImpl {
public:
    CFuzzyVariable(const string name, const double min, const double max);
    ~CFuzzyVariable();
    virtual bool IsTypeOf(EnType type);
    void Max(const double max);
    double Max(void);
    void Min(const double min);
    double Min(void);
    void Terms(CList * terms);
    void AddTerm(CFuzzyTerm * term);
};

class CGenericFuzzySystem {
public:
    void AndMethod(EnAndMethod value);
    EnAndMethod AndMethod(void) const;
    void OrMethod(EnOrMethod value);
    EnOrMethod OrMethod(void) const;
protected:
    CGenericFuzzySystem(void);
    ~CGenericFuzzySystem();
    double EvaluateCondition(ICondition * condition, CList * fuzzifiedInput);
    double EvaluateConditionPair(const double cond1, const double cond2, OperatorType op);
};

class CNameHelper {
public:
    static bool IsValidName(const string name);
};

class CMamdaniFuzzySystem : public CGenericFuzzySystem {
public:
    CMamdaniFuzzySystem(void);
    ~CMamdaniFuzzySystem();
    ImplicationMethod GetImplicationMethod(void) const;
    void SetImplicationMethod(ImplicationMethod value);
    AggregationMethod GetAggregationMethod(void) const;
    void SetAggregationMethod(AggregationMethod value);
    DefuzzificationMethod GetDefuzzificationMethod(void) const;
    void SetDefuzzificationMethod(DefuzzificationMethod value);
    double Defuzzify(IMembershipFunction * mf, const double min, const double max);
};

class IMembershipFunction : public CObject {
public:
    virtual double GetValue(const double x);
};

class CNormalCombinationMembershipFunction : public IMembershipFunction {
public:
    CNormalCombinationMembershipFunction(void);
    CNormalCombinationMembershipFunction(const double b1, const double sigma1, const double b2, const double sigma2);
    ~CNormalCombinationMembershipFunction();
    void B1(const double b1);
    double B1(void);
    void Sigma1(const double sigma1);
    double Sigma1(void);
    void B2(const double b2);
    double B2(void);
    void Sigma2(const double sigma2);
    double Sigma2(void);
    double GetValue(const double x);
};

class CGeneralizedBellShapedMembershipFunction : public IMembershipFunction {
public:
    CGeneralizedBellShapedMembershipFunction(void);
    CGeneralizedBellShapedMembershipFunction(const double a, const double b, const double c);
    ~CGeneralizedBellShapedMembershipFunction();
    void A(const double a);
    double A(void);
    void B(const double b);
    double B(void);
    void C(const double c);
    double C(void);
    double GetValue(const double x);
};

class CS_ShapedMembershipFunction : public IMembershipFunction {
public:
    CS_ShapedMembershipFunction(void);
    CS_ShapedMembershipFunction(const double a, const double b);
    ~CS_ShapedMembershipFunction();
    void A(const double a);
    double A(void);
    void B(const double b);
    double B(void);
    double GetValue(const double x);
};

class CZ_ShapedMembershipFunction : public IMembershipFunction {
public:
    CZ_ShapedMembershipFunction(void);
    CZ_ShapedMembershipFunction(const double a, const double b);
    ~CZ_ShapedMembershipFunction();
    void A(const double a);
    double A(void);
    void B(const double b);
    double B(void);
    double GetValue(const double x);
};

class CP_ShapedMembershipFunction : public IMembershipFunction {
public:
    CP_ShapedMembershipFunction(void);
    CP_ShapedMembershipFunction(const double a, const double b, const double c, const double d);
    ~CP_ShapedMembershipFunction();
    void A(const double a);
    double A(void);
    void D(const double d);
    double D(void);
    void B(const double b);
    double B(void);
    void C(const double c);
    double C(void);
    double GetValue(const double x);
};

class CSigmoidalMembershipFunction : public IMembershipFunction {
public:
    CSigmoidalMembershipFunction(void);
    CSigmoidalMembershipFunction(const double a, const double c);
    ~CSigmoidalMembershipFunction();
    void A(const double a);
    double A(void);
    void C(const double c);
    double C(void);
    double GetValue(const double x);
};

class CProductTwoSigmoidalMembershipFunctions : public IMembershipFunction {
public:
    CProductTwoSigmoidalMembershipFunctions(void);
    CProductTwoSigmoidalMembershipFunctions(const double a1, const double c1, const double a2, const double c2);
    ~CProductTwoSigmoidalMembershipFunctions();
    void A1(const double a1);
    double A1(void);
    void C1(const double c1);
    double C1(void);
    void A2(const double a2);
    double A2(void);
    void C2(const double c2);
    double C2(void);
    double GetValue(const double x);
};

class CDifferencTwoSigmoidalMembershipFunction : public IMembershipFunction {
public:
    CDifferencTwoSigmoidalMembershipFunction(void);
    CDifferencTwoSigmoidalMembershipFunction(const double a1, const double c1, const double a2, const double c2);
    ~CDifferencTwoSigmoidalMembershipFunction();
    void A1(const double a1);
    double A1(void);
    void C1(const double c1);
    double C1(void);
    void A2(const double a2);
    double A2(void);
    void C2(const double c2);
    double C2(void);
    double GetValue(const double x);
};

class CTrapezoidMembershipFunction : public IMembershipFunction {
public:
    CTrapezoidMembershipFunction(void);
    CTrapezoidMembershipFunction(const double x1, const double x2, const double x3, const double x4);
    ~CTrapezoidMembershipFunction();
    void X1(const double x);
    double X1(void);
    void X2(const double x);
    double X2(void);
    void X3(const double x);
    double X3(void);
    void X4(const double x);
    double X4(void);
    double GetValue(const double x);
};

class CNormalMembershipFunction : public IMembershipFunction {
public:
    CNormalMembershipFunction(void);
    CNormalMembershipFunction(const double b, const double sigma);
    ~CNormalMembershipFunction();
    void B(const double b);
    double B(void);
    void Sigma(const double sigma);
    double Sigma(void);
    double GetValue(const double x);
};

class CTriangularMembershipFunction : public IMembershipFunction {
public:
    CTriangularMembershipFunction(void);
    CTriangularMembershipFunction(const double x1, const double x2, const double x3);
    ~CTriangularMembershipFunction();
    void X1(const double x);
    double X1(void);
    void X2(const double x);
    double X2(void);
    void X3(const double x);
    double X3(void);
    double GetValue(const double x);
};

class CConstantMembershipFunction : public IMembershipFunction {
public:
    CConstantMembershipFunction();
    CConstantMembershipFunction(const double constValue);
    ~CConstantMembershipFunction();
    double GetValue(const double x);
};

class CCompositeMembershipFunction : public IMembershipFunction {
public:
    CCompositeMembershipFunction(MfCompositionType composType);
    CCompositeMembershipFunction(MfCompositionType composType, IMembershipFunction * mf1, IMembershipFunction * mf2);
    CCompositeMembershipFunction(MfCompositionType composType, CList * mfs);
    ~CCompositeMembershipFunction();
    MfCompositionType CompositionType(void);
    void CompositionType(MfCompositionType value);
    double GetValue(double const);
};

class IExpression : public CObject {
public:
    virtual string Text(void);
    virtual bool IsTypeOf(EnLexem type);
};

class CLexem : public IExpression {
public:
    virtual string Text(void);
    virtual bool IsTypeOf(EnLexem type);
};

class CConditionExpression : public IExpression {
public:
    CConditionExpression(CArrayObj * expressions, CFuzzyCondition * condition);
    ~CConditionExpression();
    void Expressions(CArrayObj * value);
    void Condition(CFuzzyCondition * value);
    string Text(void);
    virtual bool IsTypeOf(EnLexem type);
};

class CKeywordLexem : public CLexem {
public:
    CKeywordLexem(const string name);
    ~CKeywordLexem();
    string Text(void);
    virtual bool IsTypeOf(EnLexem type);
};

class CVarLexem : public CLexem {
public:
    CVarLexem(INamedVariable * var, bool in);
    ~CVarLexem();
    void Var(INamedVariable * var);
    string Text(void);
    bool Input(void);
    void Input(bool value);
    virtual bool IsTypeOf(EnLexem type);
};

class IAltLexem : public CLexem {
public:
    virtual void Alternative(IAltLexem * value);
    virtual bool IsTypeOf(EnLexem type);
};

class CTermLexem : public IAltLexem {
public:
    CTermLexem(INamedValue * term, bool in);
    ~CTermLexem();
    void Term(INamedValue * value);
    string Text(void);
    void Alternative(IAltLexem * value);
    virtual bool IsTypeOf(EnLexem type);
};

class CRuleParser : public INamedVariable {
};

class CSugenoFuzzySystem : public CGenericFuzzySystem {
public:
    CSugenoFuzzySystem(void);
    ~CSugenoFuzzySystem();
};

class ISugenoFunction : public CNamedValueImpl {
public:
    virtual bool IsTypeOf(EnType type);
};

class CLinearSugenoFunction : public ISugenoFunction {
public:
    CLinearSugenoFunction(const string name, CList * in);
    CLinearSugenoFunction(const string name, CList * in, CList * coeffs, const double constValue);
    CLinearSugenoFunction(const string name, CList * in, const double  & coeffs);
    ~CLinearSugenoFunction();
    virtual bool IsTypeOf(EnType type);
    double ConstValue();
    void ConstValue(const double value);
    double GetCoefficient(CFuzzyVariable * var);
    void SetCoefficient(CFuzzyVariable * var, const double coeff);
    double Evaluate(CList * inputValues);
};

class CSugenoVariable : public CNamedVariableImpl {
public:
    CSugenoVariable(const string name);
    ~CSugenoVariable();
    virtual bool IsTypeOf(EnType type);
};

class COpenCL {
public:
    COpenCL(void);
    ~COpenCL();
    int GetContext(void) const;
    int GetProgram(void) const;
    int GetKernel(const int kernel_index) const;
    string GetKernelName(const int kernel_index) const;
    bool GetGlobalMemorySize(long & global_memory_size);
    bool GetLocalMemorySize(long & local_memory_size);
    bool GetMaxWorkgroupSize(long & max_workgroup_size);
    bool SupportDouble(void) const;
    bool Initialize(const string program, const bool show_log = true);
    void Shutdown(void);
    bool ContextCreate(const int device = CL_USE_ANY);
    void ContextClean(void);
    bool ProgramCreate(const string program, const bool show_log = true);
    void ProgramDelete(void);
    bool SetBuffersCount(const int total_buffers);
    bool SetKernelsCount(const int total_kernels);
    bool KernelCreate(const int kernel_index, const string kernel_name);
    bool KernelFree(const int kernel_index);
    long GetDeviceInfo(const int prop);
    long GetDeviceInfoInteger(ENUM_OPENCL_PROPERTY_INTEGER prop);
    long GetKernelInfoInteger(const int kernel_index, ENUM_OPENCL_PROPERTY_INTEGER prop);
    bool BufferCreate(const int buffer_index, const uint size_in_bytes, const uint flags);
    bool BufferFree(const int buffer_index);
    bool SetArgumentBuffer(const int kernel_index, const int arg_index, const int buffer_index);
    bool SetArgumentLocalMemory(const int kernel_index, const int arg_index, const int local_memory_size);
    bool Execute(const int kernel_index, const int work_dim, const uint & work_offset, const uint & work_size);
    bool Execute(const int kernel_index, const int work_dim, const uint & work_offset, const uint & work_size, const uint & local_work_size);
    ENUM_OPENCL_EXECUTION_STATUS ExecutionStatus(const int kernel_index);
protected:
    int m_context;
    int m_program;
    string m_kernel_names;
    int m_kernels;
    int m_kernels_total;
    int m_buffers;
    int m_buffers_total;
    string m_device_extensions;
    bool m_support_cl_khr_fp64;
};

class CString : public CObject {
public:
    CString(void);
    ~CString();
    string Str(void) const;
    uint Len(void) const;
    void Copy(string & copy) const;
    void Copy(CString * copy) const;
    bool Fill(const short character);
    void Assign(const string str);
    void Assign(const CString * str);
    void Append(const string str);
    void Append(const CString * str);
    uint Insert(const uint pos, const string substring);
    uint Insert(const uint pos, const CString * substring);
    int Compare(const string str) const;
    int Compare(const CString * str) const;
    int CompareNoCase(const string str) const;
    int CompareNoCase(const CString * str) const;
    string Left(const uint count) const;
    string Right(const uint count) const;
    string Mid(const uint pos, const uint count) const;
    int Trim(const string targets);
    int TrimLeft(const string targets);
    int TrimRight(const string targets);
    bool Clear(void);
    bool ToUpper(void);
    bool ToLower(void);
    void Reverse(void);
    int Find(const uint start, const string substring) const;
    int FindRev(const string substring) const;
    uint Remove(const string substring);
    uint Replace(const string substring, const string newstring);
protected:
    string m_string;
    virtual int Compare(const CObject * node, const int mode = 0) const;
};

class CAccountInfo : public CObject {
public:
    CAccountInfo(void);
    ~CAccountInfo();
    long Login(void) const;
    ENUM_ACCOUNT_TRADE_MODE TradeMode(void) const;
    string TradeModeDescription(void) const;
    long Leverage(void) const;
    ENUM_ACCOUNT_STOPOUT_MODE StopoutMode(void) const;
    string StopoutModeDescription(void) const;
    ENUM_ACCOUNT_MARGIN_MODE MarginMode(void) const;
    string MarginModeDescription(void) const;
    bool TradeAllowed(void) const;
    bool TradeExpert(void) const;
    int LimitOrders(void) const;
    double Balance(void) const;
    double Credit(void) const;
    double Profit(void) const;
    double Equity(void) const;
    double Margin(void) const;
    double FreeMargin(void) const;
    double MarginLevel(void) const;
    double MarginCall(void) const;
    double MarginStopOut(void) const;
    string Name(void) const;
    string Server(void) const;
    string Currency(void) const;
    string Company(void) const;
    long InfoInteger(const ENUM_ACCOUNT_INFO_INTEGER prop_id) const;
    double InfoDouble(const ENUM_ACCOUNT_INFO_DOUBLE prop_id) const;
    string InfoString(const ENUM_ACCOUNT_INFO_STRING prop_id) const;
    double OrderProfitCheck(const string symbol, const ENUM_ORDER_TYPE trade_operation, const double volume, const double price_open, const double price_close) const;
    double MarginCheck(const string symbol, const ENUM_ORDER_TYPE trade_operation, const double volume, const double price) const;
    double FreeMarginCheck(const string symbol, const ENUM_ORDER_TYPE trade_operation, const double volume, const double price) const;
    double MaxLotCheck(const string symbol, const ENUM_ORDER_TYPE trade_operation, const double price, const double percent = 100) const;
};

class CDealInfo : public CObject {
public:
    CDealInfo(void);
    ~CDealInfo();
    void Ticket(const ulong ticket);
    ulong Ticket(void) const;
    long Order(void) const;
    datetime Time(void) const;
    ulong TimeMsc(void) const;
    ENUM_DEAL_TYPE DealType(void) const;
    string TypeDescription(void) const;
    ENUM_DEAL_ENTRY Entry(void) const;
    string EntryDescription(void) const;
    long Magic(void) const;
    long PositionId(void) const;
    double Volume(void) const;
    double Price(void) const;
    double Commission(void) const;
    double Swap(void) const;
    double Profit(void) const;
    string Symbol(void) const;
    string Comment(void) const;
    string ExternalId(void) const;
    bool InfoInteger(ENUM_DEAL_PROPERTY_INTEGER prop_id, long & var) const;
    bool InfoDouble(ENUM_DEAL_PROPERTY_DOUBLE prop_id, double & var) const;
    bool InfoString(ENUM_DEAL_PROPERTY_STRING prop_id, string & var) const;
    string FormatAction(string & str, const uint action) const;
    string FormatEntry(string & str, const uint entry) const;
    string FormatDeal(string & str) const;
    bool SelectByIndex(const int index);
protected:
    ulong m_ticket;
};

class CHistoryOrderInfo : public CObject {
public:
    CHistoryOrderInfo(void);
    ~CHistoryOrderInfo();
    void Ticket(const ulong ticket);
    ulong Ticket(void) const;
    datetime TimeSetup(void) const;
    ulong TimeSetupMsc(void) const;
    datetime TimeDone(void) const;
    ulong TimeDoneMsc(void) const;
    ENUM_ORDER_TYPE OrderType(void) const;
    string TypeDescription(void) const;
    ENUM_ORDER_STATE State(void) const;
    string StateDescription(void) const;
    datetime TimeExpiration(void) const;
    ENUM_ORDER_TYPE_FILLING TypeFilling(void) const;
    string TypeFillingDescription(void) const;
    ENUM_ORDER_TYPE_TIME TypeTime(void) const;
    string TypeTimeDescription(void) const;
    long Magic(void) const;
    long PositionId(void) const;
    long PositionById(void) const;
    double VolumeInitial(void) const;
    double VolumeCurrent(void) const;
    double PriceOpen(void) const;
    double StopLoss(void) const;
    double TakeProfit(void) const;
    double PriceCurrent(void) const;
    double PriceStopLimit(void) const;
    string Symbol(void) const;
    string Comment(void) const;
    string ExternalId(void) const;
    bool InfoInteger(const ENUM_ORDER_PROPERTY_INTEGER prop_id, long & var) const;
    bool InfoDouble(const ENUM_ORDER_PROPERTY_DOUBLE prop_id, double & var) const;
    bool InfoString(const ENUM_ORDER_PROPERTY_STRING prop_id, string & var) const;
    string FormatType(string & str, const uint type) const;
    string FormatStatus(string & str, const uint status) const;
    string FormatTypeFilling(string & str, const uint type) const;
    string FormatTypeTime(string & str, const uint type) const;
    string FormatOrder(string & str) const;
    string FormatPrice(string & str, const double price_order, const double price_trigger, const uint digits) const;
    bool SelectByIndex(const int index);
protected:
    ulong m_ticket;
};

class COrderInfo : public CObject {
public:
    COrderInfo(void);
    ~COrderInfo();
    ulong Ticket(void) const;
    datetime TimeSetup(void) const;
    ulong TimeSetupMsc(void) const;
    datetime TimeDone(void) const;
    ulong TimeDoneMsc(void) const;
    ENUM_ORDER_TYPE OrderType(void) const;
    string TypeDescription(void) const;
    ENUM_ORDER_STATE State(void) const;
    string StateDescription(void) const;
    datetime TimeExpiration(void) const;
    ENUM_ORDER_TYPE_FILLING TypeFilling(void) const;
    string TypeFillingDescription(void) const;
    ENUM_ORDER_TYPE_TIME TypeTime(void) const;
    string TypeTimeDescription(void) const;
    long Magic(void) const;
    long PositionId(void) const;
    long PositionById(void) const;
    double VolumeInitial(void) const;
    double VolumeCurrent(void) const;
    double PriceOpen(void) const;
    double StopLoss(void) const;
    double TakeProfit(void) const;
    double PriceCurrent(void) const;
    double PriceStopLimit(void) const;
    string Symbol(void) const;
    string Comment(void) const;
    string ExternalId(void) const;
    bool InfoInteger(const ENUM_ORDER_PROPERTY_INTEGER prop_id, long & var) const;
    bool InfoDouble(const ENUM_ORDER_PROPERTY_DOUBLE prop_id, double & var) const;
    bool InfoString(const ENUM_ORDER_PROPERTY_STRING prop_id, string & var) const;
    string FormatType(string & str, const uint type) const;
    string FormatStatus(string & str, const uint status) const;
    string FormatTypeFilling(string & str, const uint type) const;
    string FormatTypeTime(string & str, const uint type) const;
    string FormatOrder(string & str) const;
    string FormatPrice(string & str, const double price_order, const double price_trigger, const uint digits) const;
    bool Select(void);
    bool Select(const ulong ticket);
    bool SelectByIndex(const int index);
    void StoreState(void);
    bool CheckState(void);
protected:
    ulong m_ticket;
    ENUM_ORDER_TYPE m_type;
    ENUM_ORDER_STATE m_state;
    datetime m_expiration;
    double m_volume_curr;
    double m_price_open;
    double m_stop_loss;
    double m_take_profit;
};

class CPositionInfo : public CObject {
public:
    CPositionInfo(void);
    ~CPositionInfo();
    ulong Ticket(void) const;
    datetime Time(void) const;
    ulong TimeMsc(void) const;
    datetime TimeUpdate(void) const;
    ulong TimeUpdateMsc(void) const;
    ENUM_POSITION_TYPE PositionType(void) const;
    string TypeDescription(void) const;
    long Magic(void) const;
    long Identifier(void) const;
    double Volume(void) const;
    double PriceOpen(void) const;
    double StopLoss(void) const;
    double TakeProfit(void) const;
    double PriceCurrent(void) const;
    double Commission(void) const;
    double Swap(void) const;
    double Profit(void) const;
    string Symbol(void) const;
    string Comment(void) const;
    bool InfoInteger(const ENUM_POSITION_PROPERTY_INTEGER prop_id, long & var) const;
    bool InfoDouble(const ENUM_POSITION_PROPERTY_DOUBLE prop_id, double & var) const;
    bool InfoString(const ENUM_POSITION_PROPERTY_STRING prop_id, string & var) const;
    string FormatType(string & str, const uint type) const;
    string FormatPosition(string & str) const;
    bool Select(const string symbol);
    bool SelectByMagic(const string symbol, const ulong magic);
    bool SelectByTicket(const ulong ticket);
    bool SelectByIndex(const int index);
    void StoreState(void);
    bool CheckState(void);
protected:
    ENUM_POSITION_TYPE m_type;
    double m_volume;
    double m_price;
    double m_stop_loss;
    double m_take_profit;
};

class CSymbolInfo : public CObject {
public:
    CSymbolInfo(void);
    ~CSymbolInfo();
    string Name(void) const;
    bool Name(const string name);
    bool Refresh(void);
    bool RefreshRates(void);
    bool Select(void) const;
    bool Select(const bool select);
    bool IsSynchronized(void) const;
    ulong Volume(void) const;
    ulong VolumeHigh(void) const;
    ulong VolumeLow(void) const;
    datetime Time(void) const;
    int Spread(void) const;
    bool SpreadFloat(void) const;
    int TicksBookDepth(void) const;
    int StopsLevel(void) const;
    int FreezeLevel(void) const;
    double Bid(void) const;
    double BidHigh(void) const;
    double BidLow(void) const;
    double Ask(void) const;
    double AskHigh(void) const;
    double AskLow(void) const;
    double Last(void) const;
    double LastHigh(void) const;
    double LastLow(void) const;
    int OrderMode(void) const;
    ENUM_SYMBOL_CALC_MODE TradeCalcMode(void) const;
    string TradeCalcModeDescription(void) const;
    ENUM_SYMBOL_TRADE_MODE TradeMode(void) const;
    string TradeModeDescription(void) const;
    ENUM_SYMBOL_TRADE_EXECUTION TradeExecution(void) const;
    string TradeExecutionDescription(void) const;
    ENUM_SYMBOL_SWAP_MODE SwapMode(void) const;
    string SwapModeDescription(void) const;
    ENUM_DAY_OF_WEEK SwapRollover3days(void) const;
    string SwapRollover3daysDescription(void) const;
    datetime StartTime(void) const;
    datetime ExpirationTime(void) const;
    double MarginInitial(void) const;
    double MarginMaintenance(void) const;
    bool MarginHedgedUseLeg(void) const;
    double MarginHedged(void) const;
    double MarginLong(void) const;
    double MarginShort(void) const;
    double MarginLimit(void) const;
    double MarginStop(void) const;
    double MarginStopLimit(void) const;
    int TradeTimeFlags(void) const;
    int TradeFillFlags(void) const;
    int Digits(void) const;
    double Point(void) const;
    double TickValue(void) const;
    double TickValueProfit(void) const;
    double TickValueLoss(void) const;
    double TickSize(void) const;
    double ContractSize(void) const;
    double LotsMin(void) const;
    double LotsMax(void) const;
    double LotsStep(void) const;
    double LotsLimit(void) const;
    double SwapLong(void) const;
    double SwapShort(void) const;
    string CurrencyBase(void) const;
    string CurrencyProfit(void) const;
    string CurrencyMargin(void) const;
    string Bank(void) const;
    string Description(void) const;
    string Path(void) const;
    long SessionDeals(void) const;
    long SessionBuyOrders(void) const;
    long SessionSellOrders(void) const;
    double SessionTurnover(void) const;
    double SessionInterest(void) const;
    double SessionBuyOrdersVolume(void) const;
    double SessionSellOrdersVolume(void) const;
    double SessionOpen(void) const;
    double SessionClose(void) const;
    double SessionAW(void) const;
    double SessionPriceSettlement(void) const;
    double SessionPriceLimitMin(void) const;
    double SessionPriceLimitMax(void) const;
    bool InfoInteger(const ENUM_SYMBOL_INFO_INTEGER prop_id, long& var) const;
    bool InfoDouble(const ENUM_SYMBOL_INFO_DOUBLE prop_id, double& var) const;
    bool InfoString(const ENUM_SYMBOL_INFO_STRING prop_id, string& var) const;
    bool InfoMarginRate(const ENUM_ORDER_TYPE order_type, double& initial_margin_rate, double& maintenance_margin_rate) const;
    double NormalizePrice(const double price) const;
    bool CheckMarketWatch(void);
protected:
    string m_name;
    MqlTick m_tick;
    double m_point;
    double m_tick_value;
    double m_tick_value_profit;
    double m_tick_value_loss;
    double m_tick_size;
    double m_contract_size;
    double m_lots_min;
    double m_lots_max;
    double m_lots_step;
    double m_lots_limit;
    double m_swap_long;
    double m_swap_short;
    int m_digits;
    int m_order_mode;
    ENUM_SYMBOL_TRADE_EXECUTION m_trade_execution;
    ENUM_SYMBOL_CALC_MODE m_trade_calcmode;
    ENUM_SYMBOL_TRADE_MODE m_trade_mode;
    ENUM_SYMBOL_SWAP_MODE m_swap_mode;
    ENUM_DAY_OF_WEEK m_swap3;
    double m_margin_initial;
    double m_margin_maintenance;
    bool m_margin_hedged_use_leg;
    double m_margin_hedged;
    int m_trade_time_flags;
    int m_trade_fill_flags;
};

class CTerminalInfo : public CObject {
public:
    CTerminalInfo(void);
    ~CTerminalInfo();
    int Build(void) const;
    bool IsConnected(void) const;
    bool IsDLLsAllowed(void) const;
    bool IsTradeAllowed(void) const;
    bool IsEmailEnabled(void) const;
    bool IsFtpEnabled(void) const;
    int MaxBars(void) const;
    int CodePage(void) const;
    int CPUCores(void) const;
    int MemoryPhysical(void) const;
    int MemoryTotal(void) const;
    int MemoryAvailable(void) const;
    int MemoryUsed(void) const;
    bool IsX64(void) const;
    int OpenCLSupport(void) const;
    int DiskSpace(void) const;
    string Language(void) const;
    string Name(void) const;
    string Company(void) const;
    string Path(void) const;
    string DataPath(void) const;
    string CommonDataPath(void) const;
    long InfoInteger(const ENUM_TERMINAL_INFO_INTEGER prop_id) const;
    string InfoString(const ENUM_TERMINAL_INFO_STRING prop_id) const;
};

struct BY_HANDLE_FILE_INFORMATION {
public:
    uint dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    uint dwVolumeSerialNumber;
    uint nFileSizeHigh;
    uint nFileSizeLow;
    uint nNumberOfLinks;
    uint nFileIndexHigh;
    uint nFileIndexLow;
};

struct CREATEFILE2_EXTENDED_PARAMETERS {
public:
    uint dwSize;
    uint dwFileAttributes;
    uint dwFileFlags;
    uint dwSecurityQosFlags;
    PVOID lpSecurityAttributes;
    HANDLE hTemplateFile;
};

struct FILE_ATTRIBUTE_DATA {
public:
    uint dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    uint nFileSizeHigh;
    uint nFileSizeLow;
};

struct FIND_STREAM_DATA {
public:
    long StreamSize;
    short cStreamName;
};

struct FIND_DATAW {
public:
    uint dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    uint nFileSizeHigh;
    uint nFileSizeLow;
    uint dwReserved0;
    uint dwReserved1;
    short cFileName;
    short cAlternateFileName;
};

struct ENUMUILANG {
public:
    uint NumOfEnumUILang;
    uint SizeOfEnumUIBuffer;
    PVOID EnumUIBuffer;
};

struct WIN32_MEMORY_RANGE_ENTRY {
public:
    PVOID VirtualAddress;
    ulong NumberOfBytes;
};

struct PROCESS_INFORMATION {
public:
    HANDLE hProcess;
    HANDLE hThread;
    uint dwProcessId;
    uint dwThreadId;
};

struct STARTUPINFOW {
public:
    uint cb;
    string lpReserved;
    string lpDesktop;
    string lpTitle;
    uint dwX;
    uint dwY;
    uint dwXSize;
    uint dwYSize;
    uint dwXCountChars;
    uint dwYCountChars;
    uint dwFillAttribute;
    uint dwFlags;
    ushort wShowWindow;
    ushort cbReserved2;
    PVOID lpReserved2;
    HANDLE hStdInput;
    HANDLE hStdOutput;
    HANDLE hStdError;
};

struct MEMORY_PRIORITY_INFORMATION {
public:
    uint MemoryPriority;
};

struct THREAD_POWER_THROTTLING_STATE {
public:
    uint Version;
    uint ControlMask;
    uint StateMask;
};

struct APP_MEMORY_INFORMATION {
public:
    ulong AvailableCommit;
    ulong PrivateCommitUsage;
    ulong PeakPrivateCommitUsage;
    ulong TotalCommitUsage;
};

struct PROCESS_MEMORY_EXHAUSTION_INFO {
public:
    ushort Version;
    ushort Reserved;
    PROCESS_MEMORY_EXHAUSTION_TYPE Type;
    ulong Value;
};

struct PROCESS_POWER_THROTTLING_STATE {
public:
    uint Version;
    uint ControlMask;
    uint StateMask;
};

struct PROCESS_PROTECTION_LEVEL_INFORMATION {
public:
    uint ProtectionLevel;
};

struct DUMMYSTRUCTNAME {
public:
    uint dwOemId;
    ushort wProcessorArchitecture;
    ushort wReserved;
};

struct MEMORYSTATUSEX {
public:
    uint dwLength;
    uint dwMemoryLoad;
    ulong ullTotalPhys;
    ulong ullAvailPhys;
    ulong ullTotalPageFile;
    ulong ullAvailPageFile;
    ulong ullTotalVirtual;
    ulong ullAvailVirtual;
    ulong ullAvailExtendedVirtual;
};

struct SYSTEM_INFO {
public:
    uint dwOemId;
    uint dwPageSize;
    PVOID lpMinimumApplicationAddress;
    PVOID lpMaximumApplicationAddress;
    ulong dwActiveProcessorMask;
    uint dwNumberOfProcessors;
    uint dwProcessorType;
    uint dwAllocationGranularity;
    ushort wProcessorLevel;
    ushort wProcessorRevision;
};

struct ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA {
public:
    PVOID lpInformation;
    PVOID lpSectionBase;
    uint ulSectionLength;
    PVOID lpSectionGlobalDataBase;
    uint ulSectionGlobalDataLength;
};

struct ACTCTX_SECTION_KEYED_DATA {
public:
    uint cbSize;
    uint ulDataFormatVersion;
    PVOID lpData;
    uint ulLength;
    PVOID lpSectionGlobalData;
    uint ulSectionGlobalDataLength;
    PVOID lpSectionBase;
    uint ulSectionTotalLength;
    HANDLE hActCtx;
    uint ulAssemblyRosterIndex;
    uint ulFlags;
    ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA AssemblyMetadata;
};

struct ACTCTX_SECTION_KEYED_DATA_2600 {
public:
    uint cbSize;
    uint ulDataFormatVersion;
    PVOID lpData;
    uint ulLength;
    PVOID lpSectionGlobalData;
    uint ulSectionGlobalDataLength;
    PVOID lpSectionBase;
    uint ulSectionTotalLength;
    HANDLE hActCtx;
    uint ulAssemblyRosterIndex;
};

struct ACTCTXW {
public:
    uint cbSize;
    uint dwFlags;
    PVOID lpSource;
    ushort wProcessorArchitecture;
    ushort wLangId;
    PVOID lpAssemblyDirectory;
    PVOID lpResourceName;
    PVOID lpApplicationName;
    HANDLE hModule;
};

struct ACTIVATION_CONTEXT_BASIC_INFORMATION {
public:
    HANDLE hActCtx;
    uint dwFlags;
};

struct DCB {
public:
    uint DCBlength;
    uint BaudRate;
    uint Flags;
    ushort wReserved;
    ushort XonLim;
    ushort XoffLim;
    uchar ByteSize;
    uchar Parity;
    uchar StopBits;
    char XonChar;
    char XoffChar;
    char ErrorChar;
    char EofChar;
    char EvtChar;
    ushort wReserved1;
};

struct COMMCONFIG {
public:
    uint dwSize;
    ushort wVersion;
    ushort wReserved;
    DCB dcb;
    uint dwProviderSubType;
    uint dwProviderOffset;
    uint dwProviderSize;
    short wcProviderData;
};

struct COMMPROP {
public:
    ushort wPacketLength;
    ushort wPacketVersion;
    uint dwServiceMask;
    uint dwReserved1;
    uint dwMaxTxQueue;
    uint dwMaxRxQueue;
    uint dwMaxBaud;
    uint dwProvSubType;
    uint dwProvCapabilities;
    uint dwSettableParams;
    uint dwSettableBaud;
    ushort wSettableData;
    ushort wSettableStopParity;
    uint dwCurrentTxQueue;
    uint dwCurrentRxQueue;
    uint dwProvSpec1;
    uint dwProvSpec2;
    short wcProvChar;
};

struct COMMTIMEOUTS {
public:
    uint ReadIntervalTimeout;
    uint ReadTotalTimeoutMultiplier;
    uint ReadTotalTimeoutConstant;
    uint WriteTotalTimeoutMultiplier;
    uint WriteTotalTimeoutConstant;
};

struct COMSTAT {
public:
    uint cbInQue;
    uint cbOutQue;
};

struct COPYFILE2_EXTENDED_PARAMETERS {
public:
    uint dwSize;
    uint dwCopyFlags;
    PVOID pfCancel;
    PVOID pProgressRoutine;
    PVOID pvCallbackContext;
};

struct EVENTLOG_FULL_INFORMATION {
public:
    uint dwFull;
};

struct FILE_INFO {
};

struct FILE_ALIGNMENT_INFO : public FILE_INFO {
public:
    uint AlignmentRequirement;
};

struct FILE_ALLOCATION_INFO : public FILE_INFO {
public:
    long AllocationSize;
};

struct FILE_ATTRIBUTE_TAG_INFO : public FILE_INFO {
public:
    uint FileAttributes;
    uint ReparseTag;
};

struct FILE_BASIC_INFO : public FILE_INFO {
public:
    long CreationTime;
    long LastAccessTime;
    long LastWriteTime;
    long ChangeTime;
    uint FileAttributes;
};

struct FILE_COMPRESSION_INFO : public FILE_INFO {
public:
    long CompressedFileSize;
    ushort CompressionFormat;
    uchar CompressionUnitShift;
    uchar ChunkShift;
    uchar ClusterShift;
    uchar Reserved;
};

struct FILE_DISPOSITION_INFO : public FILE_INFO {
public:
    uchar DeleteFile;
};

struct FILE_DISPOSITION_INFO_EX : public FILE_INFO {
public:
    uint Flags;
};

struct FILE_END_OF_FILE_INFO : public FILE_INFO {
public:
    long EndOfFile;
};

struct FILE_FULL_DIR_INFO : public FILE_INFO {
public:
    uint NextEntryOffset;
    uint FileIndex;
    long CreationTime;
    long LastAccessTime;
    long LastWriteTime;
    long ChangeTime;
    long EndOfFile;
    long AllocationSize;
    uint FileAttributes;
    uint FileNameLength;
    uint EaSize;
    short FileName;
};

struct FILE_ID_BOTH_DIR_INFO : public FILE_INFO {
public:
    uint NextEntryOffset;
    uint FileIndex;
    long CreationTime;
    long LastAccessTime;
    long LastWriteTime;
    long ChangeTime;
    long EndOfFile;
    long AllocationSize;
    uint FileAttributes;
    uint FileNameLength;
    uint EaSize;
    char ShortNameLength;
    short ShortName;
    long FileId;
    short FileName;
};

struct FILE_ID_EXTD_DIR_INFO : public FILE_INFO {
public:
    uint NextEntryOffset;
    uint FileIndex;
    long CreationTime;
    long LastAccessTime;
    long LastWriteTime;
    long ChangeTime;
    long EndOfFile;
    long AllocationSize;
    uint FileAttributes;
    uint FileNameLength;
    uint EaSize;
    uint ReparsePointTag;
    FILE_ID_128 FileId;
    short FileName;
};

struct FILE_ID_INFO : public FILE_INFO {
public:
    ulong VolumeSerialNumber;
    FILE_ID_128 FileId;
};

struct FILE_IO_PRIORITY_HINT_INFO : public FILE_INFO {
public:
    PRIORITY_HINT PriorityHint;
};

struct FILE_NAME_INFO {
public:
    uint FileNameLength;
    short FileName;
};

struct FILE_STANDARD_INFO : public FILE_INFO {
public:
    long AllocationSize;
    long EndOfFile;
    uint NumberOfLinks;
    uchar DeletePending;
    uchar Directory;
};

struct FILE_STORAGE_INFO : public FILE_INFO {
public:
    uint LogicalBytesPerSector;
    uint PhysicalBytesPerSectorForAtomicity;
    uint PhysicalBytesPerSectorForPerformance;
    uint FileSystemEffectivePhysicalBytesPerSectorForAtomicity;
    uint Flags;
    uint ByteOffsetForSectorAlignment;
    uint ByteOffsetForPartitionAlignment;
};

struct FILE_STREAM_INFO : public FILE_INFO {
public:
    uint NextEntryOffset;
    uint StreamNameLength;
    long StreamSize;
    long StreamAllocationSize;
    short StreamName;
};

struct HW_PROFILE_INFOW {
public:
    uint dwDockInfo;
    short szHwProfileGuid;
    short szHwProfileName;
};

struct JIT_DEBUG_INFO {
public:
    uint dwSize;
    uint dwProcessorArchitecture;
    uint dwThreadID;
    uint dwReserved0;
    ulong lpExceptionAddress;
    ulong lpExceptionRecord;
    ulong lpContextRecord;
};

struct MEMORYSTATUS {
public:
    uint dwLength;
    uint dwMemoryLoad;
    ulong dwTotalPhys;
    ulong dwAvailPhys;
    ulong dwTotalPageFile;
    ulong dwAvailPageFile;
    ulong dwTotalVirtual;
    ulong dwAvailVirtual;
};

struct OFSTRUCT {
public:
    uchar cBytes;
    uchar fFixedDisk;
    ushort nErrCode;
    ushort Reserved1;
    ushort Reserved2;
    char szPathName;
};

struct OPERATION_END_PARAMETERS {
public:
    uint Version;
    uint OperationId;
    uint Flags;
};

struct OPERATION_START_PARAMETERS {
public:
    uint Version;
    uint OperationId;
    uint Flags;
};

struct SYSTEM_POWER_STATUS {
public:
    uchar ACLineStatus;
    uchar BatteryFlag;
    uchar BatteryLifePercent;
    uchar SystemStatusFlag;
    uint BatteryLifeTime;
    uint BatteryFullLifeTime;
};

struct UMS_SCHEDULER_STARTUP_INFO {
public:
    uint UmsVersion;
    PVOID CompletionList;
    PVOID SchedulerProc;
    PVOID SchedulerParam;
};

struct WIN32_STREAM_ID {
public:
    uint dwStreamId;
    uint dwStreamAttributes;
    long Size;
    uint dwStreamNameSize;
};

struct UMS_SYSTEM_THREAD_INFORMATION {
public:
    uint UmsVersion;
    uint ThreadUmsFlags;
};

struct FILE_ID_DESCRIPTOR {
public:
    uint dwSize;
    FILE_ID_TYPE Type;
    long FileId;
};

struct SYSTEMTIME {
public:
    ushort wYear;
    ushort wMonth;
    ushort wDayOfWeek;
    ushort wDay;
    ushort wHour;
    ushort wMinute;
    ushort wSecond;
    ushort wMilliseconds;
};

struct REASON_CONTEXT {
public:
    uint Version;
    uint Flags;
    PVOID Reason;
};

struct OVERLAPPED {
public:
    PVOID Internal;
    PVOID InternalHigh;
    uint Offset;
    uint OffsetHigh;
    HANDLE hEvent;
};

struct LDT_ENTRY {
public:
    ushort LimitLow;
    ushort BaseLow;
    uchar BaseMid;
    uchar Flags1;
    uchar Flags2;
    uchar BaseHi;
};

struct GUID {
public:
    ulong Data1;
    ushort Data2;
    ushort Data3;
    uchar Data4;
};

struct FILETIME {
public:
    uint dwLowDateTime;
    uint dwHighDateTime;
};

struct POINT {
public:
    int x;
    int y;
};

struct POINTL {
public:
    int x;
    int y;
};

struct POINTS {
public:
    short x;
    short y;
};

struct RECT {
public:
    int left;
    int top;
    int right;
    int bottom;
};

struct RECTL {
public:
    int left;
    int top;
    int right;
    int bottom;
};

struct SIZE {
public:
    int cx;
    int cy;
};

struct CLAIM_SECURITY_ATTRIBUTE_V1 {
public:
    PVOID Name;
    ushort ValueType;
    ushort Reserved;
    uint Flags;
    uint ValueCount;
    PVOID Values;
};

struct CLAIM_SECURITY_ATTRIBUTES_INFORMATION {
public:
    ushort Version;
    ushort Reserved;
    uint AttributeCount;
    PVOID Attribute;
};

struct ABC {
public:
    int abcA;
    uint abcB;
    int abcC;
};

struct ABCFLOAT {
public:
    float abcfA;
    float abcfB;
    float abcfC;
};

struct AXISINFOW {
public:
    int axMinValue;
    int axMaxValue;
    short axAxisName;
};

struct AXESLISTW {
public:
    uint axlReserved;
    uint axlNumAxes;
    AXISINFOW axlAxisInfo;
};

struct BITMAP {
public:
    int bmType;
    int bmWidth;
    int bmHeight;
    int bmWidthBytes;
    ushort bmPlanes;
    ushort bmBitsPixel;
    PVOID bmBits;
};

struct BITMAPCOREHEADER {
public:
    uint bcSize;
    ushort bcWidth;
    ushort bcHeight;
    ushort bcPlanes;
    ushort bcBitCount;
};

struct RGBTRIPLE {
public:
    uchar rgbtBlue;
    uchar rgbtGreen;
    uchar rgbtRed;
};

struct BITMAPCOREINFO {
public:
    BITMAPCOREHEADER bmciHeader;
    RGBTRIPLE bmciColors;
};

struct RGBQUAD {
public:
    uchar rgbBlue;
    uchar rgbGreen;
    uchar rgbRed;
    uchar rgbReserved;
};

struct BITMAPINFO {
public:
    BITMAPINFOHEADER bmiHeader;
    RGBQUAD bmiColors;
};

struct CIEXYZ {
public:
    int ciexyzX;
    int ciexyzY;
    int ciexyzZ;
};

struct CIEXYZTRIPLE {
public:
    CIEXYZ ciexyzRed;
    CIEXYZ ciexyzGreen;
    CIEXYZ ciexyzBlue;
};

struct BITMAPV4HEADER {
public:
    uint bV4Size;
    int bV4Width;
    int bV4Height;
    ushort bV4Planes;
    ushort bV4BitCount;
    uint bV4V4Compression;
    uint bV4SizeImage;
    int bV4XPelsPerMeter;
    int bV4YPelsPerMeter;
    uint bV4ClrUsed;
    uint bV4ClrImportant;
    uint bV4RedMask;
    uint bV4GreenMask;
    uint bV4BlueMask;
    uint bV4AlphaMask;
    uint bV4CSType;
    CIEXYZTRIPLE bV4Endpoints;
    uint bV4GammaRed;
    uint bV4GammaGreen;
    uint bV4GammaBlue;
};

struct BITMAPV5HEADER {
public:
    uint bV5Size;
    int bV5Width;
    int bV5Height;
    ushort bV5Planes;
    ushort bV5BitCount;
    uint bV5Compression;
    uint bV5SizeImage;
    int bV5XPelsPerMeter;
    int bV5YPelsPerMeter;
    uint bV5ClrUsed;
    uint bV5ClrImportant;
    uint bV5RedMask;
    uint bV5GreenMask;
    uint bV5BlueMask;
    uint bV5AlphaMask;
    uint bV5CSType;
    CIEXYZTRIPLE bV5Endpoints;
    uint bV5GammaRed;
    uint bV5GammaGreen;
    uint bV5GammaBlue;
    uint bV5Intent;
    uint bV5ProfileData;
    uint bV5ProfileSize;
    uint bV5Reserved;
};

struct BLENDFUNCTION {
public:
    uchar BlendOp;
    uchar BlendFlags;
    uchar SourceConstantAlpha;
    uchar AlphaFormat;
};

struct FONTSIGNATURE {
public:
    uint fsUsb;
    uint fsCsb;
};

struct CHARSETINFO {
public:
    uint ciCharset;
    uint ciACP;
    FONTSIGNATURE fs;
};

struct COLORADJUSTMENT {
public:
    ushort caSize;
    ushort caFlags;
    ushort caIlluminantIndex;
    ushort caRedGamma;
    ushort caGreenGamma;
    ushort caBlueGamma;
    ushort caReferenceBlack;
    ushort caReferenceWhite;
    short caContrast;
    short caBrightness;
    short caColorfulness;
    short caRedGreenTint;
};

struct DESIGNVECTOR {
public:
    uint dvReserved;
    uint dvNumAxes;
    int dvValues;
};

struct DIBSECTION {
public:
    BITMAP dsBm;
    BITMAPINFOHEADER dsBmih;
    uint dsBitfields;
    HANDLE dshSection;
    uint dsOffset;
};

struct DISPLAY_DEVICEA {
public:
    uint cb;
    char DeviceName;
    char DeviceString;
    uint StateFlags;
    char DeviceID;
    char DeviceKey;
};

struct DISPLAY_DEVICEW {
public:
    uint cb;
    short DeviceName;
    short DeviceString;
    uint StateFlags;
    short DeviceID;
    short DeviceKey;
};

struct DISPLAYCONFIG_2DREGION {
public:
    uint cx;
    uint cy;
};

struct DISPLAYCONFIG_DEVICE_INFO_HEADER {
public:
    DISPLAYCONFIG_DEVICE_INFO_TYPE type;
    uint size;
    LUID adapterId;
    uint id;
};

struct DISPLAYCONFIG_ADAPTER_NAME {
public:
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    short adapterDevicePath;
};

struct DISPLAYCONFIG_DESKTOP_IMAGE_INFO {
public:
    POINTL PathSourceSize;
    RECTL DesktopImageRegion;
    RECTL DesktopImageClip;
};

struct DISPLAYCONFIG_PATH_SOURCE_INFO {
public:
    LUID adapterId;
    uint id;
    uint modeInfoIdx;
    uint statusFlags;
};

struct DISPLAYCONFIG_RATIONAL {
public:
    uint Numerator;
    uint Denominator;
};

struct DISPLAYCONFIG_PATH_TARGET_INFO {
public:
    LUID adapterId;
    uint id;
    uint modeInfoIdx;
    DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY outputTechnology;
    DISPLAYCONFIG_ROTATION rotation;
    DISPLAYCONFIG_SCALING scaling;
    DISPLAYCONFIG_RATIONAL refreshRate;
    DISPLAYCONFIG_SCANLINE_ORDERING scanLineOrdering;
    int targetAvailable;
    uint statusFlags;
};

struct DISPLAYCONFIG_PATH_INFO {
public:
    DISPLAYCONFIG_PATH_SOURCE_INFO sourceInfo;
    DISPLAYCONFIG_PATH_TARGET_INFO targetInfo;
    uint flags;
};

struct DISPLAYCONFIG_SDR_WHITE_LEVEL {
public:
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    uint SDRWhiteLevel;
};

struct DISPLAYCONFIG_SOURCE_DEVICE_NAME {
public:
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    short viewGdiDeviceName;
};

struct DISPLAYCONFIG_SOURCE_MODE {
public:
    uint width;
    uint height;
    DISPLAYCONFIG_PIXELFORMAT pixelFormat;
    POINTL position;
};

struct DISPLAYCONFIG_TARGET_BASE_TYPE {
public:
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY baseOutputTechnology;
};

struct DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS {
public:
    uint value;
};

struct DISPLAYCONFIG_TARGET_DEVICE_NAME {
public:
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS flags;
    DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY outputTechnology;
    ushort edidManufactureId;
    ushort edidProductCodeId;
    uint connectorInstance;
    short monitorFriendlyDeviceName;
    short monitorDevicePath;
};

struct DISPLAYCONFIG_VIDEO_SIGNAL_INFO {
public:
    ulong pixelRate;
    DISPLAYCONFIG_RATIONAL hSyncFreq;
    DISPLAYCONFIG_RATIONAL vSyncFreq;
    DISPLAYCONFIG_2DREGION activeSize;
    DISPLAYCONFIG_2DREGION totalSize;
    uint videoStandard;
    DISPLAYCONFIG_SCANLINE_ORDERING scanLineOrdering;
};

struct DISPLAYCONFIG_TARGET_MODE {
public:
    DISPLAYCONFIG_VIDEO_SIGNAL_INFO targetVideoSignalInfo;
};

struct DISPLAYCONFIG_TARGET_PREFERRED_MODE {
public:
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    uint width;
    uint height;
    DISPLAYCONFIG_TARGET_MODE targetMode;
};

struct DOCINFOW {
public:
    int cbSize;
    const string lpszDocName;
    const string lpszOutput;
    const string lpszDatatype;
    uint fwType;
};

struct DRAWPATRECT {
public:
    POINT ptPosition;
    POINT ptSize;
    ushort wStyle;
    ushort wPattern;
};

struct EMR {
public:
    uint iType;
    uint nSize;
};

struct EMRABORTPATH {
public:
    EMR emr;
};

struct XFORM {
public:
    float eM11;
    float eM12;
    float eM21;
    float eM22;
    float eDx;
    float eDy;
};

struct EMRALPHABLEND {
public:
    EMR emr;
    RECTL rclBounds;
    int xDest;
    int yDest;
    int cxDest;
    int cyDest;
    uint dwRop;
    int xSrc;
    int ySrc;
    XFORM xformSrc;
    uint crBkColorSrc;
    uint iUsageSrc;
    uint offBmiSrc;
    uint cbBmiSrc;
    uint offBitsSrc;
    uint cbBitsSrc;
    int cxSrc;
    int cySrc;
};

struct EMRANGLEARC {
public:
    EMR emr;
    POINTL ptlCenter;
    uint nRadius;
    float eStartAngle;
    float eSweepAngle;
};

struct EMRARC {
public:
    EMR emr;
    RECTL rclBox;
    POINTL ptlStart;
    POINTL ptlEnd;
};

struct EMRBITBLT {
public:
    EMR emr;
    RECTL rclBounds;
    int xDest;
    int yDest;
    int cxDest;
    int cyDest;
    uint dwRop;
    int xSrc;
    int ySrc;
    XFORM xformSrc;
    uint crBkColorSrc;
    uint iUsageSrc;
    uint offBmiSrc;
    uint cbBmiSrc;
    uint offBitsSrc;
    uint cbBitsSrc;
};

struct EMRCOLORCORRECTPALETTE {
public:
    EMR emr;
    uint ihPalette;
    uint nFirstEntry;
    uint nPalEntries;
    uint nReserved;
};

struct EMRCOLORMATCHTOTARGET {
public:
    EMR emr;
    uint dwAction;
    uint dwFlags;
    uint cbName;
    uint cbData;
    uchar Data;
};

struct LOGBRUSH {
public:
    uint lbStyle;
    uint lbColor;
    ulong lbHatch;
};

struct EMRCREATEBRUSHINDIRECT {
public:
    EMR emr;
    uint ihBrush;
    LOGBRUSH lb;
};

struct LOGCOLORSPACEW {
public:
    uint lcsSignature;
    uint lcsVersion;
    uint lcsSize;
    int lcsCSType;
    int lcsIntent;
    CIEXYZTRIPLE lcsEndpoints;
    uint lcsGammaRed;
    uint lcsGammaGreen;
    uint lcsGammaBlue;
    short lcsFilename;
};

struct EMRCREATECOLORSPACEW {
public:
    EMR emr;
    uint ihCS;
    LOGCOLORSPACEW lcs;
    uint dwFlags;
    uint cbData;
    uchar Data;
};

struct EMRCREATEDIBPATTERNBRUSHPT {
public:
    EMR emr;
    uint ihBrush;
    uint iUsage;
    uint offBmi;
    uint cbBmi;
    uint offBits;
    uint cbBits;
};

struct EMRCREATEMONOBRUSH {
public:
    EMR emr;
    uint ihBrush;
    uint iUsage;
    uint offBmi;
    uint cbBmi;
    uint offBits;
    uint cbBits;
};

struct LOGPALETTE {
public:
    ushort palVersion;
    ushort palNumEntries;
};

struct LOGPEN {
public:
    uint lopnStyle;
    POINT lopnWidth;
    uint lopnColor;
};

struct EMRCREATEPALETTE {
public:
    EMR emr;
    uint ihPal;
    LOGPALETTE lgpl;
};

struct EMRCREATEPEN {
public:
    EMR emr;
    uint ihPen;
    LOGPEN lopn;
};

struct EMRELLIPSE {
public:
    EMR emr;
    RECTL rclBox;
};

struct EMREOF {
public:
    EMR emr;
    uint nPalEntries;
    uint offPalEntries;
    uint nSizeLast;
};

struct EMREXCLUDECLIPRECT {
public:
    EMR emr;
    RECTL rclClip;
};

struct LOGFONTW {
public:
    int lfHeight;
    int lfWidth;
    int lfEscapement;
    int lfOrientation;
    int lfWeight;
    uchar lfItalic;
    uchar lfUnderline;
    uchar lfStrikeOut;
    uchar lfCharSet;
    uchar lfOutPrecision;
    uchar lfClipPrecision;
    uchar lfQuality;
    uchar lfPitchAndFamily;
    short lfFaceName;
};

struct PANOSE {
public:
    uchar bFamilyType;
    uchar bSerifStyle;
    uchar bWeight;
    uchar bProportion;
    uchar bContrast;
    uchar bStrokeVariation;
    uchar bArmStyle;
    uchar bLetterform;
    uchar bMidline;
    uchar bXHeight;
};

struct EXTLOGFONTW {
public:
    LOGFONTW elfLogFont;
    short elfFullName;
    short elfStyle;
    uint elfVersion;
    uint elfStyleSize;
    uint elfMatch;
    uint elfReserved;
    uchar elfVendorId;
    uint elfCulture;
    PANOSE elfPanose;
};

struct EMREXTCREATEFONTINDIRECTW {
public:
    EMR emr;
    uint ihFont;
    EXTLOGFONTW elfw;
};

struct EXTLOGPEN {
public:
    uint elpPenStyle;
    uint elpWidth;
    uint elpBrushStyle;
    uint elpColor;
    ulong elpHatch;
    uint elpNumEntries;
    uint elpStyleEntry;
};

struct EMREXTCREATEPEN {
public:
    EMR emr;
    uint ihPen;
    uint offBmi;
    uint cbBmi;
    uint offBits;
    uint cbBits;
    EXTLOGPEN elp;
};

struct EMREXTESCAPE {
public:
    EMR emr;
    int iEscape;
    int cbEscData;
    uchar EscData;
};

struct EMREXTFLOODFILL {
public:
    EMR emr;
    POINTL ptlStart;
    uint crColor;
    uint iMode;
};

struct EMREXTSELECTCLIPRGN {
public:
    EMR emr;
    uint cbRgnData;
    uint iMode;
    uchar RgnData;
};

struct EMRTEXT {
public:
    POINTL ptlReference;
    uint nChars;
    uint offString;
    uint fOptions;
    RECTL rcl;
    uint offDx;
};

struct EMREXTTEXTOUTA {
public:
    EMR emr;
    RECTL rclBounds;
    uint iGraphicsMode;
    float exScale;
    float eyScale;
    EMRTEXT emrtext;
};

struct EMRFILLPATH {
public:
    EMR emr;
    RECTL rclBounds;
};

struct EMRFILLRGN {
public:
    EMR emr;
    RECTL rclBounds;
    uint cbRgnData;
    uint ihBrush;
    uchar RgnData;
};

struct EMRFORMAT {
public:
    uint dSignature;
    uint nVersion;
    uint cbData;
    uint offData;
};

struct EMRFRAMERGN {
public:
    EMR emr;
    RECTL rclBounds;
    uint cbRgnData;
    uint ihBrush;
    SIZE szlStroke;
    uchar RgnData;
};

struct EMRGDICOMMENT {
public:
    EMR emr;
    uint cbData;
    uchar Data;
};

struct EMRGLSBOUNDEDRECORD {
public:
    EMR emr;
    RECTL rclBounds;
    uint cbData;
    uchar Data;
};

struct EMRGLSRECORD {
public:
    EMR emr;
    uint cbData;
    uchar Data;
};

struct PIXELFORMATDESCRIPTOR {
public:
    ushort nSize;
    ushort nVersion;
    uint dwFlags;
    uchar iPixelType;
    uchar cColorBits;
    uchar cRedBits;
    uchar cRedShift;
    uchar cGreenBits;
    uchar cGreenShift;
    uchar cBlueBits;
    uchar cBlueShift;
    uchar cAlphaBits;
    uchar cAlphaShift;
    uchar cAccumBits;
    uchar cAccumRedBits;
    uchar cAccumGreenBits;
    uchar cAccumBlueBits;
    uchar cAccumAlphaBits;
    uchar cDepthBits;
    uchar cStencilBits;
    uchar cAuxBuffers;
    uchar iLayerType;
    uchar bReserved;
    uint dwLayerMask;
    uint dwVisibleMask;
    uint dwDamageMask;
};

struct TRIVERTEX {
public:
    int x;
    int y;
    ushort red;
    ushort green;
    ushort blue;
    ushort alpha;
};

struct EMRGRADIENTFILL {
public:
    EMR emr;
    RECTL rclBounds;
    uint nVer;
    uint nTri;
    uint ulMode;
    TRIVERTEX Ver;
};

struct EMRINVERTRGN {
public:
    EMR emr;
    RECTL rclBounds;
    uint cbRgnData;
    uchar RgnData;
};

struct EMRLINETO {
public:
    EMR emr;
    POINTL ptl;
};

struct EMRMASKBLT {
public:
    EMR emr;
    RECTL rclBounds;
    int xDest;
    int yDest;
    int cxDest;
    int cyDest;
    uint dwRop;
    int xSrc;
    int ySrc;
    XFORM xformSrc;
    uint crBkColorSrc;
    uint iUsageSrc;
    uint offBmiSrc;
    uint cbBmiSrc;
    uint offBitsSrc;
    uint cbBitsSrc;
    int xMask;
    int yMask;
    uint iUsageMask;
    uint offBmiMask;
    uint cbBmiMask;
    uint offBitsMask;
    uint cbBitsMask;
};

struct EMRMODIFYWORLDTRANSFORM {
public:
    EMR emr;
    XFORM xform;
    uint iMode;
};

struct EMRNAMEDESCAPE {
public:
    EMR emr;
    int iEscape;
    int cbDriver;
    int cbEscData;
    uchar EscData;
};

struct EMROFFSETCLIPRGN {
public:
    EMR emr;
    POINTL ptlOffset;
};

struct EMRPIXELFORMAT {
public:
    EMR emr;
    PIXELFORMATDESCRIPTOR pfd;
};

struct EMRPLGBLT {
public:
    EMR emr;
    RECTL rclBounds;
    POINTL aptlDest;
    int xSrc;
    int ySrc;
    int cxSrc;
    int cySrc;
    XFORM xformSrc;
    uint crBkColorSrc;
    uint iUsageSrc;
    uint offBmiSrc;
    uint cbBmiSrc;
    uint offBitsSrc;
    uint cbBitsSrc;
    int xMask;
    int yMask;
    uint iUsageMask;
    uint offBmiMask;
    uint cbBmiMask;
    uint offBitsMask;
    uint cbBitsMask;
};

struct EMRPOLYDRAW {
public:
    EMR emr;
    RECTL rclBounds;
    uint cptl;
    POINTL aptl;
    uchar abTypes;
};

struct EMRPOLYDRAW16 {
public:
    EMR emr;
    RECTL rclBounds;
    uint cpts;
    POINTS apts;
    uchar abTypes;
};

struct EMRPOLYLINE {
public:
    EMR emr;
    RECTL rclBounds;
    uint cptl;
    POINTL aptl;
};

struct EMRPOLYLINE16 {
public:
    EMR emr;
    RECTL rclBounds;
    uint cpts;
    POINTS apts;
};

struct EMRPOLYPOLYLINE {
public:
    EMR emr;
    RECTL rclBounds;
    uint nPolys;
    uint cptl;
    uint aPolyCounts;
    POINTL aptl;
};

struct EMRPOLYPOLYLINE16 {
public:
    EMR emr;
    RECTL rclBounds;
    uint nPolys;
    uint cpts;
    uint aPolyCounts;
    POINTS apts;
};

struct EMRPOLYTEXTOUTW {
public:
    EMR emr;
    RECTL rclBounds;
    uint iGraphicsMode;
    float exScale;
    float eyScale;
    int cStrings;
    EMRTEXT aemrtext;
};

struct EMRRESIZEPALETTE {
public:
    EMR emr;
    uint ihPal;
    uint cEntries;
};

struct EMRRESTOREDC {
public:
    EMR emr;
    int iRelative;
};

struct EMRROUNDRECT {
public:
    EMR emr;
    RECTL rclBox;
    SIZE szlCorner;
};

struct EMRSCALEVIEWPORTEXTEX {
public:
    EMR emr;
    int xNum;
    int xDenom;
    int yNum;
    int yDenom;
};

struct EMRSELECTCLIPPATH {
public:
    EMR emr;
    uint iMode;
};

struct EMRSELECTOBJECT {
public:
    EMR emr;
    uint ihObject;
};

struct EMRSELECTPALETTE {
public:
    EMR emr;
    uint ihPal;
};

struct EMRSETARCDIRECTION {
public:
    EMR emr;
    uint iArcDirection;
};

struct EMRSETBKCOLOR {
public:
    EMR emr;
    uint crColor;
};

struct EMRSETCOLORADJUSTMENT {
public:
    EMR emr;
    COLORADJUSTMENT ColorAdjustment;
};

struct EMRSETCOLORSPACE {
public:
    EMR emr;
    uint ihCS;
};

struct EMRSETDIBITSTODEVICE {
public:
    EMR emr;
    RECTL rclBounds;
    int xDest;
    int yDest;
    int xSrc;
    int ySrc;
    int cxSrc;
    int cySrc;
    uint offBmiSrc;
    uint cbBmiSrc;
    uint offBitsSrc;
    uint cbBitsSrc;
    uint iUsageSrc;
    uint iStartScan;
    uint cScans;
};

struct EMRSETICMPROFILE {
public:
    EMR emr;
    uint dwFlags;
    uint cbName;
    uint cbData;
    uchar Data;
};

struct EMRSETMAPPERFLAGS {
public:
    EMR emr;
    uint dwFlags;
};

struct EMRSETMITERLIMIT {
public:
    EMR emr;
    float eMiterLimit;
};

struct PALETTEENTRY {
public:
    uchar red;
    uchar green;
    uchar blue;
    uchar flags;
};

struct EMRSETPALETTEENTRIES {
public:
    EMR emr;
    uint ihPal;
    uint iStart;
    uint cEntries;
    PALETTEENTRY aPalEntries;
};

struct EMRSETPIXELV {
public:
    EMR emr;
    POINTL ptlPixel;
    uint crColor;
};

struct EMRSETVIEWPORTEXTEX {
public:
    EMR emr;
    SIZE szlExtent;
};

struct EMRSETVIEWPORTORGEX {
public:
    EMR emr;
    POINTL ptlOrigin;
};

struct EMRSETWORLDTRANSFORM {
public:
    EMR emr;
    XFORM xform;
};

struct EMRSTRETCHBLT {
public:
    EMR emr;
    RECTL rclBounds;
    int xDest;
    int yDest;
    int cxDest;
    int cyDest;
    uint dwRop;
    int xSrc;
    int ySrc;
    XFORM xformSrc;
    uint crBkColorSrc;
    uint iUsageSrc;
    uint offBmiSrc;
    uint cbBmiSrc;
    uint offBitsSrc;
    uint cbBitsSrc;
    int cxSrc;
    int cySrc;
};

struct EMRSTRETCHDIBITS {
public:
    EMR emr;
    RECTL rclBounds;
    int xDest;
    int yDest;
    int xSrc;
    int ySrc;
    int cxSrc;
    int cySrc;
    uint offBmiSrc;
    uint cbBmiSrc;
    uint offBitsSrc;
    uint cbBitsSrc;
    uint iUsageSrc;
    uint dwRop;
    int cxDest;
    int cyDest;
};

struct EMRTRANSPARENTBLT {
public:
    EMR emr;
    RECTL rclBounds;
    int xDest;
    int yDest;
    int cxDest;
    int cyDest;
    uint dwRop;
    int xSrc;
    int ySrc;
    XFORM xformSrc;
    uint crBkColorSrc;
    uint iUsageSrc;
    uint offBmiSrc;
    uint cbBmiSrc;
    uint offBitsSrc;
    uint cbBitsSrc;
    int cxSrc;
    int cySrc;
};

struct ENHMETAHEADER {
public:
    uint iType;
    uint nSize;
    RECTL rclBounds;
    RECTL rclFrame;
    uint dSignature;
    uint nVersion;
    uint nBytes;
    uint nRecords;
    ushort nHandles;
    ushort sReserved;
    uint nDescription;
    uint offDescription;
    uint nPalEntries;
    SIZE szlDevice;
    SIZE szlMillimeters;
    uint cbPixelFormat;
    uint offPixelFormat;
    uint bOpenGL;
    SIZE szlMicrometers;
};

struct ENHMETARECORD {
public:
    uint iType;
    uint nSize;
    uint dParm;
};

struct ENUMLOGFONTEXW {
public:
    LOGFONTW elfLogFont;
    short elfFullName;
    short elfStyle;
    short elfScript;
};

struct ENUMLOGFONTEXDVW {
public:
    ENUMLOGFONTEXW elfEnumLogfontEx;
    DESIGNVECTOR elfDesignVector;
};

struct ENUMLOGFONTW {
public:
    LOGFONTW elfLogFont;
    short elfFullName;
    short elfStyle;
};

struct NEWTEXTMETRICW {
public:
    int tmHeight;
    int tmAscent;
    int tmDescent;
    int tmInternalLeading;
    int tmExternalLeading;
    int tmAveCharWidth;
    int tmMaxCharWidth;
    int tmWeight;
    int tmOverhang;
    int tmDigitizedAspectX;
    int tmDigitizedAspectY;
    short tmFirstChar;
    short tmLastChar;
    short tmDefaultChar;
    short tmBreakChar;
    uchar tmItalic;
    uchar tmUnderlined;
    uchar tmStruckOut;
    uchar tmPitchAndFamily;
    uchar tmCharSet;
    uint ntmFlags;
    uint ntmSizeEM;
    uint ntmCellHeight;
    uint ntmAvgWidth;
};

struct NEWTEXTMETRICEXW {
public:
    NEWTEXTMETRICW ntmTm;
    FONTSIGNATURE ntmFontSig;
};

struct ENUMTEXTMETRICW {
public:
    NEWTEXTMETRICEXW etmNewTextMetricEx;
    AXESLISTW etmAxesList;
};

struct FIXED {
public:
    ushort fract;
    short value;
};

struct POINTFLOAT {
public:
    float x;
    float y;
};

struct GCP_RESULTSW {
public:
    uint lStructSize;
    string lpOutString;
    PVOID lpOrder;
    PVOID lpDx;
    PVOID lpCaretPos;
    PVOID lpClass;
    PVOID lpGlyphs;
    uint nGlyphs;
    int nMaxFit;
};

struct GLYPHMETRICS {
public:
    uint gmBlackBoxX;
    uint gmBlackBoxY;
    POINT gmptGlyphOrigin;
    short gmCellIncX;
    short gmCellIncY;
};

struct GLYPHMETRICSFLOAT {
public:
    float gmfBlackBoxX;
    float gmfBlackBoxY;
    POINTFLOAT gmfptGlyphOrigin;
    float gmfCellIncX;
    float gmfCellIncY;
};

struct WCRANGE {
public:
    short wcLow;
    ushort cGlyphs;
};

struct GLYPHSET {
public:
    uint cbThis;
    uint flAccel;
    uint cGlyphsSupported;
    uint cRanges;
    WCRANGE ranges;
};

struct GRADIENT_RECT {
public:
    uint UpperLeft;
    uint LowerRight;
};

struct GRADIENT_TRIANGLE {
public:
    uint Vertex1;
    uint Vertex2;
    uint Vertex3;
};

struct HANDLETABLE {
public:
    PVOID objectHandle;
};

struct KERNINGPAIR {
public:
    ushort wFirst;
    ushort wSecond;
    int iKernAmount;
};

struct LAYERPLANEDESCRIPTOR {
public:
    ushort nSize;
    ushort nVersion;
    uint dwFlags;
    uchar iPixelType;
    uchar cColorBits;
    uchar cRedBits;
    uchar cRedShift;
    uchar cGreenBits;
    uchar cGreenShift;
    uchar cBlueBits;
    uchar cBlueShift;
    uchar cAlphaBits;
    uchar cAlphaShift;
    uchar cAccumBits;
    uchar cAccumRedBits;
    uchar cAccumGreenBits;
    uchar cAccumBlueBits;
    uchar cAccumAlphaBits;
    uchar cDepthBits;
    uchar cStencilBits;
    uchar cAuxBuffers;
    uchar iLayerPlane;
    uchar bReserved;
    uint crTransparent;
};

struct LOCALESIGNATURE {
public:
    uint lsUsb;
    uint lsCsbDefault;
    uint lsCsbSupported;
};

struct MAT2 {
public:
    FIXED eM11;
    FIXED eM12;
    FIXED eM21;
    FIXED eM22;
};

struct METAFILEPICT {
public:
    int mm;
    int xExt;
    int yExt;
    HANDLE hMF;
};

struct METAHEADER {
public:
    ushort mtType;
    ushort mtHeaderSize;
    ushort mtVersion;
    uint mtSize;
    ushort mtNoObjects;
    uint mtMaxRecord;
    ushort mtNoParameters;
};

struct METARECORD {
public:
    uint rdSize;
    ushort rdFunction;
    ushort rdParm;
};

struct TEXTMETRICW {
public:
    int tmHeight;
    int tmAscent;
    int tmDescent;
    int tmInternalLeading;
    int tmExternalLeading;
    int tmAveCharWidth;
    int tmMaxCharWidth;
    int tmWeight;
    int tmOverhang;
    int tmDigitizedAspectX;
    int tmDigitizedAspectY;
    short tmFirstChar;
    short tmLastChar;
    short tmDefaultChar;
    short tmBreakChar;
    uchar tmItalic;
    uchar tmUnderlined;
    uchar tmStruckOut;
    uchar tmPitchAndFamily;
    uchar tmCharSet;
};

struct OUTLINETEXTMETRICW {
public:
    uint otmSize;
    TEXTMETRICW otmTextMetrics;
    uchar otmFiller;
    PANOSE otmPanoseNumber;
    uint otmfsSelection;
    uint otmfsType;
    int otmsCharSlopeRise;
    int otmsCharSlopeRun;
    int otmItalicAngle;
    uint otmEMSquare;
    int otmAscent;
    int otmDescent;
    uint otmLineGap;
    uint otmsCapEmHeight;
    uint otmsXHeight;
    RECT otmrcFontBox;
    int otmMacAscent;
    int otmMacDescent;
    uint otmMacLineGap;
    uint otmusMinimumPPEM;
    POINT otmptSubscriptSize;
    POINT otmptSubscriptOffset;
    POINT otmptSuperscriptSize;
    POINT otmptSuperscriptOffset;
    uint otmsStrikeoutSize;
    int otmsStrikeoutPosition;
    int otmsUnderscoreSize;
    int otmsUnderscorePosition;
    PVOID otmpFamilyName;
    PVOID otmpFaceName;
    PVOID otmpStyleName;
    PVOID otmpFullName;
};

struct PELARRAY {
public:
    int paXCount;
    int paYCount;
    int paXExt;
    int paYExt;
    uchar paRGBs;
};

struct POINTFX {
public:
    FIXED x;
    FIXED y;
};

struct POLYTEXTW {
public:
    int x;
    int y;
    uint n;
    const string lpstr;
    uint uiFlags;
    RECT rcl;
    PVOID pdx;
};

struct PSFEATURE_CUSTPAPER {
public:
    int lOrientation;
    int lWidth;
    int lHeight;
    int lWidthOffset;
    int lHeightOffset;
};

struct PSFEATURE_OUTPUT {
public:
    int bPageIndependent;
    int bSetPageDevice;
};

struct PSINJECTDATA {
public:
    uint DataBytes;
    ushort InjectionPoint;
    ushort PageNumber;
};

struct RASTERIZER_STATUS {
public:
    short nSize;
    short wFlags;
    short nLanguageID;
};

struct RGNDATAHEADER {
public:
    uint dwSize;
    uint iType;
    uint nCount;
    uint nRgnSize;
    RECT rcBound;
};

struct RGNDATA {
public:
    RGNDATAHEADER rdh;
    char Buffer;
};

struct TTPOLYCURVE {
public:
    ushort wType;
    ushort cpfx;
    POINTFX apfx;
};

struct TTPOLYGONHEADER {
public:
    uint cb;
    uint dwType;
    POINTFX pfxStart;
};

struct DEVMODEW {
public:
    short dmDeviceName;
    ushort dmSpecVersion;
    ushort dmDriverVersion;
    ushort dmSize;
    ushort dmDriverExtra;
    uint dmFields;
    short dmOrientation;
    short dmPaperSize;
    short dmPaperLength;
    short dmPaperWidth;
    short dmScale;
    short dmCopies;
    short dmDefaultSource;
    short dmPrintQuality;
    short dmColor;
    short dmDuplex;
    short dmYResolution;
    short dmTTOption;
    short dmCollate;
    short dmFormName;
    ushort dmLogPixels;
    uint dmBitsPerPel;
    uint dmPelsWidth;
    uint dmPelsHeight;
    uint dmDisplayFlags;
    uint dmDisplayFrequency;
    uint dmICMMethod;
    uint dmICMIntent;
    uint dmMediaType;
    uint dmDitherType;
    uint dmReserved1;
    uint dmReserved2;
    uint dmPanningWidth;
    uint dmPanningHeight;
};

struct WGLSWAP {
public:
    HANDLE hdc;
    uint uiFlags;
};

struct DISPLAYCONFIG_MODE_INFO {
public:
    DISPLAYCONFIG_MODE_INFO_TYPE infoType;
    uint id;
    LUID adapterId;
    DISPLAYCONFIG_MODE mode;
};

struct PROCESSOR_NUMBER {
public:
    ushort Group;
    uchar Number;
    uchar Reserved;
};

struct GROUP_AFFINITY {
public:
    ulong Mask;
    ushort Group;
    ushort Reserved;
};

struct FLOAT128 {
public:
    long LowPart;
    long HighPart;
};

struct LARGE_INTEGER {
public:
    long QuadPart;
};

struct ULARGE_INTEGER {
public:
    ulong QuadPart;
};

struct LUID {
public:
    uint LowPart;
    int HighPart;
};

struct LIST_ENTRY {
public:
    PVOID Flink;
    PVOID Blink;
};

struct SINGLE_LIST_ENTRY {
public:
    PVOID Next;
};

struct LIST_ENTRY32 {
public:
    uint Flink;
    uint Blink;
};

struct LIST_ENTRY64 {
public:
    ulong Flink;
    ulong Blink;
};

struct OBJECTID {
public:
    GUID Lineage;
    uint Uniquifier;
};

struct M128A {
public:
    ulong Low;
    long High;
};

struct XSAVE_FORMAT {
public:
    ushort Controlushort;
    ushort Statusushort;
    uchar Tagushort;
    uchar Reserved1;
    ushort ErrorOpcode;
    uint ErrorOffset;
    ushort ErrorSelector;
    ushort Reserved2;
    uint DataOffset;
    ushort DataSelector;
    ushort Reserved3;
    uint MxCsr;
    uint MxCsr_Mask;
    M128A FloatRegisters;
    M128A XmmRegisters;
    uchar Reserved4;
};

struct XSAVE_AREA_HEADER {
public:
    ulong Mask;
    ulong CompactionMask;
    ulong Reserved2;
};

struct XSAVE_AREA {
public:
    XSAVE_FORMAT LegacyState;
    XSAVE_AREA_HEADER Header;
};

struct XSTATE_CONTEXT {
public:
    ulong Mask;
    uint Length;
    uint Reserved1;
    PVOID Area;
    uint Reserved2;
    PVOID Buffer;
    uint Reserved3;
};

struct SCOPE_TABLE_AMD64 {
public:
    uint Count;
    uint BeginAddress;
    uint EndAddress;
    uint HandlerAddress;
    uint JumpTarget;
};

struct UNWIND_HISTORY_TABLE_ENTRY {
public:
    ulong ImageBase;
    PVOID FunctionEntry;
};

struct UNWIND_HISTORY_TABLE {
public:
    uint Count;
    uchar LocalHint;
    uchar GlobalHint;
    uchar Search;
    uchar Once;
    ulong LowAddress;
    ulong HighAddress;
    UNWIND_HISTORY_TABLE_ENTRY Entry;
};

struct SCOPE_TABLE_ARM64 {
public:
    uint Count;
    uint BeginAddress;
    uint EndAddress;
    uint HandlerAddress;
    uint JumpTarget;
};

struct NEON128 {
public:
    ulong Low;
    long High;
};

struct DISPATCHER_CONTEXT {
public:
    uint ControlPc;
    uint ImageBase;
    PVOID FunctionEntry;
    uint EstablisherFrame;
    uint TargetPc;
    PVOID ContextRecord;
    PVOID LanguageHandler;
    PVOID HandlerData;
    PVOID HistoryTable;
    uint ScopeIndex;
    uchar ControlPcIsUnwound;
    PVOID NonVolatileRegisters;
    uint Reserved;
};

struct KNONVOLATILE_CONTEXT_POINTERS {
public:
    PVOID FloatingContext;
    PVOID IntegerContext;
};

struct SCOPE_TABLE_ARM {
public:
    uint Count;
    uint BeginAddress;
    uint EndAddress;
    uint HandlerAddress;
    uint JumpTarget;
};

struct DISPATCHER_CONTEXT_ARM64 {
public:
    ulong ControlPc;
    ulong ImageBase;
    PVOID FunctionEntry;
    ulong EstablisherFrame;
    ulong TargetPc;
    PVOID ContextRecord;
    PVOID LanguageHandler;
    PVOID HandlerData;
    PVOID HistoryTable;
    uint ScopeIndex;
    uchar ControlPcIsUnwound;
    PVOID NonVolatileRegisters;
};

struct KNONVOLATILE_CONTEXT_POINTERS_ARM64 {
public:
    PVOID X19;
    PVOID X20;
    PVOID X21;
    PVOID X22;
    PVOID X23;
    PVOID X24;
    PVOID X25;
    PVOID X26;
    PVOID X27;
    PVOID X28;
    PVOID Fp;
    PVOID Lr;
    PVOID D8;
    PVOID D9;
    PVOID D10;
    PVOID D11;
    PVOID D12;
    PVOID D13;
    PVOID D14;
    PVOID D15;
};

struct FLOATING_SAVE_AREA {
public:
    uint Controlushort;
    uint Statusushort;
    uint Tagushort;
    uint ErrorOffset;
    uint ErrorSelector;
    uint DataOffset;
    uint DataSelector;
    uchar RegisterArea;
    uint Spare0;
};

struct CONTEXT {
public:
    ulong P1Home;
    ulong P2Home;
    ulong P3Home;
    ulong P4Home;
    ulong P5Home;
    ulong P6Home;
    uint ContextFlags;
    uint MxCsr;
    ushort SegCs;
    ushort SegDs;
    ushort SegEs;
    ushort SegFs;
    ushort SegGs;
    ushort SegSs;
    uint EFlags;
    ulong Dr0;
    ulong Dr1;
    ulong Dr2;
    ulong Dr3;
    ulong Dr6;
    ulong Dr7;
    ulong Rax;
    ulong Rcx;
    ulong Rdx;
    ulong Rbx;
    ulong Rsp;
    ulong Rbp;
    ulong Rsi;
    ulong Rdi;
    ulong R8;
    ulong R9;
    ulong R10;
    ulong R11;
    ulong R12;
    ulong R13;
    ulong R14;
    ulong R15;
    ulong Rip;
    M128A Header;
    M128A Legacy;
    M128A Xmm0;
    M128A Xmm1;
    M128A Xmm2;
    M128A Xmm3;
    M128A Xmm4;
    M128A Xmm5;
    M128A Xmm6;
    M128A Xmm7;
    M128A Xmm8;
    M128A Xmm9;
    M128A Xmm10;
    M128A Xmm11;
    M128A Xmm12;
    M128A Xmm13;
    M128A Xmm14;
    M128A Xmm15;
    M128A VectorRegister;
    ulong VectorControl;
    ulong DebugControl;
    ulong LastBranchToRip;
    ulong LastBranchFromRip;
    ulong LastExceptionToRip;
    ulong LastExceptionFromRip;
};

struct WOW64_FLOATING_SAVE_AREA {
public:
    uint Controlushort;
    uint Statusushort;
    uint Tagushort;
    uint ErrorOffset;
    uint ErrorSelector;
    uint DataOffset;
    uint DataSelector;
    uchar RegisterArea;
    uint Cr0NpxState;
};

struct WOW64_CONTEXT {
public:
    uint ContextFlags;
    uint Dr0;
    uint Dr1;
    uint Dr2;
    uint Dr3;
    uint Dr6;
    uint Dr7;
    WOW64_FLOATING_SAVE_AREA FloatSave;
    uint SegGs;
    uint SegFs;
    uint SegEs;
    uint SegDs;
    uint Edi;
    uint Esi;
    uint Ebx;
    uint Edx;
    uint Ecx;
    uint Eax;
    uint Ebp;
    uint Eip;
    uint SegCs;
    uint EFlags;
    uint Esp;
    uint SegSs;
    uchar ExtendedRegisters;
};

struct WOW64_LDT_ENTRY {
public:
    uint LimitLow;
    uint BaseLow;
    uchar BaseMid;
    uchar Flags1;
    uchar Flags2;
    uchar BaseHi;
};

struct WOW64_DESCRIPTOR_TABLE_ENTRY {
public:
    uint Selector;
    WOW64_LDT_ENTRY Descriptor;
};

struct EXCEPTION_RECORD {
public:
    uint ExceptionCode;
    uint ExceptionFlags;
    PVOID ExceptionRecord;
    PVOID ExceptionAddress;
    uint NumberParameters;
    PVOID ExceptionInformation;
};

struct EXCEPTION_RECORD32 {
public:
    uint ExceptionCode;
    uint ExceptionFlags;
    uint ExceptionRecord;
    uint ExceptionAddress;
    uint NumberParameters;
    uint ExceptionInformation;
};

struct EXCEPTION_RECORD64 {
public:
    uint ExceptionCode;
    uint ExceptionFlags;
    ulong ExceptionRecord;
    ulong ExceptionAddress;
    uint NumberParameters;
    uint __unusedAlignment;
    ulong ExceptionInformation;
};

struct EXCEPTION_POINTERS {
public:
    PVOID ExceptionRecord;
    PVOID ContextRecord;
};

struct GENERIC_MAPPING {
public:
    uint GenericRead;
    uint GenericWrite;
    uint GenericExecute;
    uint GenericAll;
};

struct LUID_AND_ATTRIBUTES {
public:
    LUID Luid;
    uint Attributes;
};

struct SID_IDENTIFIER_AUTHORITY {
public:
    uchar Value;
};

struct SID {
public:
    uchar Revision;
    uchar SubAuthorityCount;
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
    uint SubAuthority;
};

struct SID_AND_ATTRIBUTES {
public:
    SID Sid;
    uint Attributes;
};

struct SID_AND_ATTRIBUTES_HASH {
public:
    uint SidCount;
    PVOID SidAttr;
    ulong Hash;
};

struct ACL {
public:
    uchar AclRevision;
    uchar Sbz1;
    ushort AclSize;
    ushort AceCount;
    ushort Sbz2;
};

struct ACE_HEADER {
public:
    uchar AceType;
    uchar AceFlags;
    ushort AceSize;
};

struct ACCESS_ALLOWED_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint SidStart;
};

struct ACCESS_DENIED_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint SidStart;
};

struct SYSTEM_AUDIT_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint SidStart;
};

struct SYSTEM_ALARM_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint SidStart;
};

struct SYSTEM_RESOURCE_ATTRIBUTE_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint SidStart;
};

struct SYSTEM_SCOPED_POLICY_ID_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint SidStart;
};

struct SYSTEM_MANDATORY_LABEL_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint SidStart;
};

struct SYSTEM_PROCESS_TRUST_LABEL_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint SidStart;
};

struct SYSTEM_ACCESS_FILTER_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint SidStart;
};

struct ACCESS_ALLOWED_OBJECT_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    uint SidStart;
};

struct ACCESS_DENIED_OBJECT_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    uint SidStart;
};

struct SYSTEM_AUDIT_OBJECT_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    uint SidStart;
};

struct SYSTEM_ALARM_OBJECT_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    uint SidStart;
};

struct ACCESS_ALLOWED_CALLBACK_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint SidStart;
};

struct ACCESS_DENIED_CALLBACK_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint SidStart;
};

struct SYSTEM_AUDIT_CALLBACK_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint SidStart;
};

struct SYSTEM_ALARM_CALLBACK_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint SidStart;
};

struct ACCESS_ALLOWED_CALLBACK_OBJECT_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    uint SidStart;
};

struct ACCESS_DENIED_CALLBACK_OBJECT_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    uint SidStart;
};

struct SYSTEM_AUDIT_CALLBACK_OBJECT_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    uint SidStart;
};

struct SYSTEM_ALARM_CALLBACK_OBJECT_ACE {
public:
    ACE_HEADER Header;
    uint Mask;
    uint Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    uint SidStart;
};

struct ACL_REVISION_INFORMATION {
public:
    uint AclRevision;
};

struct ACL_SIZE_INFORMATION {
public:
    uint AceCount;
    uint AclBytesInUse;
    uint AclBytesFree;
};

struct SECURITY_DESCRIPTOR_RELATIVE {
public:
    uchar Revision;
    uchar Sbz1;
    ushort Control;
    uint Owner;
    uint Group;
    uint Sacl;
    uint Dacl;
};

struct SECURITY_DESCRIPTOR {
public:
    uchar Revision;
    uchar Sbz1;
    ushort Control;
    uchar offset;
    PVOID Owner;
    PVOID Group;
    PVOID Sacl;
    PVOID Dacl;
};

struct SECURITY_OBJECT_AI_PARAMS {
public:
    uint Size;
    uint ConstraintMask;
};

struct OBJECT_TYPE_LIST {
public:
    ushort Level;
    ushort Sbz;
    GUID ObjectType;
};

struct PRIVILEGE_SET {
public:
    uint PrivilegeCount;
    uint Control;
    LUID_AND_ATTRIBUTES Privilege;
};

struct ACCESS_REASONS {
public:
    uint Data;
};

struct SE_SECURITY_DESCRIPTOR {
public:
    uint Size;
    uint Flags;
    PVOID SecurityDescriptor;
};

struct SE_ACCESS_REQUEST {
public:
    uint Size;
    PVOID SeSecurityDescriptor;
    uint DesiredAccess;
    uint PreviouslyGrantedAccess;
    PVOID PrincipalSelfSid;
    PVOID GenericMapping;
    uint ObjectTypeListCount;
    PVOID ObjectTypeList;
};

struct SE_ACCESS_REPLY {
public:
    uint Size;
    uint ResultListCount;
    PVOID GrantedAccess;
    uint AccessStatus;
    PVOID AccessReason;
    PVOID Privileges;
};

struct TOKEN_USER {
public:
    SID_AND_ATTRIBUTES User;
};

struct SE_TOKEN_USER {
public:
    TOKEN_USER TokenUser;
    SID Sid;
};

struct TOKEN_GROUPS {
public:
    uint GroupCount;
    SID_AND_ATTRIBUTES Groups;
};

struct TOKEN_PRIVILEGES {
public:
    uint PrivilegeCount;
    LUID_AND_ATTRIBUTES Privileges;
};

struct TOKEN_OWNER {
public:
    PVOID Owner;
};

struct TOKEN_PRIMARY_GROUP {
public:
    PVOID PrimaryGroup;
};

struct TOKEN_DEFAULT_DACL {
public:
    PVOID DefaultDacl;
};

struct TOKEN_USER_CLAIMS {
public:
    PVOID UserClaims;
};

struct TOKEN_DEVICE_CLAIMS {
public:
    PVOID DeviceClaims;
};

struct TOKEN_GROUPS_AND_PRIVILEGES {
public:
    uint SidCount;
    uint SidLength;
    PVOID Sids;
    uint RestrictedSidCount;
    uint RestrictedSidLength;
    PVOID RestrictedSids;
    uint PrivilegeCount;
    uint PrivilegeLength;
    PVOID Privileges;
    LUID AuthenticationId;
};

struct TOKEN_LINKED_TOKEN {
public:
    HANDLE LinkedToken;
};

struct TOKEN_ELEVATION {
public:
    uint TokenIsElevated;
};

struct TOKEN_MANDATORY_LABEL {
public:
    SID_AND_ATTRIBUTES Label;
};

struct TOKEN_MANDATORY_POLICY {
public:
    uint Policy;
};

struct TOKEN_ACCESS_INFORMATION {
public:
    PVOID SidHash;
    PVOID RestrictedSidHash;
    PVOID Privileges;
    LUID AuthenticationId;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    TOKEN_MANDATORY_POLICY MandatoryPolicy;
    uint Flags;
    uint AppContainerNumber;
    PVOID PackageSid;
    PVOID CapabilitiesHash;
    PVOID TrustLevelSid;
    PVOID SecurityAttributes;
};

struct TOKEN_AUDIT_POLICY {
};

struct TOKEN_SOURCE {
public:
    char SourceName;
    LUID SourceIdentifier;
};

struct TOKEN_STATISTICS {
public:
    LUID TokenId;
    LUID AuthenticationId;
    long ExpirationTime;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    uint DynamicCharged;
    uint DynamicAvailable;
    uint GroupCount;
    uint PrivilegeCount;
    LUID ModifiedId;
};

struct TOKEN_CONTROL {
public:
    LUID TokenId;
    LUID AuthenticationId;
    LUID ModifiedId;
    TOKEN_SOURCE TokenSource;
};

struct TOKEN_ORIGIN {
public:
    LUID OriginatingLogonSession;
};

struct TOKEN_APPCONTAINER_INFORMATION {
public:
    PVOID TokenAppContainer;
};

struct TOKEN_SID_INFORMATION {
public:
    PVOID Sid;
};

struct TOKEN_BNO_ISOLATION_INFORMATION {
public:
    string IsolationPrefix;
    uchar IsolationEnabled;
};

struct CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE {
public:
    ulong Version;
    string Name;
};

struct CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {
public:
    PVOID pValue;
    uint ValueLength;
};

struct CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 {
public:
    uint Name;
    ushort ValueType;
    ushort Reserved;
    uint Flags;
    uint ValueCount;
    uint pInt64;
};

struct Attribute {
public:
    ushort Version;
    ushort Reserved;
    uint AttributeCount;
    PVOID pAttributeV1;
};

struct SECURITY_QUALITY_OF_SERVICE {
public:
    uint Length;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    uchar ContextTrackingMode;
    uchar EffectiveOnly;
};

struct SE_IMPERSONATION_STATE {
public:
    PVOID Token;
    uchar CopyOnOpen;
    uchar EffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL Level;
};

struct SECURITY_CAPABILITIES {
public:
    PVOID AppContainerSid;
    PVOID Capabilities;
    uint CapabilityCount;
    uint Reserved;
};

struct JOB_SET_ARRAY {
public:
    HANDLE JobHandle;
    uint MemberLevel;
    uint Flags;
};

struct EXCEPTION_REGISTRATION_RECORD {
public:
    PVOID Next;
    PVOID Handler;
};

struct NT_TIB {
public:
    PVOID ExceptionList;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID SubSystemTib;
    PVOID FiberData;
    PVOID ArbitraryUserPointer;
    PVOID Self;
};

struct UMS_CREATE_THREAD_ATTRIBUTES {
public:
    uint UmsVersion;
    PVOID UmsContext;
    PVOID UmsCompletionList;
};

struct WOW64_ARCHITECTURE_INFORMATION {
public:
    uint Info;
};

struct QUOTA_LIMITS {
public:
    ulong PagedPoolLimit;
    ulong NonPagedPoolLimit;
    ulong MinimumWorkingSetSize;
    ulong MaximumWorkingSetSize;
    ulong PagefileLimit;
    long TimeLimit;
};

struct QUOTA_LIMITS_EX {
public:
    ulong PagedPoolLimit;
    ulong NonPagedPoolLimit;
    ulong MinimumWorkingSetSize;
    ulong MaximumWorkingSetSize;
    ulong PagefileLimit;
    long TimeLimit;
    ulong WorkingSetLimit;
    ulong Reserved2;
    ulong Reserved3;
    ulong Reserved4;
    uint Flags;
    uint CpuRateLimit;
};

struct IO_COUNTERS {
public:
    ulong ReadOperationCount;
    ulong WriteOperationCount;
    ulong OtherOperationCount;
    ulong ReadTransferCount;
    ulong WriteTransferCount;
    ulong OtherTransferCount;
};

struct JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
public:
    long TotalUserTime;
    long TotalKernelTime;
    long ThisPeriodTotalUserTime;
    long ThisPeriodTotalKernelTime;
    uint TotalPageFaultCount;
    uint TotalProcesses;
    uint ActiveProcesses;
    uint TotalTerminatedProcesses;
};

struct JOBOBJECT_BASIC_LIMIT_INFORMATION {
public:
    long PerProcessUserTimeLimit;
    long PerJobUserTimeLimit;
    uint LimitFlags;
    ulong MinimumWorkingSetSize;
    ulong MaximumWorkingSetSize;
    uint ActiveProcessLimit;
    ulong Affinity;
    uint PriorityClass;
    uint SchedulingClass;
};

struct JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
public:
    JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;
    IO_COUNTERS IoInfo;
    ulong ProcessMemoryLimit;
    ulong JobMemoryLimit;
    ulong PeakProcessMemoryUsed;
    ulong PeakJobMemoryUsed;
};

struct JOBOBJECT_BASIC_PROCESS_ID_LIST {
public:
    uint NumberOfAssignedProcesses;
    uint NumberOfProcessIdsInList;
    ulong ProcessIdList;
};

struct JOBOBJECT_BASIC_UI_RESTRICTIONS {
public:
    uint UIRestrictionsClass;
};

struct JOBOBJECT_SECURITY_LIMIT_INFORMATION {
public:
    uint SecurityLimitFlags;
    HANDLE JobToken;
    PVOID SidsToDisable;
    PVOID PrivilegesToDelete;
    PVOID RestrictedSids;
};

struct JOBOBJECT_END_OF_JOB_TIME_INFORMATION {
public:
    uint EndOfJobTimeAction;
};

struct JOBOBJECT_ASSOCIATE_COMPLETION_PORT {
public:
    PVOID CompletionKey;
    HANDLE CompletionPort;
};

struct JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
public:
    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo;
    IO_COUNTERS IoInfo;
};

struct JOBOBJECT_JOBSET_INFORMATION {
public:
    uint MemberLevel;
};

struct JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION {
public:
    ulong IoReadBytesLimit;
    ulong IoWriteBytesLimit;
    long PerJobUserTimeLimit;
    ulong JobMemoryLimit;
    JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
    JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL RateControlToleranceInterval;
    uint LimitFlags;
};

struct JOBOBJECT_LIMIT_VIOLATION_INFORMATION {
public:
    uint LimitFlags;
    uint ViolationLimitFlags;
    ulong IoReadBytes;
    ulong IoReadBytesLimit;
    ulong IoWriteBytes;
    ulong IoWriteBytesLimit;
    long PerJobUserTime;
    long PerJobUserTimeLimit;
    ulong JobMemory;
    ulong JobMemoryLimit;
    JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
    JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlToleranceLimit;
};

struct JOBOBJECT_NET_RATE_CONTROL_INFORMATION {
public:
    ulong MaxBandwidth;
    JOB_OBJECT_NET_RATE_CONTROL_FLAGS ControlFlags;
    uchar DscpTag;
};

struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE {
public:
    long MaxIops;
    long MaxBandwidth;
    long ReservationIops;
    string VolumeName;
    uint BaseIoSize;
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS ControlFlags;
    ushort VolumeNameLength;
};

struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2 {
public:
    long MaxIops;
    long MaxBandwidth;
    long ReservationIops;
    string VolumeName;
    uint BaseIoSize;
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS ControlFlags;
    ushort VolumeNameLength;
    long CriticalReservationIops;
    long ReservationBandwidth;
    long CriticalReservationBandwidth;
    long MaxTimePercent;
    long ReservationTimePercent;
    long CriticalReservationTimePercent;
};

struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3 {
public:
    long MaxIops;
    long MaxBandwidth;
    long ReservationIops;
    string VolumeName;
    uint BaseIoSize;
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS ControlFlags;
    ushort VolumeNameLength;
    long CriticalReservationIops;
    long ReservationBandwidth;
    long CriticalReservationBandwidth;
    long MaxTimePercent;
    long ReservationTimePercent;
    long CriticalReservationTimePercent;
    long SoftMaxIops;
    long SoftMaxBandwidth;
    long SoftMaxTimePercent;
    long LimitExcessNotifyIops;
    long LimitExcessNotifyBandwidth;
    long LimitExcessNotifyTimePercent;
};

struct JOBOBJECT_IO_ATTRIBUTION_STATS {
public:
    ulong IoCount;
    ulong TotalNonOverlappedQueueTime;
    ulong TotalNonOverlappedServiceTime;
    ulong TotalSize;
};

struct JOBOBJECT_IO_ATTRIBUTION_INFORMATION {
public:
    uint ControlFlags;
    JOBOBJECT_IO_ATTRIBUTION_STATS ReadStats;
    JOBOBJECT_IO_ATTRIBUTION_STATS WriteStats;
};

struct SILOOBJECT_BASIC_INFORMATION {
public:
    uint SiloId;
    uint SiloParentId;
    uint NumberOfProcesses;
    uchar IsInServerSilo;
    uchar Reserved;
};

struct SERVERSILO_BASIC_INFORMATION {
public:
    uint ServiceSessionId;
    SERVERSILO_STATE State;
    uint ExitStatus;
};

struct CACHE_DESCRIPTOR {
public:
    uchar Level;
    uchar Associativity;
    ushort LineSize;
    uint Size;
    PROCESSOR_CACHE_TYPE Type;
};

struct ProcessorCore {
public:
    ulong ProcessorMask;
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    uchar Flags;
};

struct PROCESSOR_RELATIONSHIP {
public:
    uchar Flags;
    uchar EfficiencyClass;
    uchar Reserved;
    ushort GroupCount;
    GROUP_AFFINITY GroupMask;
};

struct NUMA_NODE_RELATIONSHIP {
public:
    uint NodeNumber;
    uchar Reserved;
    GROUP_AFFINITY GroupMask;
};

struct CACHE_RELATIONSHIP {
public:
    uchar Level;
    uchar Associativity;
    ushort LineSize;
    uint CacheSize;
    PROCESSOR_CACHE_TYPE Type;
    uchar Reserved;
    GROUP_AFFINITY GroupMask;
};

struct PROCESSOR_GROUP_INFO {
public:
    uchar MaximumProcessorCount;
    uchar ActiveProcessorCount;
    uchar Reserved;
    ulong ActiveProcessorMask;
};

struct GROUP_RELATIONSHIP {
public:
    ushort MaximumGroupCount;
    ushort ActiveGroupCount;
    uchar Reserved;
    PROCESSOR_GROUP_INFO GroupInfo;
};

struct SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION {
public:
    ulong CycleTime;
};

struct XSTATE_FEATURE {
public:
    uint Offset;
    uint Size;
};

struct XSTATE_CONFIGURATION {
public:
    ulong EnabledFeatures;
    ulong EnabledVolatileFeatures;
    uint Size;
    uint ControlFlags;
    XSTATE_FEATURE Features;
    ulong EnabledSupervisorFeatures;
    ulong AlignedFeatures;
    uint AllFeatureSize;
    uint AllFeatures;
};

struct MEMORY_BASIC_INFORMATION {
public:
    PVOID BaseAddress;
    PVOID AllocationBase;
    uint AllocationProtect;
    ulong RegionSize;
    uint State;
    uint Protect;
    uint Type;
};

struct MEMORY_BASIC_INFORMATION32 {
public:
    uint BaseAddress;
    uint AllocationBase;
    uint AllocationProtect;
    uint RegionSize;
    uint State;
    uint Protect;
    uint Type;
};

struct MEMORY_BASIC_INFORMATION64 {
public:
    ulong BaseAddress;
    ulong AllocationBase;
    uint AllocationProtect;
    uint __alignment1;
    ulong RegionSize;
    uint State;
    uint Protect;
    uint Type;
    uint __alignment2;
};

struct CFG_CALL_TARGET_INFO {
public:
    ulong Offset;
    ulong Flags;
};

struct MEM_ADDRESS_REQUIREMENTS {
public:
    PVOID LowestStartingAddress;
    PVOID HighestEndingAddress;
    ulong Alignment;
};

struct ENCLAVE_CREATE_INFO_SGX {
public:
    uchar Secs;
};

struct ENCLAVE_INIT_INFO_SGX {
public:
    uchar SigStruct;
    uchar Reserved1;
    uchar EInitToken;
    uchar Reserved2;
};

struct ENCLAVE_CREATE_INFO_VBS {
public:
    uint Flags;
    uchar OwnerID;
};

struct ENCLAVE_INIT_INFO_VBS {
public:
    uint Length;
    uint ThreadCount;
};

struct FILE_ID_128 {
public:
    uchar Identifier;
};

struct FILE_NOTIFY_INFORMATION {
public:
    uint NextEntryOffset;
    uint Action;
    uint FileNameLength;
    short FileName;
};

struct FILE_NOTIFY_EXTENDED_INFORMATION {
public:
    uint NextEntryOffset;
    uint Action;
    long CreationTime;
    long LastModificationTime;
    long LastChangeTime;
    long LastAccessTime;
    long AllocatedLength;
    long FileSize;
    uint FileAttributes;
    uint ReparsePointTag;
    long FileId;
    long ParentFileId;
    uint FileNameLength;
    short FileName;
};

struct GenericReparseBuffer {
public:
    uint ReparseTag;
    ushort ReparseDataLength;
    ushort Reserved;
    GUID ReparseGuid;
    uchar DataBuffer;
};

struct SCRUB_DATA_INPUT {
public:
    uint Size;
    uint Flags;
    uint MaximumIos;
    uint ObjectId;
    uint Reserved;
    uchar ResumeContext;
};

struct SCRUB_PARITY_EXTENT {
public:
    long Offset;
    ulong Length;
};

struct SCRUB_PARITY_EXTENT_DATA {
public:
    ushort Size;
    ushort Flags;
    ushort NumberOfParityExtents;
    ushort MaximumNumberOfParityExtents;
    SCRUB_PARITY_EXTENT ParityExtents;
};

struct SCRUB_DATA_OUTPUT {
public:
    uint Size;
    uint Flags;
    uint Status;
    ulong ErrorFileOffset;
    ulong ErrorLength;
    ulong NumberOfBytesRepaired;
    ulong NumberOfBytesFailed;
    ulong InternalFileReference;
    ushort ResumeContextLength;
    ushort ParityExtentDataOffset;
    uint Reserved;
    uchar ResumeContext;
};

struct SHARED_VIRTUAL_DISK_SUPPORT {
public:
    SharedVirtualDiskSupportType SharedVirtualDiskSupport;
    SharedVirtualDiskHandleState HandleState;
};

struct NETWORK_APP_INSTANCE_EA {
public:
    GUID AppInstanceID;
    uint CsvFlags;
};

struct CM_POWER_DATA {
public:
    uint PD_Size;
    DEVICE_POWER_STATE PD_MostRecentPowerState;
    uint PD_Capabilities;
    uint PD_D1Latency;
    uint PD_D2Latency;
    uint PD_D3Latency;
    DEVICE_POWER_STATE PD_PowerStateMapping;
    SYSTEM_POWER_STATE PD_DeepestSystemWake;
};

struct POWER_USER_PRESENCE {
public:
    POWER_USER_PRESENCE_TYPE UserPresence;
};

struct POWER_SESSION_CONNECT {
public:
    uchar Connected;
    uchar Console;
};

struct POWER_SESSION_TIMEOUTS {
public:
    uint InputTimeout;
    uint DisplayTimeout;
};

struct POWER_SESSION_RIT_STATE {
public:
    uchar Active;
    uint LastInputTime;
};

struct POWER_SESSION_WINLOGON {
public:
    uint SessionId;
    uchar Console;
    uchar Locked;
};

struct POWER_IDLE_RESILIENCY {
public:
    uint CoalescingTimeout;
    uint IdleResiliencyPeriod;
};

struct POWER_MONITOR_INVOCATION {
public:
    uchar Console;
    POWER_MONITOR_REQUEST_REASON RequestReason;
};

struct RESUME_PERFORMANCE {
public:
    uint PostTimeMs;
    ulong TotalResumeTimeMs;
    ulong ResumeCompleteTimestamp;
};

struct APPLICATIONLAUNCH_SETTING_VALUE {
public:
    long ActivationTime;
    uint Flags;
    uint ButtonInstanceID;
};

struct POWER_PLATFORM_INFORMATION {
public:
    uchar AoAc;
};

struct POWER_ACTION_POLICY {
public:
    POWER_ACTION Action;
    uint Flags;
    uint EventCode;
};

struct SYSTEM_POWER_LEVEL {
public:
    uchar Enable;
    uchar Spare;
    uint BatteryLevel;
    POWER_ACTION_POLICY PowerPolicy;
    SYSTEM_POWER_STATE MinSystemState;
};

struct SYSTEM_POWER_POLICY {
public:
    uint Revision;
    POWER_ACTION_POLICY PowerButton;
    POWER_ACTION_POLICY SleepButton;
    POWER_ACTION_POLICY LidClose;
    SYSTEM_POWER_STATE LidOpenWake;
    uint Reserved;
    POWER_ACTION_POLICY Idle;
    uint IdleTimeout;
    uchar IdleSensitivity;
    uchar DynamicThrottle;
    uchar Spare2;
    SYSTEM_POWER_STATE MinSleep;
    SYSTEM_POWER_STATE MaxSleep;
    SYSTEM_POWER_STATE ReducedLatencySleep;
    uint WinLogonFlags;
    uint Spare3;
    uint DozeS4Timeout;
    uint BroadcastCapacityResolution;
    SYSTEM_POWER_LEVEL DischargePolicy;
    uint VideoTimeout;
    uchar VideoDimDisplay;
    uint VideoReserved;
    uint SpindownTimeout;
    uchar OptimizeForPower;
    uchar FanThrottleTolerance;
    uchar ForcedThrottle;
    uchar MinThrottle;
    POWER_ACTION_POLICY OverThrottled;
};

struct PROCESSOR_POWER_POLICY_INFO {
public:
    uint TimeCheck;
    uint DemoteLimit;
    uint PromoteLimit;
    uchar DemotePercent;
    uchar PromotePercent;
    uchar Spare;
    uint Flags;
};

struct PROCESSOR_POWER_POLICY {
public:
    uint Revision;
    uchar DynamicThrottle;
    uchar Spare;
    uint Flags;
    uint PolicyCount;
    PROCESSOR_POWER_POLICY_INFO Policy;
};

struct ADMINISTRATOR_POWER_POLICY {
public:
    SYSTEM_POWER_STATE MinSleep;
    SYSTEM_POWER_STATE MaxSleep;
    uint MinVideoTimeout;
    uint MaxVideoTimeout;
    uint MinSpindownTimeout;
    uint MaxSpindownTimeout;
};

struct HIBERFILE_BUCKET {
public:
    ulong MaxPhysicalMemory;
    uint PhysicalMemoryPercent;
};

struct IMAGE_DOS_HEADER {
public:
    ushort e_magic;
    ushort e_cblp;
    ushort e_cp;
    ushort e_crlc;
    ushort e_cparhdr;
    ushort e_minalloc;
    ushort e_maxalloc;
    ushort e_ss;
    ushort e_sp;
    ushort e_csum;
    ushort e_ip;
    ushort e_cs;
    ushort e_lfarlc;
    ushort e_ovno;
    ushort e_res;
    ushort e_oemid;
    ushort e_oeminfo;
    ushort e_res2;
    int e_lfanew;
};

struct IMAGE_OS2_HEADER {
public:
    ushort ne_magic;
    char ne_ver;
    char ne_rev;
    ushort ne_enttab;
    ushort ne_cbenttab;
    int ne_crc;
    ushort ne_flags;
    ushort ne_autodata;
    ushort ne_heap;
    ushort ne_stack;
    int ne_csip;
    int ne_sssp;
    ushort ne_cseg;
    ushort ne_cmod;
    ushort ne_cbnrestab;
    ushort ne_segtab;
    ushort ne_rsrctab;
    ushort ne_restab;
    ushort ne_modtab;
    ushort ne_imptab;
    int ne_nrestab;
    ushort ne_cmovent;
    ushort ne_align;
    ushort ne_cres;
    uchar ne_exetyp;
    uchar ne_flagsothers;
    ushort ne_pretthunks;
    ushort ne_psegrefbytes;
    ushort ne_swaparea;
    ushort ne_expver;
};

struct IMAGE_VXD_HEADER {
public:
    ushort e32_magic;
    uchar e32_border;
    uchar e32_ushorter;
    uint e32_level;
    ushort e32_cpu;
    ushort e32_os;
    uint e32_ver;
    uint e32_mflags;
    uint e32_mpages;
    uint e32_startobj;
    uint e32_eip;
    uint e32_stackobj;
    uint e32_esp;
    uint e32_pagesize;
    uint e32_lastpagesize;
    uint e32_fixupsize;
    uint e32_fixupsum;
    uint e32_ldrsize;
    uint e32_ldrsum;
    uint e32_objtab;
    uint e32_objcnt;
    uint e32_objmap;
    uint e32_itermap;
    uint e32_rsrctab;
    uint e32_rsrccnt;
    uint e32_restab;
    uint e32_enttab;
    uint e32_dirtab;
    uint e32_dircnt;
    uint e32_fpagetab;
    uint e32_frectab;
    uint e32_impmod;
    uint e32_impmodcnt;
    uint e32_impproc;
    uint e32_pagesum;
    uint e32_datapage;
    uint e32_preload;
    uint e32_nrestab;
    uint e32_cbnrestab;
    uint e32_nressum;
    uint e32_autodata;
    uint e32_debuginfo;
    uint e32_debuglen;
    uint e32_instpreload;
    uint e32_instdemand;
    uint e32_heapsize;
    uchar e32_res3;
    uint e32_winresoff;
    uint e32_winreslen;
    ushort e32_devid;
    ushort e32_ddkver;
};

struct IMAGE_FILE_HEADER {
public:
    ushort Machine;
    ushort NumberOfSections;
    uint TimeDateStamp;
    uint PointerToSymbolTable;
    uint NumberOfSymbols;
    ushort SizeOfOptionalHeader;
    ushort Characteristics;
};

struct IMAGE_DATA_DIRECTORY {
public:
    uint VirtualAddress;
    uint Size;
};

struct IMAGE_OPTIONAL_HEADER32 {
public:
    ushort Magic;
    uchar MajorLinkerVersion;
    uchar MinorLinkerVersion;
    uint SizeOfCode;
    uint SizeOfInitializedData;
    uint SizeOfUninitializedData;
    uint AddressOfEntryPoint;
    uint BaseOfCode;
    uint BaseOfData;
    uint ImageBase;
    uint SectionAlignment;
    uint FileAlignment;
    ushort MajorOperatingSystemVersion;
    ushort MinorOperatingSystemVersion;
    ushort MajorImageVersion;
    ushort MinorImageVersion;
    ushort MajorSubsystemVersion;
    ushort MinorSubsystemVersion;
    uint Win32VersionValue;
    uint SizeOfImage;
    uint SizeOfHeaders;
    uint CheckSum;
    ushort Subsystem;
    ushort DllCharacteristics;
    uint SizeOfStackReserve;
    uint SizeOfStackCommit;
    uint SizeOfHeapReserve;
    uint SizeOfHeapCommit;
    uint LoaderFlags;
    uint NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory;
};

struct IMAGE_ROM_OPTIONAL_HEADER {
public:
    ushort Magic;
    uchar MajorLinkerVersion;
    uchar MinorLinkerVersion;
    uint SizeOfCode;
    uint SizeOfInitializedData;
    uint SizeOfUninitializedData;
    uint AddressOfEntryPoint;
    uint BaseOfCode;
    uint BaseOfData;
    uint BaseOfBss;
    uint GprMask;
    uint CprMask;
    uint GpValue;
};

struct IMAGE_OPTIONAL_HEADER64 {
public:
    ushort Magic;
    uchar MajorLinkerVersion;
    uchar MinorLinkerVersion;
    uint SizeOfCode;
    uint SizeOfInitializedData;
    uint SizeOfUninitializedData;
    uint AddressOfEntryPoint;
    uint BaseOfCode;
    ulong ImageBase;
    uint SectionAlignment;
    uint FileAlignment;
    ushort MajorOperatingSystemVersion;
    ushort MinorOperatingSystemVersion;
    ushort MajorImageVersion;
    ushort MinorImageVersion;
    ushort MajorSubsystemVersion;
    ushort MinorSubsystemVersion;
    uint Win32VersionValue;
    uint SizeOfImage;
    uint SizeOfHeaders;
    uint CheckSum;
    ushort Subsystem;
    ushort DllCharacteristics;
    ulong SizeOfStackReserve;
    ulong SizeOfStackCommit;
    ulong SizeOfHeapReserve;
    ulong SizeOfHeapCommit;
    uint LoaderFlags;
    uint NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory;
};

struct IMAGE_NT_HEADERS64 {
public:
    uint Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
};

struct IMAGE_NT_HEADERS32 {
public:
    uint Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
};

struct IMAGE_ROM_HEADERS {
public:
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
};

struct ANON_OBJECT_HEADER {
public:
    ushort Sig1;
    ushort Sig2;
    ushort Version;
    ushort Machine;
    uint TimeDateStamp;
    GUID ClassID;
    uint SizeOfData;
};

struct ANON_OBJECT_HEADER_V2 {
public:
    ushort Sig1;
    ushort Sig2;
    ushort Version;
    ushort Machine;
    uint TimeDateStamp;
    GUID ClassID;
    uint SizeOfData;
    uint Flags;
    uint MetaDataSize;
    uint MetaDataOffset;
};

struct ANON_OBJECT_HEADER_BIGOBJ {
public:
    ushort Sig1;
    ushort Sig2;
    ushort Version;
    ushort Machine;
    uint TimeDateStamp;
    GUID ClassID;
    uint SizeOfData;
    uint Flags;
    uint MetaDataSize;
    uint MetaDataOffset;
    uint NumberOfSections;
    uint PointerToSymbolTable;
    uint NumberOfSymbols;
};

struct IMAGE_SECTION_HEADER {
public:
    uchar Name;
    uint PhysicalAddress;
    uint VirtualAddress;
    uint SizeOfRawData;
    uint PointerToRawData;
    uint PointerToRelocations;
    uint PointerToLinenumbers;
    ushort NumberOfRelocations;
    ushort NumberOfLinenumbers;
    uint Characteristics;
};

struct IMAGE_SYMBOL {
public:
    uchar ShortName;
    uint Value;
    short SectionNumber;
    ushort Type;
    uchar StorageClass;
    uchar NumberOfAuxSymbols;
};

struct IMAGE_SYMBOL_EX {
public:
    uchar ShortName;
    uint Value;
    int SectionNumber;
    ushort Type;
    uchar StorageClass;
    uchar NumberOfAuxSymbols;
};

struct IMAGE_AUX_SYMBOL_TOKEN_DEF {
public:
    uchar bAuxType;
    uchar bReserved;
    uint SymbolTableIndex;
    uchar rgbReserved;
};

struct IMAGE_LINENUMBER {
public:
    uint VirtualAddress;
    ushort Linenumber;
};

struct IMAGE_BASE_RELOCATION {
public:
    uint VirtualAddress;
    uint SizeOfBlock;
};

struct IMAGE_ARCHIVE_MEMBER_HEADER {
public:
    uchar Name;
    uchar Date;
    uchar UserID;
    uchar GroupID;
    uchar Mode;
    uchar Size;
    uchar EndHeader;
};

struct IMAGE_EXPORT_DIRECTORY {
public:
    uint Characteristics;
    uint TimeDateStamp;
    ushort MajorVersion;
    ushort MinorVersion;
    uint Name;
    uint Base;
    uint NumberOfFunctions;
    uint NumberOfNames;
    uint AddressOfFunctions;
    uint AddressOfNames;
    uint AddressOfNameOrdinals;
};

struct IMAGE_IMPORT_BY_NAME {
public:
    ushort Hint;
    char Name;
};

struct IMAGE_THUNK_DATA64 {
public:
    ulong Data;
};

struct IMAGE_THUNK_DATA32 {
public:
    uint Data;
};

struct IMAGE_BOUND_IMPORT_DESCRIPTOR {
public:
    uint TimeDateStamp;
    ushort OffsetModuleName;
    ushort NumberOfModuleForwarderRefs;
};

struct IMAGE_BOUND_FORWARDER_REF {
public:
    uint TimeDateStamp;
    ushort OffsetModuleName;
    ushort Reserved;
};

struct IMAGE_RESOURCE_DIRECTORY {
public:
    uint Characteristics;
    uint TimeDateStamp;
    ushort MajorVersion;
    ushort MinorVersion;
    ushort NumberOfNamedEntries;
    ushort NumberOfIdEntries;
};

struct IMAGE_RESOURCE_DIRECTORY_STRING {
public:
    ushort Length;
    char NameString;
};

struct IMAGE_RESOURCE_DIR_STRING_U {
public:
    ushort Length;
    short NameString;
};

struct IMAGE_RESOURCE_DATA_ENTRY {
public:
    uint OffsetToData;
    uint Size;
    uint CodePage;
    uint Reserved;
};

struct IMAGE_LOAD_CONFIG_CODE_INTEGRITY {
public:
    ushort Flags;
    ushort Catalog;
    uint CatalogOffset;
    uint Reserved;
};

struct IMAGE_DYNAMIC_RELOCATION_TABLE {
public:
    uint Version;
    uint Size;
};

struct IMAGE_DYNAMIC_RELOCATION32 {
public:
    uint Symbol;
    uint BaseRelocSize;
};

struct IMAGE_DYNAMIC_RELOCATION64 {
public:
    ulong Symbol;
    uint BaseRelocSize;
};

struct IMAGE_DYNAMIC_RELOCATION32_V2 {
public:
    uint HeaderSize;
    uint FixupInfoSize;
    uint Symbol;
    uint SymbolGroup;
    uint Flags;
};

struct IMAGE_DYNAMIC_RELOCATION64_V2 {
public:
    uint HeaderSize;
    uint FixupInfoSize;
    ulong Symbol;
    uint SymbolGroup;
    uint Flags;
};

struct IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER {
public:
    uchar PrologueByteCount;
};

struct IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER {
public:
    uint EpilogueCount;
    uchar EpilogueByteCount;
    uchar BranchDescriptorElementSize;
    ushort BranchDescriptorCount;
};

struct IMAGE_LOAD_CONFIG_DIRECTORY32 {
public:
    uint Size;
    uint TimeDateStamp;
    ushort MajorVersion;
    ushort MinorVersion;
    uint GlobalFlagsClear;
    uint GlobalFlagsSet;
    uint CriticalSectionDefaultTimeout;
    uint DeCommitFreeBlockThreshold;
    uint DeCommitTotalFreeThreshold;
    uint LockPrefixTable;
    uint MaximumAllocationSize;
    uint VirtualMemoryThreshold;
    uint ProcessHeapFlags;
    uint ProcessAffinityMask;
    ushort CSDVersion;
    ushort DependentLoadFlags;
    uint EditList;
    uint SecurityCookie;
    uint SEHandlerTable;
    uint SEHandlerCount;
    uint GuardCFCheckFunctionPointer;
    uint GuardCFDispatchFunctionPointer;
    uint GuardCFFunctionTable;
    uint GuardCFFunctionCount;
    uint GuardFlags;
    IMAGE_LOAD_CONFIG_CODE_INTEGRITY CodeIntegrity;
    uint GuardAddressTakenIatEntryTable;
    uint GuardAddressTakenIatEntryCount;
    uint GuardLongJumpTargetTable;
    uint GuardLongJumpTargetCount;
    uint DynamicValueRelocTable;
    uint CHPEMetadataPointer;
    uint GuardRFFailureRoutine;
    uint GuardRFFailureRoutineFunctionPointer;
    uint DynamicValueRelocTableOffset;
    ushort DynamicValueRelocTableSection;
    ushort Reserved2;
    uint GuardRFVerifyStackPointerFunctionPointer;
    uint HotPatchTableOffset;
    uint Reserved3;
    uint EnclaveConfigurationPointer;
};

struct IMAGE_LOAD_CONFIG_DIRECTORY64 {
public:
    uint Size;
    uint TimeDateStamp;
    ushort MajorVersion;
    ushort MinorVersion;
    uint GlobalFlagsClear;
    uint GlobalFlagsSet;
    uint CriticalSectionDefaultTimeout;
    ulong DeCommitFreeBlockThreshold;
    ulong DeCommitTotalFreeThreshold;
    ulong LockPrefixTable;
    ulong MaximumAllocationSize;
    ulong VirtualMemoryThreshold;
    ulong ProcessAffinityMask;
    uint ProcessHeapFlags;
    ushort CSDVersion;
    ushort DependentLoadFlags;
    ulong EditList;
    ulong SecurityCookie;
    ulong SEHandlerTable;
    ulong SEHandlerCount;
    ulong GuardCFCheckFunctionPointer;
    ulong GuardCFDispatchFunctionPointer;
    ulong GuardCFFunctionTable;
    ulong GuardCFFunctionCount;
    uint GuardFlags;
    IMAGE_LOAD_CONFIG_CODE_INTEGRITY CodeIntegrity;
    ulong GuardAddressTakenIatEntryTable;
    ulong GuardAddressTakenIatEntryCount;
    ulong GuardLongJumpTargetTable;
    ulong GuardLongJumpTargetCount;
    ulong DynamicValueRelocTable;
    ulong CHPEMetadataPointer;
    ulong GuardRFFailureRoutine;
    ulong GuardRFFailureRoutineFunctionPointer;
    uint DynamicValueRelocTableOffset;
    ushort DynamicValueRelocTableSection;
    ushort Reserved2;
    ulong GuardRFVerifyStackPointerFunctionPointer;
    uint HotPatchTableOffset;
    uint Reserved3;
    ulong EnclaveConfigurationPointer;
};

struct IMAGE_HOT_PATCH_INFO {
public:
    uint Version;
    uint Size;
    uint SequenceNumber;
    uint BaseImageList;
    uint BaseImageCount;
    uint BufferOffset;
};

struct IMAGE_HOT_PATCH_BASE {
public:
    uint SequenceNumber;
    uint Flags;
    uint OriginalTimeDateStamp;
    uint OriginalCheckSum;
    uint CodeIntegrityInfo;
    uint CodeIntegritySize;
    uint PatchTable;
    uint BufferOffset;
};

struct IMAGE_HOT_PATCH_HASHES {
public:
    uchar SHA256;
    uchar SHA1;
};

struct IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
public:
    uint FuncStart;
    uint Flags;
};

struct IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY {
public:
    ulong BeginAddress;
    ulong EndAddress;
    ulong ExceptionHandler;
    ulong HandlerData;
    ulong PrologEndAddress;
};

struct IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY {
public:
    uint BeginAddress;
    uint EndAddress;
    uint ExceptionHandler;
    uint HandlerData;
    uint PrologEndAddress;
};

struct IMAGE_ENCLAVE_CONFIG32 {
public:
    uint Size;
    uint MinimumRequiredConfigSize;
    uint PolicyFlags;
    uint NumberOfImports;
    uint ImportList;
    uint ImportEntrySize;
    uchar FamilyID;
    uchar ImageID;
    uint ImageVersion;
    uint SecurityVersion;
    uint EnclaveSize;
    uint NumberOfThreads;
    uint EnclaveFlags;
};

struct IMAGE_ENCLAVE_CONFIG64 {
public:
    uint Size;
    uint MinimumRequiredConfigSize;
    uint PolicyFlags;
    uint NumberOfImports;
    uint ImportList;
    uint ImportEntrySize;
    uchar FamilyID;
    uchar ImageID;
    uint ImageVersion;
    uint SecurityVersion;
    ulong EnclaveSize;
    uint NumberOfThreads;
    uint EnclaveFlags;
};

struct IMAGE_ENCLAVE_IMPORT {
public:
    uint MatchType;
    uint MinimumSecurityVersion;
    uchar UniqueOrAuthorID;
    uchar FamilyID;
    uchar ImageID;
    uint ImportName;
    uint Reserved;
};

struct IMAGE_DEBUG_DIRECTORY {
public:
    uint Characteristics;
    uint TimeDateStamp;
    ushort MajorVersion;
    ushort MinorVersion;
    uint Type;
    uint SizeOfData;
    uint AddressOfRawData;
    uint PointerToRawData;
};

struct IMAGE_COFF_SYMBOLS_HEADER {
public:
    uint NumberOfSymbols;
    uint LvaToFirstSymbol;
    uint NumberOfLinenumbers;
    uint LvaToFirstLinenumber;
    uint RvaToFirstByteOfCode;
    uint RvaToLastByteOfCode;
    uint RvaToFirstByteOfData;
    uint RvaToLastByteOfData;
};

struct FPO_DATA {
public:
    uint ulOffStart;
    uint cbProcSize;
    uint cdwLocals;
    ushort cdwParams;
    ushort data;
};

struct IMAGE_DEBUG_MISC {
public:
    uint DataType;
    uint Length;
    uchar Unicode;
    uchar Reserved;
    uchar Data;
};

struct IMAGE_FUNCTION_ENTRY {
public:
    uint StartingAddress;
    uint EndingAddress;
    uint EndOfPrologue;
};

struct IMAGE_SEPARATE_DEBUG_HEADER {
public:
    ushort Signature;
    ushort Flags;
    ushort Machine;
    ushort Characteristics;
    uint TimeDateStamp;
    uint CheckSum;
    uint ImageBase;
    uint SizeOfImage;
    uint NumberOfSections;
    uint ExportedNamesSize;
    uint DebugDirectorySize;
    uint SectionAlignment;
    uint Reserved;
};

struct NON_PAGED_DEBUG_INFO {
public:
    ushort Signature;
    ushort Flags;
    uint Size;
    ushort Machine;
    ushort Characteristics;
    uint TimeDateStamp;
    uint CheckSum;
    uint SizeOfImage;
    ulong ImageBase;
};

struct IMAGE_ARCHITECTURE_HEADER {
public:
    int mask;
    uint FirstEntryRVA;
};

struct IMAGE_ARCHITECTURE_ENTRY {
public:
    uint FixupInstRVA;
    uint NewInst;
};

struct SLIST_ENTRY {
public:
    PVOID Next;
};

struct RTL_BARRIER {
public:
    uint Reserved1;
    uint Reserved2;
    ulong Reserved3;
    uint Reserved4;
    uint Reserved5;
};

struct MESSAGE_RESOURCE_ENTRY {
public:
    ushort Length;
    ushort Flags;
    uchar Text;
};

struct MESSAGE_RESOURCE_BLOCK {
public:
    uint LowId;
    uint HighId;
    uint OffsetToEntries;
};

struct MESSAGE_RESOURCE_DATA {
public:
    uint NumberOfBlocks;
    MESSAGE_RESOURCE_BLOCK Blocks;
};

struct OSVERSIONINFOW {
public:
    uint dwOSVersionInfoSize;
    uint dwMajorVersion;
    uint dwMinorVersion;
    uint dwBuildNumber;
    uint dwPlatformId;
    ushort szCSDVersion;
};

struct OSVERSIONINFOEXW {
public:
    uint dwOSVersionInfoSize;
    uint dwMajorVersion;
    uint dwMinorVersion;
    uint dwBuildNumber;
    uint dwPlatformId;
    short szCSDVersion;
    ushort wServicePackMajor;
    ushort wServicePackMinor;
    ushort wSuiteMask;
    uchar wProductType;
    uchar wReserved;
};

struct NV_MEMORY_RANGE {
public:
    PVOID BaseAddress;
    ulong Length;
};

struct CORRELATION_VECTOR {
public:
    char Version;
    char Vector;
};

struct CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG {
public:
    uint Size;
    const string TriggerId;
};

struct IMAGE_POLICY_ENTRY {
public:
    IMAGE_POLICY_ENTRY_TYPE Type;
    IMAGE_POLICY_ID PolicyId;
    PVOID Value;
};

struct IMAGE_POLICY_METADATA {
public:
    uchar Version;
    uchar Reserved0;
    ulong ApplicationId;
    IMAGE_POLICY_ENTRY Policies;
};

struct RTL_CRITICAL_SECTION_DEBUG {
public:
    ushort Type;
    ushort CreatorBackTraceIndex;
    PVOID CriticalSection;
    LIST_ENTRY ProcessLocksList;
    uint EntryCount;
    uint ContentionCount;
    uint Flags;
    ushort CreatorBackTraceIndexHigh;
    ushort Spareushort;
};

struct RTL_CRITICAL_SECTION {
public:
    PVOID DebugInfo;
    int LockCount;
    int RecursionCount;
    HANDLE OwningThread;
    HANDLE LockSemaphore;
    ulong SpinCount;
};

struct RTL_SRWLOCK {
public:
    PVOID Ptr;
};

struct RTL_CONDITION_VARIABLE {
public:
    PVOID Ptr;
};

struct HEAP_OPTIMIZE_RESOURCES_INFORMATION {
public:
    uint Version;
    uint Flags;
};

struct ACTIVATION_CONTEXT_QUERY_INDEX {
public:
    uint ulAssemblyIndex;
    uint ulFileIndexInAssembly;
};

struct ASSEMBLY_FILE_DETAILED_INFORMATION {
public:
    uint ulFlags;
    uint ulFilenameLength;
    uint ulPathLength;
    const string lpFileName;
    const string lpFilePath;
};

struct ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION {
public:
    uint ulFlags;
    uint ulEncodedAssemblyIdentityLength;
    uint ulManifestPathType;
    uint ulManifestPathLength;
    long liManifestLastWriteTime;
    uint ulPolicyPathType;
    uint ulPolicyPathLength;
    long liPolicyLastWriteTime;
    uint ulMetadataSatelliteRosterIndex;
    uint ulManifestVersionMajor;
    uint ulManifestVersionMinor;
    uint ulPolicyVersionMajor;
    uint ulPolicyVersionMinor;
    uint ulAssemblyDirectoryNameLength;
    const string lpAssemblyEncodedAssemblyIdentity;
    const string lpAssemblyManifestPath;
    const string lpAssemblyPolicyPath;
    const string lpAssemblyDirectoryName;
    uint ulFileCount;
};

struct ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION {
public:
    uint ulFlags;
    ACTCTX_REQUESTED_RUN_LEVEL RunLevel;
    uint UiAccess;
};

struct COMPATIBILITY_CONTEXT_ELEMENT {
public:
    GUID Id;
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE Type;
};

struct ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION {
public:
    uint ElementCount;
    COMPATIBILITY_CONTEXT_ELEMENT Elements;
};

struct SUPPORTED_OS_INFO {
public:
    ushort MajorVersion;
    ushort MinorVersion;
};

struct ACTIVATION_CONTEXT_DETAILED_INFORMATION {
public:
    uint dwFlags;
    uint ulFormatVersion;
    uint ulAssemblyCount;
    uint ulRootManifestPathType;
    uint ulRootManifestPathChars;
    uint ulRootConfigurationPathType;
    uint ulRootConfigurationPathChars;
    uint ulAppDirPathType;
    uint ulAppDirPathChars;
    const string lpRootManifestPath;
    const string lpRootConfigurationPath;
    const string lpAppDirPath;
};

struct HARDWARE_COUNTER_DATA {
public:
    HARDWARE_COUNTER_TYPE Type;
    uint Reserved;
    ulong Value;
};

struct PERFORMANCE_DATA {
public:
    ushort Size;
    uchar Version;
    uchar HwCountersCount;
    uint ContextSwitchCount;
    ulong WaitReasonBitMap;
    ulong CycleTime;
    uint RetryCount;
    uint Reserved;
    HARDWARE_COUNTER_DATA HwCounters;
};

struct EVENTLOGRECORD {
public:
    uint Length;
    uint Reserved;
    uint RecordNumber;
    uint TimeGenerated;
    uint TimeWritten;
    uint EventID;
    ushort EventType;
    ushort NumStrings;
    ushort EventCategory;
    ushort ReservedFlags;
    uint ClosingRecordNumber;
    uint StringOffset;
    uint UserSidLength;
    uint UserSidOffset;
    uint DataLength;
    uint DataOffset;
};

struct TAPE_ERASE {
public:
    uint Type;
    uchar Immediate;
};

struct TAPE_PREPARE {
public:
    uint Operation;
    uchar Immediate;
};

struct TAPE_WRITE_MARKS {
public:
    uint Type;
    uint Count;
    uchar Immediate;
};

struct TAPE_GET_POSITION {
public:
    uint Type;
    uint Partition;
    long Offset;
};

struct TAPE_SET_POSITION {
public:
    uint Method;
    uint Partition;
    long Offset;
    uchar Immediate;
};

struct TAPE_GET_DRIVE_PARAMETERS {
public:
    uchar ECC;
    uchar Compression;
    uchar DataPadding;
    uchar ReportSetmarks;
    uint DefaultBlockSize;
    uint MaximumBlockSize;
    uint MinimumBlockSize;
    uint MaximumPartitionCount;
    uint FeaturesLow;
    uint FeaturesHigh;
    uint EOTWarningZoneSize;
};

struct TAPE_SET_DRIVE_PARAMETERS {
public:
    uchar ECC;
    uchar Compression;
    uchar DataPadding;
    uchar ReportSetmarks;
    uint EOTWarningZoneSize;
};

struct TAPE_GET_MEDIA_PARAMETERS {
public:
    long Capacity;
    long Remaining;
    uint BlockSize;
    uint PartitionCount;
    uchar WriteProtected;
};

struct TAPE_SET_MEDIA_PARAMETERS {
public:
    uint BlockSize;
};

struct TAPE_CREATE_PARTITION {
public:
    uint Method;
    uint Count;
    uint Size;
};

struct TAPE_WMI_OPERATIONS {
public:
    uint Method;
    uint DataBufferSize;
    PVOID DataBuffer;
};

struct TRANSACTION_BASIC_INFORMATION {
public:
    GUID TransactionId;
    uint State;
    uint Outcome;
};

struct TRANSACTIONMANAGER_BASIC_INFORMATION {
public:
    GUID TmIdentity;
    long VirtualClock;
};

struct TRANSACTIONMANAGER_LOG_INFORMATION {
public:
    GUID LogIdentity;
};

struct TRANSACTIONMANAGER_LOGPATH_INFORMATION {
public:
    uint LogPathLength;
    short LogPath;
};

struct TRANSACTIONMANAGER_RECOVERY_INFORMATION {
public:
    ulong LastRecoveredLsn;
};

struct TRANSACTIONMANAGER_OLDEST_INFORMATION {
public:
    GUID OldestTransactionGuid;
};

struct TRANSACTION_PROPERTIES_INFORMATION {
public:
    uint IsolationLevel;
    uint IsolationFlags;
    long Timeout;
    uint Outcome;
    uint DescriptionLength;
    short Description;
};

struct TRANSACTION_BIND_INFORMATION {
public:
    HANDLE TmHandle;
};

struct TRANSACTION_ENLISTMENT_PAIR {
public:
    GUID EnlistmentId;
    GUID ResourceManagerId;
};

struct TRANSACTION_ENLISTMENTS_INFORMATION {
public:
    uint NumberOfEnlistments;
    TRANSACTION_ENLISTMENT_PAIR EnlistmentPair;
};

struct TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {
public:
    TRANSACTION_ENLISTMENT_PAIR SuperiorEnlistmentPair;
};

struct RESOURCEMANAGER_BASIC_INFORMATION {
public:
    GUID ResourceManagerId;
    uint DescriptionLength;
    short Description;
};

struct RESOURCEMANAGER_COMPLETION_INFORMATION {
public:
    HANDLE IoCompletionPortHandle;
    ulong CompletionKey;
};

struct ENLISTMENT_BASIC_INFORMATION {
public:
    GUID EnlistmentId;
    GUID TransactionId;
    GUID ResourceManagerId;
};

struct ENLISTMENT_CRM_INFORMATION {
public:
    GUID CrmTransactionManagerId;
    GUID CrmResourceManagerId;
    GUID CrmEnlistmentId;
};

struct TRANSACTION_LIST_ENTRY {
public:
    GUID UOW;
};

struct TRANSACTION_LIST_INFORMATION {
public:
    uint NumberOfTransactions;
    TRANSACTION_LIST_ENTRY TransactionInformation;
};

struct KTMOBJECT_CURSOR {
public:
    GUID LastQuery;
    uint ObjectIdCount;
    GUID ObjectIds;
};

struct TP_POOL_STACK_INFORMATION {
public:
    ulong StackReserve;
    ulong StackCommit;
};

struct TP_CALLBACK_ENVIRON_V3 {
public:
    uint Version;
    PVOID Pool;
    PVOID CleanupGroup;
    PVOID CleanupGroupCancelCallback;
    PVOID RaceDll;
    PVOID ActivationContext;
    PVOID FinalizationCallback;
    uint Flags;
    TP_CALLBACK_PRIORITY CallbackPriority;
    uint Size;
};

struct SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
public:
    ulong ProcessorMask;
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    uchar offset;
    ulong Reserved;
};

struct SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
public:
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    uint Size;
    uchar info;
};

struct SYSTEM_CPU_SET_INFORMATION {
public:
    uint Size;
    CPU_SET_INFORMATION_TYPE Type;
    uint Id;
    ushort Group;
    uchar LogicalProcessorIndex;
    uchar CoreIndex;
    uchar LastLevelCacheIndex;
    uchar NumaNodeIndex;
    uchar EfficiencyClass;
    uchar AllFlags;
    uint Reserved;
    ulong AllocationTag;
};

struct VALENTW {
public:
    PVOID ve_valuename;
    uint ve_valuelen;
    uchar offset1;
    PVOID ve_valueptr;
    uint ve_type;
    uchar offset2;
};

struct ACCEL {
public:
    uchar fVirt;
    ushort key;
    ushort cmd;
};

struct ACCESSTIMEOUT {
public:
    uint cbSize;
    uint dwFlags;
    uint iTimeOutMSec;
};

struct ALTTABINFO {
public:
    uint cbSize;
    int cItems;
    int cColumns;
    int cRows;
    int iColFocus;
    int iRowFocus;
    int cxItem;
    int cyItem;
    POINT ptStart;
};

struct ANIMATIONINFO {
public:
    uint cbSize;
    int iMinAnimate;
};

struct AUDIODESCRIPTION {
public:
    uint cbSize;
    int Enabled;
    uint Locale;
};

struct BSMINFO {
public:
    uint cbSize;
    HANDLE hdesk;
    HANDLE hwnd;
    LUID luid;
};

struct CBT_CREATEWNDA {
public:
    HANDLE hwndInsertAfter;
};

struct CBT_CREATEWNDW {
public:
    HANDLE hwndInsertAfter;
};

struct CBTACTIVATESTRUCT {
public:
    int fMouse;
    HANDLE hWndActive;
};

struct CHANGEFILTERSTRUCT {
public:
    uint cbSize;
    uint ExtStatus;
};

struct CLIENTCREATESTRUCT {
public:
    HANDLE hWindowMenu;
    uint idFirstChild;
};

struct COMBOBOXINFO {
public:
    uint cbSize;
    RECT rcItem;
    RECT rcButton;
    uint stateButton;
    HANDLE hwndCombo;
    HANDLE hwndItem;
    HANDLE hwndList;
};

struct COMPAREITEMSTRUCT {
public:
    uint CtlType;
    uint CtlID;
    HANDLE hwndItem;
    uint itemID1;
    ulong itemData1;
    uint itemID2;
    ulong itemData2;
    uint dwLocaleId;
};

struct COPYDATASTRUCT {
public:
    ulong dwData;
    uint cbData;
};

struct CURSORINFO {
public:
    uint cbSize;
    uint flags;
    HANDLE hCursor;
    POINT ptScreenPos;
};

struct CURSORSHAPE {
public:
    int xHotSpot;
    int yHotSpot;
    int cx;
    int cy;
    int cbWidth;
    uchar Planes;
    uchar BitsPixel;
};

struct CWPRETSTRUCT {
public:
    PVOID lResult;
    PVOID lParam;
    PVOID wParam;
    uint message;
    HANDLE hwnd;
};

struct CWPSTRUCT {
public:
    PVOID lParam;
    PVOID wParam;
    uint message;
    HANDLE hwnd;
};

struct DEBUGHOOKINFO {
public:
    uint idThread;
    uint idThreadInstaller;
    PVOID lParam;
    PVOID wParam;
    int code;
};

struct DELETEITEMSTRUCT {
public:
    uint CtlType;
    uint CtlID;
    uint itemID;
    HANDLE hwndItem;
    ulong itemData;
};

struct DLGITEMTEMPLATE {
public:
    uint style;
    uint dwExtendedStyle;
    short x;
    short y;
    short cx;
    short cy;
    ushort id;
};

struct DLGTEMPLATE {
public:
    uint style;
    uint dwExtendedStyle;
    ushort cdit;
    short x;
    short y;
    short cx;
    short cy;
};

struct DRAWITEMSTRUCT {
public:
    uint CtlType;
    uint CtlID;
    uint itemID;
    uint itemAction;
    uint itemState;
    HANDLE hwndItem;
    HANDLE hDC;
    RECT rcItem;
    ulong itemData;
};

struct DRAWTEXTPARAMS {
public:
    uint cbSize;
    int iTabLength;
    int iLeftMargin;
    int iRightMargin;
    uint uiLengthDrawn;
};

struct DROPSTRUCT {
public:
    HANDLE hwndSource;
    HANDLE hwndSink;
    uint wFmt;
    ulong dwData;
    POINT ptDrop;
    uint dwControlData;
};

struct EVENTMSG {
public:
    uint message;
    uint paramL;
    uint paramH;
    uint time;
    HANDLE hwnd;
};

struct FILTERKEYS {
public:
    uint cbSize;
    uint dwFlags;
    uint iWaitMSec;
    uint iDelayMSec;
    uint iRepeatMSec;
    uint iBounceMSec;
};

struct FLASHWINFO {
public:
    uint cbSize;
    HANDLE hwnd;
    uint dwFlags;
    uint uCount;
    uint dwTimeout;
};

struct GESTURECONFIG {
public:
    uint dwID;
    uint dwWant;
    uint dwBlock;
};

struct GESTUREINFO {
public:
    uint cbSize;
    uint dwFlags;
    uint dwID;
    HANDLE hwndTarget;
    POINTS ptsLocation;
    uint dwInstanceID;
    uint dwSequenceID;
    ulong ullArguments;
    uint cbExtraArgs;
};

struct GESTURENOTIFYSTRUCT {
public:
    uint cbSize;
    uint dwFlags;
    HANDLE hwndTarget;
    POINTS ptsLocation;
    uint dwInstanceID;
};

struct GUITHREADINFO {
public:
    uint cbSize;
    uint flags;
    HANDLE hwndActive;
    HANDLE hwndFocus;
    HANDLE hwndCapture;
    HANDLE hwndMenuOwner;
    HANDLE hwndMoveSize;
    HANDLE hwndCaret;
    RECT rcCaret;
};

struct HARDWAREHOOKSTRUCT {
public:
    HANDLE hwnd;
    uint message;
    PVOID wParam;
    PVOID lParam;
};

struct HARDWAREINPUT {
public:
    uint uMsg;
    ushort wParamL;
    ushort wParamH;
};

struct HELPINFO {
public:
    uint cbSize;
    int iContextType;
    int iCtrlId;
    HANDLE hItemHandle;
    uint dwContextId;
    POINT MousePos;
};

struct HELPWININFOA {
public:
    int wStructSize;
    int x;
    int y;
    int dx;
    int dy;
    int wMax;
    char rgchMember;
};

struct HELPWININFOW {
public:
    int wStructSize;
    int x;
    int y;
    int dx;
    int dy;
    int wMax;
    short rgchMember;
};

struct HIGHCONTRASTW {
public:
    uint cbSize;
    uint dwFlags;
    string lpszDefaultScheme;
};

struct ICONINFO {
public:
    int fIcon;
    uint xHotspot;
    uint yHotspot;
    HANDLE hbmMask;
    HANDLE hbmColor;
};

struct ICONINFOEXW {
public:
    uint cbSize;
    int fIcon;
    uint xHotspot;
    uint yHotspot;
    HANDLE hbmMask;
    HANDLE hbmColor;
    ushort wResID;
    short szModName;
    short szResName;
};

struct ICONMETRICSW {
public:
    uint cbSize;
    int iHorzSpacing;
    int iVertSpacing;
    int iTitleWrap;
    LOGFONTW lfFont;
};

struct INPUT_INJECTION_VALUE {
public:
    ushort page;
    ushort usage;
    int value;
    ushort index;
};

struct INPUT_MESSAGE_SOURCE {
public:
    INPUT_MESSAGE_DEVICE_TYPE deviceType;
    INPUT_MESSAGE_ORIGIN_ID originId;
};

struct KBDLLHOOKSTRUCT {
public:
    uint vkCode;
    uint scanCode;
    uint flags;
    uint time;
    ulong dwExtraInfo;
};

struct KEYBDINPUT {
public:
    ushort wVk;
    ushort wScan;
    uint dwFlags;
    uint time;
    ulong dwExtraInfo;
};

struct LASTINPUTINFO {
public:
    uint cbSize;
    uint dwTime;
};

struct MDICREATESTRUCTW {
public:
    PVOID szClass;
    PVOID szTitle;
    HANDLE hOwner;
    int x;
    int y;
    int cx;
    int cy;
    uint style;
    PVOID lParam;
};

struct MDINEXTMENU {
public:
    HANDLE hmenuIn;
    HANDLE hmenuNext;
    HANDLE hwndNext;
};

struct MEASUREITEMSTRUCT {
public:
    uint CtlType;
    uint CtlID;
    uint itemID;
    uint itemWidth;
    uint itemHeight;
    ulong itemData;
};

struct MENUBARINFO {
public:
    uint cbSize;
    RECT rcBar;
    HANDLE hMenu;
    HANDLE hwndMenu;
    int Focused;
};

struct MENUGETOBJECTINFO {
public:
    uint dwFlags;
    uint uPos;
    HANDLE hmenu;
    PVOID riid;
    PVOID pvObj;
};

struct MENUINFO {
public:
    uint cbSize;
    uint fMask;
    uint dwStyle;
    uint cyMax;
    HANDLE hbrBack;
    uint dwContextHelpID;
    ulong dwMenuData;
};

struct MENUITEMINFOW {
public:
    uint cbSize;
    uint fMask;
    uint fType;
    uint fState;
    uint wID;
    HANDLE hSubMenu;
    HANDLE hbmpChecked;
    HANDLE hbmpUnchecked;
    ulong dwItemData;
    string dwTypeData;
    uint cch;
    HANDLE hbmpItem;
};

struct MENUITEMTEMPLATE {
public:
    ushort mtOption;
    ushort mtID;
    short mtString;
};

struct MENUITEMTEMPLATEHEADER {
public:
    ushort versionNumber;
    ushort offset;
};

struct MINIMIZEDMETRICS {
public:
    uint cbSize;
    int iWidth;
    int iHorzGap;
    int iVertGap;
    int iArrange;
};

struct MINMAXINFO {
public:
    POINT ptReserved;
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
};

struct MONITORINFO {
public:
    uint cbSize;
    RECT rcMonitor;
    RECT rcWork;
    uint dwFlags;
};

struct MOUSEHOOKSTRUCT {
public:
    POINT pt;
    HANDLE hwnd;
    uint wHitTestCode;
    ulong dwExtraInfo;
};

struct MOUSEHOOKSTRUCTEX : public MONITORINFO {
public:
    uint mouseData;
};

struct MOUSEKEYS {
public:
    uint cbSize;
    uint dwFlags;
    uint iMaxSpeed;
    uint iTimeToMaxSpeed;
    uint iCtrlSpeed;
    uint dwReserved1;
    uint dwReserved2;
};

struct MOUSEMOVEPOINT {
public:
    int x;
    int y;
    uint time;
    ulong dwExtraInfo;
};

struct MSG {
public:
    HANDLE hwnd;
    uint message;
    PVOID wParam;
    PVOID lParam;
    uint time;
    POINT pt;
    uint lPrivate;
};

struct MSGBOXPARAMSW {
public:
    uint cbSize;
    HANDLE hwndOwner;
    HANDLE hInstance;
    PVOID lpszText;
    PVOID lpszCaption;
    uint dwStyle;
    PVOID lpszIcon;
    uint dwContextHelpId;
    PVOID lpfnMsgBoxCallback;
    uint dwLanguageId;
};

struct MSLLHOOKSTRUCT {
public:
    POINT pt;
    uint mouseData;
    uint flags;
    uint time;
    ulong dwExtraInfo;
};

struct MULTIKEYHELPW {
public:
    short mkKeylist;
    short szKeyphrase;
};

struct NCCALCSIZE_PARAMS {
public:
    RECT rgrc;
    PVOID lppos;
};

struct NMHDR {
public:
    HANDLE hwndFrom;
    ulong idFrom;
    uint code;
};

struct NONCLIENTMETRICSW {
public:
    uint cbSize;
    int iBorderWidth;
    int iScrollWidth;
    int iScrollHeight;
    int iCaptionWidth;
    int iCaptionHeight;
    LOGFONTW lfCaptionFont;
    int iSmCaptionWidth;
    int iSmCaptionHeight;
    LOGFONTW lfSmCaptionFont;
    int iMenuWidth;
    int iMenuHeight;
    LOGFONTW lfMenuFont;
    LOGFONTW lfStatusFont;
    LOGFONTW lfMessageFont;
    int iPaddedBorderWidth;
};

struct PAINTSTRUCT {
public:
    HANDLE hdc;
    int fErase;
    RECT rcPaint;
    int fRestore;
    int fIncUpdate;
    uchar rgbReserved;
};

struct POINTER_DEVICE_CURSOR_INFO {
public:
    uint cursorId;
    POINTER_DEVICE_CURSOR_TYPE cursor;
};

struct POINTER_DEVICE_PROPERTY {
public:
    int logicalMin;
    int logicalMax;
    int physicalMin;
    int physicalMax;
    uint unit;
    uint unitExponent;
    ushort usagePageId;
    ushort usageId;
};

struct POINTER_INFO {
public:
    uint pointerType;
    uint pointerId;
    uint frameId;
    uint pointerFlags;
    HANDLE sourceDevice;
    HANDLE hwndTarget;
    POINT ptPixelLocation;
    POINT ptHimetricLocation;
    POINT ptPixelLocationRaw;
    POINT ptHimetricLocationRaw;
    uint dwTime;
    uint historyCount;
    int InputData;
    uint dwKeyStates;
    ulong PerformanceCount;
    POINTER_BUTTON_CHANGE_TYPE ButtonChangeType;
};

struct POINTER_PEN_INFO {
public:
    POINTER_INFO pointerInfo;
    uint penFlags;
    uint penMask;
    uint pressure;
    uint rotation;
    int tiltX;
    int tiltY;
};

struct POINTER_TOUCH_INFO {
public:
    POINTER_INFO pointerInfo;
    uint touchFlags;
    uint touchMask;
    RECT rcContact;
    RECT rcContactRaw;
    uint orientation;
    uint pressure;
};

struct POWERBROADCAST_SETTING {
public:
    GUID PowerSetting;
    uint DataLength;
    uchar Data;
};

struct RAWINPUTDEVICE {
public:
    ushort usUsagePage;
    ushort usUsage;
    uint dwFlags;
    HANDLE hwndTarget;
};

struct RAWINPUTDEVICELIST {
public:
    HANDLE hDevice;
    uint dwType;
};

struct RAWINPUTHEADER {
public:
    uint dwType;
    uint dwSize;
    HANDLE hDevice;
    PVOID wParam;
};

struct RID_DEVICE_INFO_HID {
public:
    uint dwVendorId;
    uint dwProductId;
    uint dwVersionNumber;
    ushort usUsagePage;
    ushort usUsage;
};

struct RID_DEVICE_INFO_KEYBOARD {
public:
    uint dwType;
    uint dwSubType;
    uint dwKeyboardMode;
    uint dwNumberOfFunctionKeys;
    uint dwNumberOfIndicators;
    uint dwNumberOfKeysTotal;
};

struct RID_DEVICE_INFO_MOUSE {
public:
    uint dwId;
    uint dwNumberOfButtons;
    uint dwSampleRate;
    int fHasHorizontalWheel;
};

struct SCROLLBARINFO {
public:
    uint cbSize;
    RECT rcScrollBar;
    int dxyLineButton;
    int xyThumbTop;
    int xyThumbBottom;
    int reserved;
};

struct SCROLLINFO {
public:
    uint cbSize;
    uint fMask;
    int nMin;
    int nMax;
    uint nPage;
    int nPos;
    int nTrackPos;
};

struct SERIALKEYSW {
public:
    uint cbSize;
    uint dwFlags;
    string lpszActivePort;
    string lpszPort;
    uint iBaudRate;
    uint iPortState;
    uint iActive;
};

struct SHELLHOOKINFO {
public:
    HANDLE hwnd;
    RECT rc;
};

struct SOUNDSENTRYW {
public:
    uint cbSize;
    uint dwFlags;
    uint iFSTextEffect;
    uint iFSTextEffectMSec;
    uint iFSTextEffectColorBits;
    uint iFSGrafEffect;
    uint iFSGrafEffectMSec;
    uint iFSGrafEffectColor;
    uint iWindowsEffect;
    uint iWindowsEffectMSec;
    string lpszWindowsEffectDLL;
    uint iWindowsEffectOrdinal;
};

struct STICKYKEYS {
public:
    uint cbSize;
    uint dwFlags;
};

struct STYLESTRUCT {
public:
    uint styleOld;
    uint styleNew;
};

struct TITLEBARINFO {
public:
    uint cbSize;
    RECT rcTitleBar;
};

struct TITLEBARINFOEX {
public:
    uint cbSize;
    RECT rcTitleBar;
};

struct TOGGLEKEYS {
public:
    uint cbSize;
    uint dwFlags;
};

struct TOUCH_HIT_TESTING_INPUT {
public:
    uint pointerId;
    POINT point;
    RECT boundingBox;
    RECT nonOccludedBoundingBox;
    uint orientation;
};

struct TOUCH_HIT_TESTING_PROXIMITY_EVALUATION {
public:
    ushort score;
    POINT adjustedPoint;
};

struct TOUCHINPUT {
public:
    int x;
    int y;
    HANDLE hSource;
    uint dwID;
    uint dwFlags;
    uint dwMask;
    uint dwTime;
    ulong dwExtraInfo;
    uint cxContact;
    uint cyContact;
};

struct TOUCHPREDICTIONPARAMETERS {
public:
    uint cbSize;
    uint dwLatency;
    uint dwSampleTime;
    uint bUseHWTimeStamp;
};

struct TPMPARAMS {
public:
    uint cbSize;
    RECT rcExclude;
};

struct TRACKMOUSEEVENT {
public:
    uint cbSize;
    uint dwFlags;
    HANDLE hwndTrack;
    uint dwHoverTime;
};

struct UPDATELAYEREDWINDOWINFO {
public:
    uint cbSize;
    HANDLE hdcDst;
    HANDLE hdcSrc;
    uint crKey;
    uint dwFlags;
};

struct USAGE_PROPERTIES {
public:
    ushort level;
    ushort page;
    ushort usage;
    int logicalMinimum;
    int logicalMaximum;
    ushort unit;
    ushort exponent;
    uchar count;
    int physicalMinimum;
    int physicalMaximum;
};

struct USEROBJECTFLAGS {
public:
    int fInherit;
    int fReserved;
    uint dwFlags;
};

struct WINDOWINFO {
public:
    uint cbSize;
    RECT rcWindow;
    RECT rcClient;
    uint dwStyle;
    uint dwExStyle;
    uint dwWindowStatus;
    uint cxWindowBorders;
    uint cyWindowBorders;
    ushort atomWindowType;
    ushort wCreatorVersion;
};

struct WINDOWPLACEMENT {
public:
    uint length;
    uint flags;
    uint showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT rcNormalPosition;
    RECT rcDevice;
};

struct WINDOWPOS {
public:
    HANDLE hwnd;
    HANDLE hwndInsertAfter;
    int x;
    int y;
    int cx;
    int cy;
    uint flags;
};

struct WTSSESSION_NOTIFICATION {
public:
    uint cbSize;
    uint dwSessionId;
};

struct RAWKEYBOARD {
public:
    ushort MakeCode;
    ushort Flags;
    ushort Reserved;
    ushort VKey;
    uint Message;
    uint ExtraInformation;
};

struct RAWHID {
public:
    uint dwSizeHid;
    uint dwCount;
    uchar bRawData;
};

struct RAWINPUT {
public:
    RAWINPUTHEADER header;
    RAWFORMAT data;
};

struct INPUT_TRANSFORM {
public:
    float _11;
    float _12;
    float _13;
    float _14;
    float _21;
    float _22;
    float _23;
    float _24;
    float _31;
    float _32;
    float _33;
    float _34;
    float _41;
    float _42;
    float _43;
    float _44;
};

struct MENUITEMINFO {
public:
    uint cbSize;
    uint fMask;
    uint fType;
    uint fState;
    uint wID;
    HANDLE hSubMenu;
    HANDLE hbmpChecked;
    HANDLE hbmpUnchecked;
    uint dwItemData;
    string dwTypeData;
    uint cch;
};

struct INPUT {
public:
    uint type;
    INPUT_TYPE in;
};

#endif // __clang__
